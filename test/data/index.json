[{"categories":[""],"content":"Refs 博客:https://guzhongren.github.io/ ","date":"2022-09-30","objectID":"/2022/09/%E4%B8%80%E4%BA%9B%E5%81%9A%E8%BF%90%E7%BB%B4%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%B0%8F%E6%80%BB%E7%BB%93/:1:0","tags":[""],"title":"一些做运维工作的小总结","uri":"/2022/09/%E4%B8%80%E4%BA%9B%E5%81%9A%E8%BF%90%E7%BB%B4%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%B0%8F%E6%80%BB%E7%BB%93/"},{"categories":[""],"content":"Disclaimer 本文仅代表个人观点，与 Thoughtworks 公司无任何关系。 SHA256 checksum: f2fe1394e4ab9297ed69ff73ac32e9ac1375f01c2102183b509bf9379a5995d6 ","date":"2022-09-30","objectID":"/2022/09/%E4%B8%80%E4%BA%9B%E5%81%9A%E8%BF%90%E7%BB%B4%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%B0%8F%E6%80%BB%E7%BB%93/:2:0","tags":[""],"title":"一些做运维工作的小总结","uri":"/2022/09/%E4%B8%80%E4%BA%9B%E5%81%9A%E8%BF%90%E7%BB%B4%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%B0%8F%E6%80%BB%E7%BB%93/"},{"categories":[""],"content":"赞助 SHA256 checksum: 964978ecd2059064abe542e51dc02e204d3ee2e6c320ca68e2b1399ce0c6953c 使用此文件进行校验： gpg --verify PayForGuzhongren.svg.sig ","date":"2022-09-30","objectID":"/2022/09/%E4%B8%80%E4%BA%9B%E5%81%9A%E8%BF%90%E7%BB%B4%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%B0%8F%E6%80%BB%E7%BB%93/:3:0","tags":[""],"title":"一些做运维工作的小总结","uri":"/2022/09/%E4%B8%80%E4%BA%9B%E5%81%9A%E8%BF%90%E7%BB%B4%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%B0%8F%E6%80%BB%E7%BB%93/"},{"categories":["Engineering"],"content":"Don't spend your time on logging","date":"2022-08-05","objectID":"/2022/08/some-good-practices-of-logging/","tags":["Engineering","logging","log","conversion"],"title":"Some Good Practices of Logging","uri":"/2022/08/some-good-practices-of-logging/"},{"categories":["Engineering"],"content":"Introduction Logging is structured or unstructured text information generated by the system during operation. Usually, it can be regarded as a record of an event by the application. Logging can often help us discover unexpected behaviors in systems, especially in some microservice architecture systems. As an important part of Observability, Logging plays an irreplaceable role in our system development and maintenance. ","date":"2022-08-05","objectID":"/2022/08/some-good-practices-of-logging/:1:0","tags":["Engineering","logging","log","conversion"],"title":"Some Good Practices of Logging","uri":"/2022/08/some-good-practices-of-logging/"},{"categories":["Engineering"],"content":"The importance of logging To understand why logging plays an important role in products or systems, we must understand its value. Currently, the most widely used logging forms are alerting, troubleshooting, and business data visualization. ","date":"2022-08-05","objectID":"/2022/08/some-good-practices-of-logging/:2:0","tags":["Engineering","logging","log","conversion"],"title":"Some Good Practices of Logging","uri":"/2022/08/some-good-practices-of-logging/"},{"categories":["Engineering"],"content":"Alerting Logging can be used as an important data source for our business system monitoring; mature product systems have alarm systems. If there is a problem exceeding a certain defined indicator in the system, the log system will automatically send the alarm information to the notification platform. The On-call people can locate and solve the problem according to the alarm information. ","date":"2022-08-05","objectID":"/2022/08/some-good-practices-of-logging/:2:1","tags":["Engineering","logging","log","conversion"],"title":"Some Good Practices of Logging","uri":"/2022/08/some-good-practices-of-logging/"},{"categories":["Engineering"],"content":"Troubleshooting Imagine that the system you are responsible for developing and maintaining is found to be faulty. What is the first thing you should do? Check the system information to verify that it’s true. The log printed on the server is the best auxiliary information. As programmers, logs are the most familiar tool for solving problems. ","date":"2022-08-05","objectID":"/2022/08/some-good-practices-of-logging/:2:2","tags":["Engineering","logging","log","conversion"],"title":"Some Good Practices of Logging","uri":"/2022/08/some-good-practices-of-logging/"},{"categories":["Engineering"],"content":"Business Data Visualization Many companies can use the logs of the production environment stored in their own databases to visualize business data in combination with the corresponding tools such as Grafana and SumoLogic. ","date":"2022-08-05","objectID":"/2022/08/some-good-practices-of-logging/:2:3","tags":["Engineering","logging","log","conversion"],"title":"Some Good Practices of Logging","uri":"/2022/08/some-good-practices-of-logging/"},{"categories":["Engineering"],"content":"Logging how-to ","date":"2022-08-05","objectID":"/2022/08/some-good-practices-of-logging/:3:0","tags":["Engineering","logging","log","conversion"],"title":"Some Good Practices of Logging","uri":"/2022/08/some-good-practices-of-logging/"},{"categories":["Engineering"],"content":"Templating It’s necessary to sort out our log format and write logs according to certain specifications. Basic template At minimum, qualified logs should have the following information: time, log level, and log information. Advanced Template Add thread name, hostname, method name, class name, and the number of lines corresponding to the method; Thread Name: Most applications don’t have a single user. For a single-instance service, many users accessing the same interface will execute the application in different threads. So using the thread name is best to differentiate the business process of corresponding users. Hostname: Most current applications are deployed in the cloud with multiple instances, so on the basis of a single node, the logging needs to be distinguished at the instance level on multiple instances, and the hostname is the best way to differentiate. Method Name: A convenient way to differentiate the source within the same log. Class Name: A convenient way to quickly locate the business process. Number of lines: A quick way to find the specific location of the log. ","date":"2022-08-05","objectID":"/2022/08/some-good-practices-of-logging/:3:1","tags":["Engineering","logging","log","conversion"],"title":"Some Good Practices of Logging","uri":"/2022/08/some-good-practices-of-logging/"},{"categories":["Engineering"],"content":"Formatting To improve the readability of the log, we can focus on formatting. Put square brackets around the log level, host name, and thread name; Add parentheses to the class name and line number where the method name is located, and separate the class name and line number with a colon; Add a horizontal line between the line number and log information; Specific formatting is also possible for log information: For regular requests, response or other business logs, you can separate custom information and parameters with an underscore; multiple parameters are separated by commas; For error message formatting, you can use Key:Value. ","date":"2022-08-05","objectID":"/2022/08/some-good-practices-of-logging/:3:2","tags":["Engineering","logging","log","conversion"],"title":"Some Good Practices of Logging","uri":"/2022/08/some-good-practices-of-logging/"},{"categories":["Engineering"],"content":"Chain-Tracking If the recorded log is just a simple text description line by line, it’ll be hard to read. In a complex system or a system with frequent business operations, there will be multiple logs and we’ll have to spend time filtering out the relevant logs. The best way to solve this problem is through chain tracking of logs: putting one or more unique IDs in the business system that are added to each log, so that when locating business problems, we can quickly filter out the relevant logs through these unique IDs and Other criteria (e.g. time). ","date":"2022-08-05","objectID":"/2022/08/some-good-practices-of-logging/:3:3","tags":["Engineering","logging","log","conversion"],"title":"Some Good Practices of Logging","uri":"/2022/08/some-good-practices-of-logging/"},{"categories":["Engineering"],"content":"Logging on demand Log level The output of the log is divided into levels.Different scenarios need to print different levels of logs. Debug: Record technical details and logs to help understand the system operation; Info: Record business information; Warn: Acceptable error messages that are manageable and not urgent; Error: Unexpected errors or system behavior, usually caused by system bugs or environmental problems. At the same time, not all logs need to be recorded, we need to record as needed. The following table shows which logs should be recorded depending on the environment. Environment Log Leave Dev Debug Test Debug UAT Info Prod Info Logging position The location of the log print also needs to be made clear. When other systems call their own systems, they need to print the log once each when they receive a request and when the request is completed; The log is printed once before the self-hosted system calls the interface of the third-party system and after receiving the response; The log needs to be printed in any abnormal place in the system. ","date":"2022-08-05","objectID":"/2022/08/some-good-practices-of-logging/:3:4","tags":["Engineering","logging","log","conversion"],"title":"Some Good Practices of Logging","uri":"/2022/08/some-good-practices-of-logging/"},{"categories":["Engineering"],"content":"Tool recommendation Different programming languages have different logging tools; the most famous is Apache’s Log4j, which is highly configurable and can be configured via external files at runtime. It is based on logging priority and provides mechanisms to instruct logging information to many destinations such as database, file, console, UNIX system log, etc.; log4j has been ported to other programming languages, such as logging in Python, log4js in NodeJS, log4rs in Rust. ","date":"2022-08-05","objectID":"/2022/08/some-good-practices-of-logging/:4:0","tags":["Engineering","logging","log","conversion"],"title":"Some Good Practices of Logging","uri":"/2022/08/some-good-practices-of-logging/"},{"categories":["Engineering"],"content":"Tips Avoid printing or recording any sensitive information, including but not limited to various PII, PCI information. Remember to obey local laws and regulations, such as China’s PILI (Personal Information Protection Law) or Europe’s GDPR (General Data Protection Regulation). Choose the appropriate log level and log position as needed. …… ","date":"2022-08-05","objectID":"/2022/08/some-good-practices-of-logging/:5:0","tags":["Engineering","logging","log","conversion"],"title":"Some Good Practices of Logging","uri":"/2022/08/some-good-practices-of-logging/"},{"categories":["Engineering"],"content":"Summary A good log can not only facilitate program development and provide the most important auxiliary information for troubleshooting, it also gives optimization suggestions or data statistics for business or infrastructure. ","date":"2022-08-05","objectID":"/2022/08/some-good-practices-of-logging/:6:0","tags":["Engineering","logging","log","conversion"],"title":"Some Good Practices of Logging","uri":"/2022/08/some-good-practices-of-logging/"},{"categories":["Engineering"],"content":"Refs 博客:https://guzhongren.github.io/ ","date":"2022-08-05","objectID":"/2022/08/some-good-practices-of-logging/:7:0","tags":["Engineering","logging","log","conversion"],"title":"Some Good Practices of Logging","uri":"/2022/08/some-good-practices-of-logging/"},{"categories":["Engineering"],"content":"Disclaimer 本文仅代表个人观点，与 Thoughtworks 公司无任何关系。 SHA256 checksum: f2fe1394e4ab9297ed69ff73ac32e9ac1375f01c2102183b509bf9379a5995d6 ","date":"2022-08-05","objectID":"/2022/08/some-good-practices-of-logging/:8:0","tags":["Engineering","logging","log","conversion"],"title":"Some Good Practices of Logging","uri":"/2022/08/some-good-practices-of-logging/"},{"categories":["Engineering"],"content":"赞助 SHA256 checksum: 964978ecd2059064abe542e51dc02e204d3ee2e6c320ca68e2b1399ce0c6953c 使用此文件进行校验： gpg --verify PayForGuzhongren.svg.sig ","date":"2022-08-05","objectID":"/2022/08/some-good-practices-of-logging/:9:0","tags":["Engineering","logging","log","conversion"],"title":"Some Good Practices of Logging","uri":"/2022/08/some-good-practices-of-logging/"},{"categories":["Tool"],"content":"Why 有时候我们用 DrawIO 在线版或者 VSCode 插件画图的时候，需要使用自己公司的配色和字体要求来做图；如果一个一个图形的选择，然后输入对应的样式值，这样很浪费时间；作为高效能人士，肯定需要将其形成模板存起来，使用的时候自动读取即可。所谓“一劳永逸”。 最近，写了一片博客，需要将博客里的图用公司的规范来做画，那么就得定制属于我们自己公司规范的样式。 ","date":"2022-07-27","objectID":"/2022/07/%E5%AE%9A%E5%88%B6%E4%BD%A0%E7%9A%84drawio%E6%A0%B7%E5%BC%8F/:1:0","tags":["drawio","thoughtworks","color","Palettes"],"title":"定制你的DrawIO样式","uri":"/2022/07/%E5%AE%9A%E5%88%B6%E4%BD%A0%E7%9A%84drawio%E6%A0%B7%E5%BC%8F/"},{"categories":["Tool"],"content":"What 在研究了https://app.diagrams.net/ 的配置说明后，发现其实定制很容易。只需要在配置中覆盖原有的样式即可。 而对于VS Code 的插件，拿vscode-drawio来说，只要在配置中键入自己的配置即可。 当然开始之前需要有自己的规范，如配色或字体等。 ","date":"2022-07-27","objectID":"/2022/07/%E5%AE%9A%E5%88%B6%E4%BD%A0%E7%9A%84drawio%E6%A0%B7%E5%BC%8F/:2:0","tags":["drawio","thoughtworks","color","Palettes"],"title":"定制你的DrawIO样式","uri":"/2022/07/%E5%AE%9A%E5%88%B6%E4%BD%A0%E7%9A%84drawio%E6%A0%B7%E5%BC%8F/"},{"categories":["Tool"],"content":"How ","date":"2022-07-27","objectID":"/2022/07/%E5%AE%9A%E5%88%B6%E4%BD%A0%E7%9A%84drawio%E6%A0%B7%E5%BC%8F/:3:0","tags":["drawio","thoughtworks","color","Palettes"],"title":"定制你的DrawIO样式","uri":"/2022/07/%E5%AE%9A%E5%88%B6%E4%BD%A0%E7%9A%84drawio%E6%A0%B7%E5%BC%8F/"},{"categories":["Tool"],"content":"Web 版 配置位置 应用-其他-配置 配置信息 { \"customFonts\": [ \"Noto Serif SC\", \"Bitter\", \"Arial\", \"Inter\" ], \"presetColors\": [ \"none\", \"000000\", \"ffffff\", \"666666\", \"edf1f3\", \"003d4f\", \"f2617a\", \"cc850a\", \"6b9e78\", \"47a1ad\", \"634f7d\" ], \"customColorSchemes\": [ [ { \"fill\": \"#ffffff\", \"stroke\": \"#ffffff\" }, { \"fill\": \"#003d4f\", \"stroke\": \"#003d4f\" }, { \"fill\": \"#f2617a\", \"stroke\": \"#f2617a\" }, { \"fill\": \"#cc850a\", \"stroke\": \"#cc850a\" }, { \"fill\": \"#6b9e78\", \"stroke\": \"#6b9e78\" }, { \"fill\": \"#47a1ad\", \"stroke\": \"#47a1ad\" }, { \"fill\": \"#634f7d\", \"stroke\": \"#634f7d\" }, { \"fill\": \"#000000\", \"stroke\": \"#000000\" } ] ] } 效果 ","date":"2022-07-27","objectID":"/2022/07/%E5%AE%9A%E5%88%B6%E4%BD%A0%E7%9A%84drawio%E6%A0%B7%E5%BC%8F/:3:1","tags":["drawio","thoughtworks","color","Palettes"],"title":"定制你的DrawIO样式","uri":"/2022/07/%E5%AE%9A%E5%88%B6%E4%BD%A0%E7%9A%84drawio%E6%A0%B7%E5%BC%8F/"},{"categories":["Tool"],"content":"VS Code 插件版（vscode-drawio） 配置信息 对于插件版本，我们可以将配置信息存储在全局（VS Code菜单-Code-Performances-Setting, 搜索 drawio, 点击任意Edit in settings.json）或者当前工程（.vscode/settings.json）,然后将如下配置粘贴进去。 \"hediet.vscode-drawio.presetColors\": [ \"none\", \"000000\", \"ffffff\", \"666666\", \"edf1f3\", \"003d4f\", \"f2617a\", \"cc850a\", \"6b9e78\", \"47a1ad\", \"634f7d\" ], \"hediet.vscode-drawio.colorNames\": { \"000000\": \"Onyx black\", \"ffffff\": \"Talc white\", \"666666\": \"文字和背景3\", \"edf1f3\": \"Mist grey\", \"003d4f\": \"Wave blue\", \"f2617a\": \"Flamingo pink\", \"cc850a\": \"Turmeric yellow\", \"6b9e78\": \"Jade green\", \"47a1ad\": \"Sapphire blue\", \"634f7d\": \"Amethyst purple\" }, \"hediet.vscode-drawio.customColorSchemes\": [ [ { \"fill\": \"#ffffff\", \"stroke\": \"#ffffff\" }, { \"fill\": \"#003d4f\", \"stroke\": \"#003d4f\" }, { \"fill\": \"#f2617a\", \"stroke\": \"#f2617a\" }, { \"fill\": \"#cc850a\", \"stroke\": \"#cc850a\" }, { \"fill\": \"#6b9e78\", \"stroke\": \"#6b9e78\" }, { \"fill\": \"#47a1ad\", \"stroke\": \"#47a1ad\" }, { \"fill\": \"#634f7d\", \"stroke\": \"#634f7d\" }, { \"fill\": \"#000000\", \"stroke\": \"#000000\" } ] ], \"hediet.vscode-drawio.customFonts\": [ \"Noto Serif SC\", \"Bitter\", \"Arial\", \"Inter\" ], 效果 ","date":"2022-07-27","objectID":"/2022/07/%E5%AE%9A%E5%88%B6%E4%BD%A0%E7%9A%84drawio%E6%A0%B7%E5%BC%8F/:3:2","tags":["drawio","thoughtworks","color","Palettes"],"title":"定制你的DrawIO样式","uri":"/2022/07/%E5%AE%9A%E5%88%B6%E4%BD%A0%E7%9A%84drawio%E6%A0%B7%E5%BC%8F/"},{"categories":["Tool"],"content":"Refs 博客: https://guzhongren.github.io/ diagrams.net: https://www.diagrams.net/doc/faq/configure-diagram-editor vscode-drawio: https://marketplace.visualstudio.com/items?itemName=eightHundreds.vscode-drawio ","date":"2022-07-27","objectID":"/2022/07/%E5%AE%9A%E5%88%B6%E4%BD%A0%E7%9A%84drawio%E6%A0%B7%E5%BC%8F/:4:0","tags":["drawio","thoughtworks","color","Palettes"],"title":"定制你的DrawIO样式","uri":"/2022/07/%E5%AE%9A%E5%88%B6%E4%BD%A0%E7%9A%84drawio%E6%A0%B7%E5%BC%8F/"},{"categories":["Tool"],"content":"Disclaimer 本文仅代表个人观点，与 Thoughtworks 公司无任何关系。 SHA256 checksum: f2fe1394e4ab9297ed69ff73ac32e9ac1375f01c2102183b509bf9379a5995d6 ","date":"2022-07-27","objectID":"/2022/07/%E5%AE%9A%E5%88%B6%E4%BD%A0%E7%9A%84drawio%E6%A0%B7%E5%BC%8F/:5:0","tags":["drawio","thoughtworks","color","Palettes"],"title":"定制你的DrawIO样式","uri":"/2022/07/%E5%AE%9A%E5%88%B6%E4%BD%A0%E7%9A%84drawio%E6%A0%B7%E5%BC%8F/"},{"categories":["Tool"],"content":"赞助 SHA256 checksum: 964978ecd2059064abe542e51dc02e204d3ee2e6c320ca68e2b1399ce0c6953c 使用此文件进行校验： gpg --verify PayForGuzhongren.svg.sig ","date":"2022-07-27","objectID":"/2022/07/%E5%AE%9A%E5%88%B6%E4%BD%A0%E7%9A%84drawio%E6%A0%B7%E5%BC%8F/:6:0","tags":["drawio","thoughtworks","color","Palettes"],"title":"定制你的DrawIO样式","uri":"/2022/07/%E5%AE%9A%E5%88%B6%E4%BD%A0%E7%9A%84drawio%E6%A0%B7%E5%BC%8F/"},{"categories":["Engineering"],"content":"不要把时间浪费在日志格式上","date":"2022-07-10","objectID":"/2022/07/%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/","tags":["Engineering","logging","log","conversion"],"title":"日志记录的最佳实践","uri":"/2022/07/%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"},{"categories":["Engineering"],"content":"简介 日志（Log）是由系统在运行过程中产生的结构化或者非结构化的文字信息。通常情况，可以将其视为应用程序对某个事件（Event）的记录。日志通常可以帮助我们发现一些微服务架构系统的非预期或突发的行为。 Logging作为 Observability的重要组成部分，在我们的系统开发、维护中起到无法替代的作用。 ","date":"2022-07-10","objectID":"/2022/07/%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/:1:0","tags":["Engineering","logging","log","conversion"],"title":"日志记录的最佳实践","uri":"/2022/07/%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"},{"categories":["Engineering"],"content":"日志的重要性 要理解为什么日志在产品或者系统中扮演着重要的角色，我们必须了解它的价值。至少到现在，日志被应用最广泛的是报警、故障排除和业务数据可视化。 ","date":"2022-07-10","objectID":"/2022/07/%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/:2:0","tags":["Engineering","logging","log","conversion"],"title":"日志记录的最佳实践","uri":"/2022/07/%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"},{"categories":["Engineering"],"content":"报警 日志可以作为我们业务系统监控的重要数据来源；成熟的产品系统都有报警系统，如果系统中出现超过某个已定义的某个指标的问题，日志系统会自动将报警信息发送到通知平台，On-call 的人就可以根据报警信息定位解决问题了。 ","date":"2022-07-10","objectID":"/2022/07/%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/:2:1","tags":["Engineering","logging","log","conversion"],"title":"日志记录的最佳实践","uri":"/2022/07/%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"},{"categories":["Engineering"],"content":"故障排除 这种情况非常普遍；想象一下你最近负责开发维护的系统被他人发现有问题，在你梳理完思路之后第一件事是干什么？ 肯定是查看系统信息验证自己的假设是否成立， 这里打印在服务器上的日志就是最好的辅助信息。而作为程序员的我们，日志是我们最熟悉不过的解决问题的利器。 ","date":"2022-07-10","objectID":"/2022/07/%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/:2:2","tags":["Engineering","logging","log","conversion"],"title":"日志记录的最佳实践","uri":"/2022/07/%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"},{"categories":["Engineering"],"content":"业务数据可视化 很多公司可以利用存储在自己数据库里的生产环境的日志，结合相应的工具可以对业务进行业务数据可视化。这里最典型的代表是 Grafana 和 SumoLogic。 ","date":"2022-07-10","objectID":"/2022/07/%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/:2:3","tags":["Engineering","logging","log","conversion"],"title":"日志记录的最佳实践","uri":"/2022/07/%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"},{"categories":["Engineering"],"content":"怎么做 ","date":"2022-07-10","objectID":"/2022/07/%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/:3:0","tags":["Engineering","logging","log","conversion"],"title":"日志记录的最佳实践","uri":"/2022/07/%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"},{"categories":["Engineering"],"content":"模版化 为了更好的支持上面的各种情况，我们需要对我们的日志格式进行梳理，按照一定的规范来写日志，而不是随便写一句废话。 基础版本 对于日志，时间，日志级别，和日志信息最为重要，所以一个合格的日志应该至少包含这些信息。 高级版本 在基础版的基础上，加入线程名，方法名，类名，方法对应的行数； 线程名： 多数应用的用户都不是单一的，对于单实例的服务对同一个接口很多用户访问应用会将在不同的线程中执行，这时如果要区分对应用户的业务流程，那么通过线程名是最好的。 主机名：现在的应用大都部署在 Cloud 中都是多实例的，所以在单节点的基础上，日志在多实例上就需要实例级别的区分，而主机名是最好的区分方式。 方法名： 打印了日志的方法名，方便区分相同日志的出处。 类名： 打印了日志的类名，方便快速定位业务流程。 行数：打印了日志的行数，方便快速定位日志的具体位置。 ","date":"2022-07-10","objectID":"/2022/07/%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/:3:1","tags":["Engineering","logging","log","conversion"],"title":"日志记录的最佳实践","uri":"/2022/07/%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"},{"categories":["Engineering"],"content":"格式化 为了提高日志的可读性，我们可以对日志进行修饰。 对日志级别、主机名和线程名前后加中括号； 对方法名所在的类名和行号加括号，并在类名与行号中间用冒号隔开； 在行号和日志信息中间加入一个横线来分割； 对于日志信息也可以进行特定的格式化 对于常规的请求（Request）、响应（Response）或者其他业务日志，可以在自定义信息和参数之间用下划线分割；多个参数之间用逗号分隔，当然参数也是可选的； 对于错误信息格式化，也可以按照 Key：Value 的形式进行组织。 ","date":"2022-07-10","objectID":"/2022/07/%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/:3:2","tags":["Engineering","logging","log","conversion"],"title":"日志记录的最佳实践","uri":"/2022/07/%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"},{"categories":["Engineering"],"content":"链式追踪 记录下了日志，如果只是一行行简单的文字说明，那是没有太大意义的。在复杂系统或业务操作频繁的系统中，会产生非常多的日志，在这种情况下，我们就得花时间去过滤出相关的日志。 解决上面问题的最好办法是日志的链式追踪；简单说就是，在每条日志中加入业务系统中的一个或者多个唯一的 ID，这样在定位业务问题的时候可以通过这些唯一的 ID 和 其他条件（e.g. 时间）快速过滤出相关的日志。 ","date":"2022-07-10","objectID":"/2022/07/%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/:3:3","tags":["Engineering","logging","log","conversion"],"title":"日志记录的最佳实践","uri":"/2022/07/%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"},{"categories":["Engineering"],"content":"按需记录日志 日志级别 日志的输出都是分级别的，不同的场景需要打印不同级别的日志；以下是几个比较重要的日志级别。 Debug: 记录技术细节，和一些帮助理解系统运行的日志; Info: 记录业务信息的日志; Warn: 非紧急且可控的可接受的错误信息; Error: 非期望的错误或者系统表现，通常是由系统bug或者环境问题导致。 同时不是所有的日志都需要记录，我们要做到按需记录。下表是推荐在不同的环境选择不同的日志级别。 Environment Log Leave Dev Debug Test Debug UAT Info Prod Info 日志位置 有了日志级别，日志打印的位置也需要明确。一般情况下： 其他系统调用自有系统时需要在收到请求和完成请求时各打印一次日志； 自有系统调用第三方系统的接口前和收到返回信息后各打印一次日志； 在系统任何有异常的地方需要打印日志； 还有一种特殊情况是，像消息传递之类的系统，为了节省日志存储和减少查看干扰，大多时候我们不需要在收到消息后直接打印该消息，一般建议在收到消息后，如果系统处理有异常，在异常中将原始消息打印。 ","date":"2022-07-10","objectID":"/2022/07/%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/:3:4","tags":["Engineering","logging","log","conversion"],"title":"日志记录的最佳实践","uri":"/2022/07/%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"},{"categories":["Engineering"],"content":"工具推荐 不同的编程语言有不同的日志工具；比较著名的是 Apache 的 Log4j, Log4j是高度可配置的，并可通过在运行时的外部文件配置。它根据记录的优先级别，并提供机制以指示记录信息到许多的目的地，诸如：数据库，文件，控制台，UNIX系统日志等；而且 log4j 已经被移植到了其他编程语言中了，如 Python 中的 logging, NodeJS 中的log4js, Rust 中的log4rs。 ","date":"2022-07-10","objectID":"/2022/07/%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/:4:0","tags":["Engineering","logging","log","conversion"],"title":"日志记录的最佳实践","uri":"/2022/07/%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"},{"categories":["Engineering"],"content":"注意点 避免打印或记录任何敏感信息，包括但不限于各种PII，PCI信息，一定要记得遵守当地的各种法律法规，如中国的《个人信息保护法》（PILI）, 欧洲的一般数据保护条例GDPR等 按需选择合适的日志级别和日志位置 …… ","date":"2022-07-10","objectID":"/2022/07/%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/:5:0","tags":["Engineering","logging","log","conversion"],"title":"日志记录的最佳实践","uri":"/2022/07/%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"},{"categories":["Engineering"],"content":"总结 好的日志不仅可以为程序开发提供便利，为故障排除提供最重要的辅助信息，更可以为业务或基础设施提供优化建议或数据统计。 ","date":"2022-07-10","objectID":"/2022/07/%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/:6:0","tags":["Engineering","logging","log","conversion"],"title":"日志记录的最佳实践","uri":"/2022/07/%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"},{"categories":["Engineering"],"content":"Refs THE TOP 25 GRAFANA DASHBOARD EXAMPLES Grafana lab SumoLogic Log4j ","date":"2022-07-10","objectID":"/2022/07/%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/:7:0","tags":["Engineering","logging","log","conversion"],"title":"日志记录的最佳实践","uri":"/2022/07/%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"},{"categories":["Engineering"],"content":"Disclaimer 本文仅代表个人观点，与 Thoughtworks 公司无任何关系。 SHA256 checksum: f2fe1394e4ab9297ed69ff73ac32e9ac1375f01c2102183b509bf9379a5995d6 ","date":"2022-07-10","objectID":"/2022/07/%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/:8:0","tags":["Engineering","logging","log","conversion"],"title":"日志记录的最佳实践","uri":"/2022/07/%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"},{"categories":["Engineering"],"content":"赞助 SHA256 checksum: 964978ecd2059064abe542e51dc02e204d3ee2e6c320ca68e2b1399ce0c6953c 使用此文件进行校验： gpg --verify PayForGuzhongren.svg.sig ","date":"2022-07-10","objectID":"/2022/07/%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/:9:0","tags":["Engineering","logging","log","conversion"],"title":"日志记录的最佳实践","uri":"/2022/07/%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"},{"categories":["Agile"],"content":" 勿以恶小而为之，勿以善小而不为 –《三国志·蜀志传》 ","date":"2022-06-23","objectID":"/2022/06/%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E5%92%8Cdora-metrics-%E5%93%AA%E4%B8%AA%E6%9B%B4%E9%87%8D%E8%A6%81/:0:0","tags":["Dora Metrics","Code Quality","4 Key Metrics","代码质量"],"title":"代码质量和Dora Metrics， 哪个更重要？","uri":"/2022/06/%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E5%92%8Cdora-metrics-%E5%93%AA%E4%B8%AA%E6%9B%B4%E9%87%8D%E8%A6%81/"},{"categories":["Agile"],"content":"起因 最近在项目上搞代码质量方面的工作，发现项目代码运行测试后不能生成测试报告，导致 SonarQube 上没有关于测试覆盖率的Metric, 而且Pipeline 还可以正确运行，并没有因为不满足 SonarQube 的 Quality Gate 而 break Pipeline 的运行。 不能生成测试报告这个问题简单，只是因为运行测试的容器的用户对特定的目录没有权限，这个很好解决。 但是对于SonarQube 不能 break Pipeline 这点组内有不同的意见。有些人交付更重要，有些人认为代码质量在这里更为重要。 ","date":"2022-06-23","objectID":"/2022/06/%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E5%92%8Cdora-metrics-%E5%93%AA%E4%B8%AA%E6%9B%B4%E9%87%8D%E8%A6%81/:1:0","tags":["Dora Metrics","Code Quality","4 Key Metrics","代码质量"],"title":"代码质量和Dora Metrics， 哪个更重要？","uri":"/2022/06/%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E5%92%8Cdora-metrics-%E5%93%AA%E4%B8%AA%E6%9B%B4%E9%87%8D%E8%A6%81/"},{"categories":["Agile"],"content":"分析 所有的问题都是解决“人”的问题。 代码质量， 英语 Code Quality, 衡量代码测试覆盖率，Code Smells， Bug 数量，安全问题（Security HotSpot）等。 代码质量在软件开发过程中都是重中之重。 Dora Metrics, 又称 4 Key Metrics 是一套衡量软件交付效能的指标，有 部署频率（Deployment frequency） 前置时间（Lead time for change） 变更失败率（Change failure rate） 故障回复时间（Time to restore services） 在我们这个场景下，大家关心的是变更失败率 和 代码质量 哪个更重要。 ","date":"2022-06-23","objectID":"/2022/06/%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E5%92%8Cdora-metrics-%E5%93%AA%E4%B8%AA%E6%9B%B4%E9%87%8D%E8%A6%81/:2:0","tags":["Dora Metrics","Code Quality","4 Key Metrics","代码质量"],"title":"代码质量和Dora Metrics， 哪个更重要？","uri":"/2022/06/%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E5%92%8Cdora-metrics-%E5%93%AA%E4%B8%AA%E6%9B%B4%E9%87%8D%E8%A6%81/"},{"categories":["Agile"],"content":"如果更关心变更失败率 如果更关心变更失败率，而放弃了代码质量，那么面临的问题将会是由“人”导致的各种问题; 如大家提交了低质量的代码，因为没有质量门禁来拦截，开发者大多情况下因为自己的懒惰或者逃避责任而选择忽略已存在的各种不符合高质量的代码。长此以往，代码质量问题积累会越来越多，项目将难以维护，CI/CD 的失败变更率必然会随之提高。 ","date":"2022-06-23","objectID":"/2022/06/%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E5%92%8Cdora-metrics-%E5%93%AA%E4%B8%AA%E6%9B%B4%E9%87%8D%E8%A6%81/:2:1","tags":["Dora Metrics","Code Quality","4 Key Metrics","代码质量"],"title":"代码质量和Dora Metrics， 哪个更重要？","uri":"/2022/06/%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E5%92%8Cdora-metrics-%E5%93%AA%E4%B8%AA%E6%9B%B4%E9%87%8D%E8%A6%81/"},{"categories":["Agile"],"content":"如果更关心代码质量 如果更关心代码质量，那么面临的问题会变成，提交了代码之后可能会被 SonarQube 检测出来一些不符合某些门禁指标的issues，然后由于不满足预定的指标而将 Pipeline 阻断，造成变更失败率指标的升高。 ","date":"2022-06-23","objectID":"/2022/06/%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E5%92%8Cdora-metrics-%E5%93%AA%E4%B8%AA%E6%9B%B4%E9%87%8D%E8%A6%81/:2:2","tags":["Dora Metrics","Code Quality","4 Key Metrics","代码质量"],"title":"代码质量和Dora Metrics， 哪个更重要？","uri":"/2022/06/%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E5%92%8Cdora-metrics-%E5%93%AA%E4%B8%AA%E6%9B%B4%E9%87%8D%E8%A6%81/"},{"categories":["Agile"],"content":"哪个更重要呢？ 很多时候大家都会拿出那句名言 “视场景而定”。 但对于软件工程，我们追求的应该是稳定，要对自己的产品要有信心。对开发者而言，信心来自经过测试、符合规范的代码。 上线固然重要，但不能降低质量。就像在 Simple Design 中的\"通过测试\"，通过测试要成为你的信仰，不可动摇。 在完全自动化的自动部署（CD）项目中，如果你的代码质量有问题（会导致生产环境 P1 的事故），经过了质量门禁的检测，发现了问题，但没有及时将流水线打断，那么因为没有及时阻止带来的损失肯定远比你为 Pipeline 失败修复付出的资金和时间要大。 所以，个人认为，在正常的软件交付过程中，代码质量更为重要, 代码质量应该也必须是我们开发者的信仰。 应该通过一定的检测技术来阻止有问题的代码部署到生产环境，就像测试左移(Shift-left Testing)。这样，我们可以确保我们的代码没有任何问题，避免了代码层面的可能引起的生产问题。 勿以恶小而为之，勿以善小而不为 –《三国志·蜀志传》 ","date":"2022-06-23","objectID":"/2022/06/%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E5%92%8Cdora-metrics-%E5%93%AA%E4%B8%AA%E6%9B%B4%E9%87%8D%E8%A6%81/:3:0","tags":["Dora Metrics","Code Quality","4 Key Metrics","代码质量"],"title":"代码质量和Dora Metrics， 哪个更重要？","uri":"/2022/06/%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E5%92%8Cdora-metrics-%E5%93%AA%E4%B8%AA%E6%9B%B4%E9%87%8D%E8%A6%81/"},{"categories":["Agile"],"content":"Refs Dora Metrics: https://devops.com/dora-and-google-cloud-to-collaborate-on-devops-research/ ","date":"2022-06-23","objectID":"/2022/06/%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E5%92%8Cdora-metrics-%E5%93%AA%E4%B8%AA%E6%9B%B4%E9%87%8D%E8%A6%81/:4:0","tags":["Dora Metrics","Code Quality","4 Key Metrics","代码质量"],"title":"代码质量和Dora Metrics， 哪个更重要？","uri":"/2022/06/%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E5%92%8Cdora-metrics-%E5%93%AA%E4%B8%AA%E6%9B%B4%E9%87%8D%E8%A6%81/"},{"categories":["Agile"],"content":"Disclaimer 本文仅代表个人观点，与 Thoughtworks 公司无任何关系。 SHA256 checksum: f2fe1394e4ab9297ed69ff73ac32e9ac1375f01c2102183b509bf9379a5995d6 ","date":"2022-06-23","objectID":"/2022/06/%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E5%92%8Cdora-metrics-%E5%93%AA%E4%B8%AA%E6%9B%B4%E9%87%8D%E8%A6%81/:5:0","tags":["Dora Metrics","Code Quality","4 Key Metrics","代码质量"],"title":"代码质量和Dora Metrics， 哪个更重要？","uri":"/2022/06/%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E5%92%8Cdora-metrics-%E5%93%AA%E4%B8%AA%E6%9B%B4%E9%87%8D%E8%A6%81/"},{"categories":["Agile"],"content":"赞助 SHA256 checksum: 964978ecd2059064abe542e51dc02e204d3ee2e6c320ca68e2b1399ce0c6953c 使用此文件进行校验： gpg --verify PayForGuzhongren.svg.sig ","date":"2022-06-23","objectID":"/2022/06/%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E5%92%8Cdora-metrics-%E5%93%AA%E4%B8%AA%E6%9B%B4%E9%87%8D%E8%A6%81/:6:0","tags":["Dora Metrics","Code Quality","4 Key Metrics","代码质量"],"title":"代码质量和Dora Metrics， 哪个更重要？","uri":"/2022/06/%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E5%92%8Cdora-metrics-%E5%93%AA%E4%B8%AA%E6%9B%B4%E9%87%8D%E8%A6%81/"},{"categories":["Test"],"content":"引言 “调试程序是程序员最大的耻辱” – CTO ","date":"2022-06-11","objectID":"/2022/06/%E7%9C%9F%E7%9A%84%E9%9C%80%E8%A6%81%E5%9C%A8%E6%B5%8B%E8%AF%95%E4%B8%AD%E6%89%93log%E4%B9%88/:1:0","tags":["test","log"],"title":"真的需要在测试中打log么？","uri":"/2022/06/%E7%9C%9F%E7%9A%84%E9%9C%80%E8%A6%81%E5%9C%A8%E6%B5%8B%E8%AF%95%E4%B8%AD%E6%89%93log%E4%B9%88/"},{"categories":["Test"],"content":"写了 log 并且出错的程序 describe('multiple', () =\u003e { it('should be send when invoke the method sendMessage', () =\u003e { Object.defineProperty(window, 'top', { value: window, writable: true, enumerable: true, configurable: true, }) Object.defineProperty(window, 'postMessage', { writable: true, value: jest.fn(), }) console.log(window.top?.postMessage) sendMessage('message') console.log(window.top?.postMessage) expect(window.parent.postMessage).toBeCalledTimes(2) }) }) 运行输出 console.log [Function: mockConstructor] { _isMockFunction: true, getMockImplementation: [Function (anonymous)], mock: [Getter/Setter], mockClear: [Function (anonymous)], mockReset: [Function (anonymous)], mockRestore: [Function (anonymous)], mockReturnValueOnce: [Function (anonymous)], mockResolvedValueOnce: [Function (anonymous)], mockRejectedValueOnce: [Function (anonymous)], mockReturnValue: [Function (anonymous)], mockResolvedValue: [Function (anonymous)], mockRejectedValue: [Function (anonymous)], mockImplementationOnce: [Function (anonymous)], mockImplementation: [Function (anonymous)], mockReturnThis: [Function (anonymous)], mockName: [Function (anonymous)], getMockName: [Function (anonymous)] } at Object.\u003canonymous\u003e (__test__/method_sendMessage_mult_tests.spec.ts:16:13) console.log [Function: mockConstructor] { _isMockFunction: true, getMockImplementation: [Function (anonymous)], mock: [Getter/Setter], mockClear: [Function (anonymous)], mockReset: [Function (anonymous)], mockRestore: [Function (anonymous)], mockReturnValueOnce: [Function (anonymous)], mockResolvedValueOnce: [Function (anonymous)], mockRejectedValueOnce: [Function (anonymous)], mockReturnValue: [Function (anonymous)], mockResolvedValue: [Function (anonymous)], mockRejectedValue: [Function (anonymous)], mockImplementationOnce: [Function (anonymous)], mockImplementation: [Function (anonymous)], mockReturnThis: [Function (anonymous)], mockName: [Function (anonymous)], getMockName: [Function (anonymous)] } at Object.\u003canonymous\u003e (__test__/method_sendMessage_mult_tests.spec.ts:18:13) FAIL __test__/method_sendMessage_mult_tests.spec.ts multiple ✕ should be send when invoke the method sendMessage (12 ms) ● multiple › should be send when invoke the method sendMessage expect(jest.fn()).toBeCalledTimes(expected) Expected number of calls: 2 Received number of calls: 1 17 | sendMessage('message') 18 | console.log(window.top?.postMessage) \u003e 19 | expect(window.parent.postMessage).toBeCalledTimes(2) | ^ 20 | }) 21 | }) at Object.\u003canonymous\u003e (__test__/method_sendMessage_mult_tests.spec.ts:19:39) at processTicksAndRejections (node:internal/process/task_queues:96:5) Test Suites: 1 failed, 1 total Tests: 1 failed, 1 total Snapshots: 0 total Time: 1.077 s Ran all test suites matching /\\/Users\\/zhongren\\.gu\\/01\\.Project\\/test-window-object\\/__test__\\/method_sendMessage_mult_tests\\.spec\\.ts/i with tests matching \"multiple should be send when invoke the method sendMessage\". ","date":"2022-06-11","objectID":"/2022/06/%E7%9C%9F%E7%9A%84%E9%9C%80%E8%A6%81%E5%9C%A8%E6%B5%8B%E8%AF%95%E4%B8%AD%E6%89%93log%E4%B9%88/:2:0","tags":["test","log"],"title":"真的需要在测试中打log么？","uri":"/2022/06/%E7%9C%9F%E7%9A%84%E9%9C%80%E8%A6%81%E5%9C%A8%E6%B5%8B%E8%AF%95%E4%B8%AD%E6%89%93log%E4%B9%88/"},{"categories":["Test"],"content":"在测试中写 log 有什么用？ 本文所说的测试中写的 Log 是提交到代码仓库中的日志。 看了上面的测试和 UT 运行后的结果，你有什么看法？ 在我看来，有以下几点： ","date":"2022-06-11","objectID":"/2022/06/%E7%9C%9F%E7%9A%84%E9%9C%80%E8%A6%81%E5%9C%A8%E6%B5%8B%E8%AF%95%E4%B8%AD%E6%89%93log%E4%B9%88/:3:0","tags":["test","log"],"title":"真的需要在测试中打log么？","uri":"/2022/06/%E7%9C%9F%E7%9A%84%E9%9C%80%E8%A6%81%E5%9C%A8%E6%B5%8B%E8%AF%95%E4%B8%AD%E6%89%93log%E4%B9%88/"},{"categories":["Test"],"content":"影响总体的测试输出 如果测试中存在很多的 log，并且有部分测试会失败，当你找失败的测试的时候就会变得非常困难，会被log 迷惑。测试结果列表不是那么整齐，给人以测试混乱，不够整洁的感觉，影响开发体验。 ","date":"2022-06-11","objectID":"/2022/06/%E7%9C%9F%E7%9A%84%E9%9C%80%E8%A6%81%E5%9C%A8%E6%B5%8B%E8%AF%95%E4%B8%AD%E6%89%93log%E4%B9%88/:3:1","tags":["test","log"],"title":"真的需要在测试中打log么？","uri":"/2022/06/%E7%9C%9F%E7%9A%84%E9%9C%80%E8%A6%81%E5%9C%A8%E6%B5%8B%E8%AF%95%E4%B8%AD%E6%89%93log%E4%B9%88/"},{"categories":["Test"],"content":"日志对测试运行的成败没有任何好处 测试在运行失败后，会自动打印出真实值（Received）和 期望值（Expected), 对于优秀的程序员，大家都用 TDD 开发，按照 TDD 的套路，程序的期望值是已知的；如果测试失败，你应该修改你的产品代码，让你的产品代码的输出符合你测试的期望值; 而不是在你的测试代码中调试，打 log。 如果在测试中打印了 Log，程序员最多在测试日志中看看某个变量的值，对生产代码没有任何影响; 同时你还得花时间去找你想要的日志，纯属浪费时间。 如果真的需要看测试的某个变量或者看生产代码中某行代码的运行时值，通过调试你的测试代码，在你的生产代码中打断点即可，完全没有必要将测试中的日志永久的留在代码库中。 ","date":"2022-06-11","objectID":"/2022/06/%E7%9C%9F%E7%9A%84%E9%9C%80%E8%A6%81%E5%9C%A8%E6%B5%8B%E8%AF%95%E4%B8%AD%E6%89%93log%E4%B9%88/:3:2","tags":["test","log"],"title":"真的需要在测试中打log么？","uri":"/2022/06/%E7%9C%9F%E7%9A%84%E9%9C%80%E8%A6%81%E5%9C%A8%E6%B5%8B%E8%AF%95%E4%B8%AD%E6%89%93log%E4%B9%88/"},{"categories":["Test"],"content":"生产代码中的日志被测试打印出来，可以吗？ 不行。没有意义。 运行测试，我们只想知道所有测试是否成功，至于中间打印出生产代码中的日志也没有意义。 如果测试失败，只需要 Fix 对应的测试即可, 无论什么方法。 ","date":"2022-06-11","objectID":"/2022/06/%E7%9C%9F%E7%9A%84%E9%9C%80%E8%A6%81%E5%9C%A8%E6%B5%8B%E8%AF%95%E4%B8%AD%E6%89%93log%E4%B9%88/:4:0","tags":["test","log"],"title":"真的需要在测试中打log么？","uri":"/2022/06/%E7%9C%9F%E7%9A%84%E9%9C%80%E8%A6%81%E5%9C%A8%E6%B5%8B%E8%AF%95%E4%B8%AD%E6%89%93log%E4%B9%88/"},{"categories":["Test"],"content":"解决方案 如果真的需要在测试时调试代码，可以加 debug 级别的调试代码，这样就可以通过日志来调试了，但还是需要通过其他的方式，比如 eslint 来限制将 debug 日志提交到 Repo 中。 怎么让测试的输出中不输出 log 信息呢？ 对于前端，我们可以在所有测试运行前 Spy console.*的所有的方法， jest.spyOn(console, 'log').mockReturnValue(); jest.spyOn(console, 'info').mockReturnValue(); jest.spyOn(console, 'warn').mockReturnValue(); jest.spyOn(console, 'error').mockReturnValue(); 这段代码需要写在 tests/jest-setup.[t|j]s 中。 或者使用第三方成熟的 npm 包， 像 jest-mock-console, 这个包功能更强大一点。 ","date":"2022-06-11","objectID":"/2022/06/%E7%9C%9F%E7%9A%84%E9%9C%80%E8%A6%81%E5%9C%A8%E6%B5%8B%E8%AF%95%E4%B8%AD%E6%89%93log%E4%B9%88/:5:0","tags":["test","log"],"title":"真的需要在测试中打log么？","uri":"/2022/06/%E7%9C%9F%E7%9A%84%E9%9C%80%E8%A6%81%E5%9C%A8%E6%B5%8B%E8%AF%95%E4%B8%AD%E6%89%93log%E4%B9%88/"},{"categories":["Test"],"content":"Refs 博客: https://guzhongren.github.io/ Mock logger in jest: http://github.yanhaixiang.com/jest-tutorial/basic/mock-timer/#mock-logger ","date":"2022-06-11","objectID":"/2022/06/%E7%9C%9F%E7%9A%84%E9%9C%80%E8%A6%81%E5%9C%A8%E6%B5%8B%E8%AF%95%E4%B8%AD%E6%89%93log%E4%B9%88/:6:0","tags":["test","log"],"title":"真的需要在测试中打log么？","uri":"/2022/06/%E7%9C%9F%E7%9A%84%E9%9C%80%E8%A6%81%E5%9C%A8%E6%B5%8B%E8%AF%95%E4%B8%AD%E6%89%93log%E4%B9%88/"},{"categories":["Test"],"content":"Disclaimer 本文仅代表个人观点，与 Thoughtworks 公司无任何关系。 SHA256 checksum: f2fe1394e4ab9297ed69ff73ac32e9ac1375f01c2102183b509bf9379a5995d6 ","date":"2022-06-11","objectID":"/2022/06/%E7%9C%9F%E7%9A%84%E9%9C%80%E8%A6%81%E5%9C%A8%E6%B5%8B%E8%AF%95%E4%B8%AD%E6%89%93log%E4%B9%88/:7:0","tags":["test","log"],"title":"真的需要在测试中打log么？","uri":"/2022/06/%E7%9C%9F%E7%9A%84%E9%9C%80%E8%A6%81%E5%9C%A8%E6%B5%8B%E8%AF%95%E4%B8%AD%E6%89%93log%E4%B9%88/"},{"categories":["Test"],"content":"赞助 SHA256 checksum: 964978ecd2059064abe542e51dc02e204d3ee2e6c320ca68e2b1399ce0c6953c 使用此文件进行校验： gpg --verify PayForGuzhongren.svg.sig ","date":"2022-06-11","objectID":"/2022/06/%E7%9C%9F%E7%9A%84%E9%9C%80%E8%A6%81%E5%9C%A8%E6%B5%8B%E8%AF%95%E4%B8%AD%E6%89%93log%E4%B9%88/:8:0","tags":["test","log"],"title":"真的需要在测试中打log么？","uri":"/2022/06/%E7%9C%9F%E7%9A%84%E9%9C%80%E8%A6%81%E5%9C%A8%E6%B5%8B%E8%AF%95%E4%B8%AD%E6%89%93log%E4%B9%88/"},{"categories":["Tool"],"content":" Performance has directly impacted the company’s bottom line. – Pinterest ","date":"2022-04-16","objectID":"/2022/04/continuously-optimize-your-website-with-lighthouse-ci/:0:0","tags":["lhci","Lighthouse","CI","CD","Performance","Webpref"],"title":"Continuously Optimize Your Website With Lighthouse CI","uri":"/2022/04/continuously-optimize-your-website-with-lighthouse-ci/"},{"categories":["Tool"],"content":"Intro Since the development of the Internet, web page performance has always been an important issue. All major Internet companies are sparing no effort to optimize their web pages, in order to allow users to see the content that users want to see faster. During the development of the Internet in recent decades, various indicators and terms for measuring web performance have stabilized, and the measurement methods of various products have tended to be consistent. The BBC found that every 1 second increase in the load time of its website was associated with losing 10% more users. DoubleClick by Google found that 53% of mobile site visits are abandoned if a page takes longer than 3 seconds to load. DoubleClick by Google research shows that sites with loading times under 5 seconds experience 70% longer sessions, 35% lower bounce rates, and 25% higher ad viewability rates than sites that load about four times as long (19 seconds). Mobify saw a 1.11% increase in session-based conversions for every 100 milliseconds decrease in homepage load time and an average annual revenue increase of nearly $380,000. AutoAnything saw a 12-13% increase in sales after halving its page load time. It can be seen how important the performance of web pages is in today’s Internet of Everything era. ","date":"2022-04-16","objectID":"/2022/04/continuously-optimize-your-website-with-lighthouse-ci/:1:0","tags":["lhci","Lighthouse","CI","CD","Performance","Webpref"],"title":"Continuously Optimize Your Website With Lighthouse CI","uri":"/2022/04/continuously-optimize-your-website-with-lighthouse-ci/"},{"categories":["Tool"],"content":"Problems with measuring web performance ","date":"2022-04-16","objectID":"/2022/04/continuously-optimize-your-website-with-lighthouse-ci/:2:0","tags":["lhci","Lighthouse","CI","CD","Performance","Webpref"],"title":"Continuously Optimize Your Website With Lighthouse CI","uri":"/2022/04/continuously-optimize-your-website-with-lighthouse-ci/"},{"categories":["Tool"],"content":"Not runnable natively to catch performance issues as early as possible Many tools cannot be run locally; if the web performance testing tools can be run locally, developers can find problems earlier and solve them locally as soon as possible, avoiding running on CI for a while before finding problems , which can save a lot of time and improve production efficiency in the agile development process of CI/CD. Shift-left of the web performance test is bound to bring more benefits to the performance of web products, and even more profits for the company. ","date":"2022-04-16","objectID":"/2022/04/continuously-optimize-your-website-with-lighthouse-ci/:2:1","tags":["lhci","Lighthouse","CI","CD","Performance","Webpref"],"title":"Continuously Optimize Your Website With Lighthouse CI","uri":"/2022/04/continuously-optimize-your-website-with-lighthouse-ci/"},{"categories":["Tool"],"content":"Inability to continuously measure performance metrics At present, most of the web performance measurement products on the market are Sass products. Using its products, we can only get a visual result page after running the performance test, but it cannot continuously record the improvement records of web page performance, and cannot be well quantified the life cycle of a web product performance. Of course there are also web performance testing tools that implement history, such as treo. ","date":"2022-04-16","objectID":"/2022/04/continuously-optimize-your-website-with-lighthouse-ci/:2:2","tags":["lhci","Lighthouse","CI","CD","Performance","Webpref"],"title":"Continuously Optimize Your Website With Lighthouse CI","uri":"/2022/04/continuously-optimize-your-website-with-lighthouse-ci/"},{"categories":["Tool"],"content":"Cost There are many open source free web performance testing tools, but they may not be so easy to use; if you need more features, such as continuous recording of web page performance, generally only commercial products will support it, and the fees are not low. ","date":"2022-04-16","objectID":"/2022/04/continuously-optimize-your-website-with-lighthouse-ci/:2:3","tags":["lhci","Lighthouse","CI","CD","Performance","Webpref"],"title":"Continuously Optimize Your Website With Lighthouse CI","uri":"/2022/04/continuously-optimize-your-website-with-lighthouse-ci/"},{"categories":["Tool"],"content":"Difficulty with CI integration As mentioned earlier, many tools either cannot be run locally or are Sass products, which cannot be well integrated with Pipeline, resulting in long feedback cycles of web performance results and make the engineering efficiency too low. ","date":"2022-04-16","objectID":"/2022/04/continuously-optimize-your-website-with-lighthouse-ci/:2:4","tags":["lhci","Lighthouse","CI","CD","Performance","Webpref"],"title":"Continuously Optimize Your Website With Lighthouse CI","uri":"/2022/04/continuously-optimize-your-website-with-lighthouse-ci/"},{"categories":["Tool"],"content":"Lighthouse Lighthouse is an open-source, automated tool for improving the quality of web pages. You can run it against any web page, public or requiring authentication. It has audits for performance, accessibility, progressive web apps, SEO and more. You can run Lighthouse in Chrome DevTools, from the command line, or as a Node module. You give Lighthouse a URL to audit, it runs a series of audits against the page, and then it generates a report on how well the page did. From there, use the failing audits as indicators on how to improve the page. Each audit has a reference doc explaining why the audit is important, as well as how to fix it. You can also use Lighthouse CI to prevent regressions on your sites. It’s very easy to use, take a look at the results of my audit of my open source project Powerboard. ","date":"2022-04-16","objectID":"/2022/04/continuously-optimize-your-website-with-lighthouse-ci/:3:0","tags":["lhci","Lighthouse","CI","CD","Performance","Webpref"],"title":"Continuously Optimize Your Website With Lighthouse CI","uri":"/2022/04/continuously-optimize-your-website-with-lighthouse-ci/"},{"categories":["Tool"],"content":"Ways of Lighthouse CI and Lighthouse Server ","date":"2022-04-16","objectID":"/2022/04/continuously-optimize-your-website-with-lighthouse-ci/:4:0","tags":["lhci","Lighthouse","CI","CD","Performance","Webpref"],"title":"Continuously Optimize Your Website With Lighthouse CI","uri":"/2022/04/continuously-optimize-your-website-with-lighthouse-ci/"},{"categories":["Tool"],"content":"Lighthouse CI （LHCI） Automate running Lighthouse for every commit, viewing the changes, and preventing regressions – GoogleChrome/lighthouse-ci Lighthouse CI is a suite of tools that make continuously running, saving, retrieving, and asserting against Lighthouse results as easy as possible. How to use LHCI provides the npm installation package, which can be well integrated on the Pipeline, just run the autorun command in the corresponding directory, the command is as follows npm install -g @lhci/cli lhci autorun After the operation is completed, LHCI will store the results in the .lighthouseci directory, and you can open the corresponding report with a browser. ","date":"2022-04-16","objectID":"/2022/04/continuously-optimize-your-website-with-lighthouse-ci/:4:1","tags":["lhci","Lighthouse","CI","CD","Performance","Webpref"],"title":"Continuously Optimize Your Website With Lighthouse CI","uri":"/2022/04/continuously-optimize-your-website-with-lighthouse-ci/"},{"categories":["Tool"],"content":"Lighthouse Server The LHCI server saves historical Lighthouse data, displays trends in a dashboard, and offers an in-depth build comparison UI to uncover differences between builds. Installation and use of LHCI Server There are many ways to install LHCI Server, please refer to here, the recommended way is to use Docker. Note that the first run needs to create a Lighthouse App, you need to run the lhci wizard in the container and fill in the corresponding information, finally record the generated Build token and Admin token. ","date":"2022-04-16","objectID":"/2022/04/continuously-optimize-your-website-with-lighthouse-ci/:4:2","tags":["lhci","Lighthouse","CI","CD","Performance","Webpref"],"title":"Continuously Optimize Your Website With Lighthouse CI","uri":"/2022/04/continuously-optimize-your-website-with-lighthouse-ci/"},{"categories":["Tool"],"content":"Integration with Lighthouse CI and Lighthouse Server We have already talked about how to install lhci and lhci server, the next step is to use the two together. Here we take GitHub Actions as an example to make a demo. Build GitHub workflow. For specific practices, please refer to the implementation details of Powerboard .github/workflows/Lighthouse.yml name:Lighthouse CIon:push:branches:- mainjobs:lhci:name:Lighthouseruns-on:ubuntu-lateststeps:- uses:actions/checkout@v2with:ref:${{ github.event.pull_request.head.sha }}- name:Use Node.js 10.xuses:actions/setup-node@v1with:node-version:16.14.2- name:npm install, buildrun:|npm install npm run build- name:Upload Lighthouse Reportrun:|npm install -g @lhci/cli lhci autorun --config=.github/config/lighthouserc-no-condition.json lhci upload --serverBaseUrl=${{ secrets.LHCI_SERVER_URL }} --token=${{ secrets.LHCI_BUILD_TOKEN }}env:LHCI_GITHUB_APP_TOKEN:${{ secrets.LHCI_GITHUB_APP_TOKEN }}- name:Check Lighthouse Reportrun:|lhci autorun --config=.github/config/lighthouserc.json .github/config/lighthouserc-no-condition.json { \"ci\": { \"collect\": { \"staticDistDir\": \"./dist\", \"settings\": { \"formFactor\": \"desktop\", \"screenEmulation\": { \"mobile\": false, \"width\": 1920, \"height\": 1080, \"deviceScaleFactor\": 1, \"disabled\": false } } }, \"assert\": { \"assertions\": { \"categories:performance\": \"off\", \"categories:accessibility\": \"off\", \"categories:best-practices\": \"off\", \"categories:seo\": \"off\", \"categories:pwa\": \"off\" } } } } .github/config/lighthouserc.json { \"ci\": { \"collect\": { \"staticDistDir\": \"./dist\", \"settings\": { \"formFactor\": \"desktop\", \"screenEmulation\": { \"mobile\": false, \"width\": 1920, \"height\": 1080, \"deviceScaleFactor\": 1, \"disabled\": false } } }, \"assert\": { \"assertions\": { \"categories:performance\": [\"error\", { \"minScore\": 0.8 }], \"categories:accessibility\": [\"error\", { \"minScore\": 0.95 }], \"categories:best-practices\": [\"error\", { \"minScore\": 1 }], \"categories:seo\": [\"error\", { \"minScore\": 0.9 }], \"categories:pwa\": [\"warn\", { \"minScore\": 0.99 }] } } } } Need to store the Build token generated by lhci Server and the address of lhci Server in the Secrets of the GitHub project Here the lhci command is executed twice. Because lhci autorun runs the default assertion, the first time you use the command without assertion, the purpose is to upload the current web page performance to the server side; the second time you configure various indicators Threshold, if it does not meet the requirements, Pipeline will block, to achieve Shift-left of the web performance test. ","date":"2022-04-16","objectID":"/2022/04/continuously-optimize-your-website-with-lighthouse-ci/:4:3","tags":["lhci","Lighthouse","CI","CD","Performance","Webpref"],"title":"Continuously Optimize Your Website With Lighthouse CI","uri":"/2022/04/continuously-optimize-your-website-with-lighthouse-ci/"},{"categories":["Tool"],"content":"Summary For: Developers, technical leads or marketers They want to: continuously quantify and demonstrate the performance of web pages This: Lighthouse CI is one: a set of tools written by Google to make it as easy as possible to continuously run, save, retrieve, and assert on Lighthouse results. It can evaluate web applications and pages, as well as gather information such as performance metrics and insights from development best practices It can: test your web page, get web page’s Performance , Accessibility , Best Practices , SEO and PWA scores on different devices, these scores can be used to analyze the product performance, helping to improve user conversion rates, etc. Unlike: treo or some other web performance testing tool Its advantages are: Open-Source, Free, Self-hosted data and Server, Easy to integrate. ","date":"2022-04-16","objectID":"/2022/04/continuously-optimize-your-website-with-lighthouse-ci/:5:0","tags":["lhci","Lighthouse","CI","CD","Performance","Webpref"],"title":"Continuously Optimize Your Website With Lighthouse CI","uri":"/2022/04/continuously-optimize-your-website-with-lighthouse-ci/"},{"categories":["Tool"],"content":"Refs Get Down to Business: Why the web Matters (Chrome Dev Summit 2018): https://web.dev/i18n/zh/why-speed-matters/ why Speed Matters？: https://web.dev/i18n/zh/why-speed-matters Lighthouse: https://developers.google.cn/web/tools/lighthouse 博客:https://guzhongren.github.io/ ","date":"2022-04-16","objectID":"/2022/04/continuously-optimize-your-website-with-lighthouse-ci/:6:0","tags":["lhci","Lighthouse","CI","CD","Performance","Webpref"],"title":"Continuously Optimize Your Website With Lighthouse CI","uri":"/2022/04/continuously-optimize-your-website-with-lighthouse-ci/"},{"categories":["Tool"],"content":"Disclaimer 本文仅代表个人观点，与 Thoughtworks 公司无任何关系。 SHA256 checksum: f2fe1394e4ab9297ed69ff73ac32e9ac1375f01c2102183b509bf9379a5995d6 ","date":"2022-04-16","objectID":"/2022/04/continuously-optimize-your-website-with-lighthouse-ci/:7:0","tags":["lhci","Lighthouse","CI","CD","Performance","Webpref"],"title":"Continuously Optimize Your Website With Lighthouse CI","uri":"/2022/04/continuously-optimize-your-website-with-lighthouse-ci/"},{"categories":["Tool"],"content":"赞助 SHA256 checksum: 964978ecd2059064abe542e51dc02e204d3ee2e6c320ca68e2b1399ce0c6953c 使用此文件进行校验： gpg --verify PayForGuzhongren.svg.sig ","date":"2022-04-16","objectID":"/2022/04/continuously-optimize-your-website-with-lighthouse-ci/:8:0","tags":["lhci","Lighthouse","CI","CD","Performance","Webpref"],"title":"Continuously Optimize Your Website With Lighthouse CI","uri":"/2022/04/continuously-optimize-your-website-with-lighthouse-ci/"},{"categories":["Tool"],"content":" 性能是留住用户的关键， 性能直接影响公司的命运。 – Pinterest ","date":"2022-03-27","objectID":"/2022/03/%E4%BD%BF%E7%94%A8-lighthouse-%E6%8C%81%E7%BB%AD%E4%BC%98%E5%8C%96%E4%BD%A0%E7%9A%84-web-%E6%80%A7%E8%83%BD/:0:0","tags":["lhci","Lighthouse","CI","CD","performance","webpref"],"title":"使用 Lighthouse 持续优化你的 Web 性能","uri":"/2022/03/%E4%BD%BF%E7%94%A8-lighthouse-%E6%8C%81%E7%BB%AD%E4%BC%98%E5%8C%96%E4%BD%A0%E7%9A%84-web-%E6%80%A7%E8%83%BD/"},{"categories":["Tool"],"content":"介绍 互联网发展至今，网页性能始终是一个重要的问题, 各大互联网公司都在不遗余力的优化自己的 Web 页面，为的就是更快的让用户更快的看到用户想看到的内容。 互联网在近几十年的发展过程中，度量 Web 性能各个指标、术语已经稳定了，各个产品的度量方式都趋于一致。 BBC 发现其网站的加载时间每增加 1 秒，便会多失去 10% 的用户。 DoubleClick by Google 发现，如果页面加载时间超过 3 秒，53% 的移动网站访问活动将遭到抛弃。 DoubleClick by Google 研究表明，与加载时间约为四倍（19 秒）的网站相比，加载时间在 5 秒以内的网站会话加长 70%、跳出率下降 35%、广告可见率上升 25%。 Mobify 的首页加载时间每减少 100 毫秒，基于会话的转化率增加 1.11%，年均收入增长近 380,000 美元。 AutoAnything 的页面加载时间减少一半后，其销售额提升 12-13%。 可见，Web 页面的性能在现今万物互联的时代有多重要。 ","date":"2022-03-27","objectID":"/2022/03/%E4%BD%BF%E7%94%A8-lighthouse-%E6%8C%81%E7%BB%AD%E4%BC%98%E5%8C%96%E4%BD%A0%E7%9A%84-web-%E6%80%A7%E8%83%BD/:1:0","tags":["lhci","Lighthouse","CI","CD","performance","webpref"],"title":"使用 Lighthouse 持续优化你的 Web 性能","uri":"/2022/03/%E4%BD%BF%E7%94%A8-lighthouse-%E6%8C%81%E7%BB%AD%E4%BC%98%E5%8C%96%E4%BD%A0%E7%9A%84-web-%E6%80%A7%E8%83%BD/"},{"categories":["Tool"],"content":"Web 性能在度量方面存在的问题 ","date":"2022-03-27","objectID":"/2022/03/%E4%BD%BF%E7%94%A8-lighthouse-%E6%8C%81%E7%BB%AD%E4%BC%98%E5%8C%96%E4%BD%A0%E7%9A%84-web-%E6%80%A7%E8%83%BD/:2:0","tags":["lhci","Lighthouse","CI","CD","performance","webpref"],"title":"使用 Lighthouse 持续优化你的 Web 性能","uri":"/2022/03/%E4%BD%BF%E7%94%A8-lighthouse-%E6%8C%81%E7%BB%AD%E4%BC%98%E5%8C%96%E4%BD%A0%E7%9A%84-web-%E6%80%A7%E8%83%BD/"},{"categories":["Tool"],"content":"不可本地运行，以尽可能早地发现性能问题 很多工具都不可以在本地运行； 如果 Web 性能测试工具可以在本地运行，开发人员可以更早地发现问题，并尽可能早的在本地解决，避免了在 CI 上跑了一会了才发现问题，在 CI/CD 的敏捷开发过程中这样可以节省很多时间，提高生产效率。Web 性能测试左移 必定为 Web 产品性能带来更多好处，甚至为公司带来更多盈利。 ","date":"2022-03-27","objectID":"/2022/03/%E4%BD%BF%E7%94%A8-lighthouse-%E6%8C%81%E7%BB%AD%E4%BC%98%E5%8C%96%E4%BD%A0%E7%9A%84-web-%E6%80%A7%E8%83%BD/:2:1","tags":["lhci","Lighthouse","CI","CD","performance","webpref"],"title":"使用 Lighthouse 持续优化你的 Web 性能","uri":"/2022/03/%E4%BD%BF%E7%94%A8-lighthouse-%E6%8C%81%E7%BB%AD%E4%BC%98%E5%8C%96%E4%BD%A0%E7%9A%84-web-%E6%80%A7%E8%83%BD/"},{"categories":["Tool"],"content":"不能持续度量性能指标 目前市场上 Web 性能度量的产品大多都是 Sass 产品，使用其产品我们只能得到一个运行完性能测试的可视化结果页面，但是不能持续的记录 Web 网页性能的改进记录，不能很好的量化一个 Web 产品性能的生命周期。当然也有实现历史记录的 Web 性能测试工具，例如 treo。 ","date":"2022-03-27","objectID":"/2022/03/%E4%BD%BF%E7%94%A8-lighthouse-%E6%8C%81%E7%BB%AD%E4%BC%98%E5%8C%96%E4%BD%A0%E7%9A%84-web-%E6%80%A7%E8%83%BD/:2:2","tags":["lhci","Lighthouse","CI","CD","performance","webpref"],"title":"使用 Lighthouse 持续优化你的 Web 性能","uri":"/2022/03/%E4%BD%BF%E7%94%A8-lighthouse-%E6%8C%81%E7%BB%AD%E4%BC%98%E5%8C%96%E4%BD%A0%E7%9A%84-web-%E6%80%A7%E8%83%BD/"},{"categories":["Tool"],"content":"费用 开源免费的 Web 性能测试工具有不少，但是用起来可能没有那么爽；如果需要更多的特性，如持续记录 Web 网页性能，一般只有商业产品会支持，而且收费还不低。 ","date":"2022-03-27","objectID":"/2022/03/%E4%BD%BF%E7%94%A8-lighthouse-%E6%8C%81%E7%BB%AD%E4%BC%98%E5%8C%96%E4%BD%A0%E7%9A%84-web-%E6%80%A7%E8%83%BD/:2:3","tags":["lhci","Lighthouse","CI","CD","performance","webpref"],"title":"使用 Lighthouse 持续优化你的 Web 性能","uri":"/2022/03/%E4%BD%BF%E7%94%A8-lighthouse-%E6%8C%81%E7%BB%AD%E4%BC%98%E5%8C%96%E4%BD%A0%E7%9A%84-web-%E6%80%A7%E8%83%BD/"},{"categories":["Tool"],"content":"CI 集成困难 如前面所说，很多工具要么是本地不能运行，要么就是 Sass 产品，不能很好的与 Pipeline 集成， 导致 Web 性能结果反馈周期长、工程效率低等问题。 ","date":"2022-03-27","objectID":"/2022/03/%E4%BD%BF%E7%94%A8-lighthouse-%E6%8C%81%E7%BB%AD%E4%BC%98%E5%8C%96%E4%BD%A0%E7%9A%84-web-%E6%80%A7%E8%83%BD/:2:4","tags":["lhci","Lighthouse","CI","CD","performance","webpref"],"title":"使用 Lighthouse 持续优化你的 Web 性能","uri":"/2022/03/%E4%BD%BF%E7%94%A8-lighthouse-%E6%8C%81%E7%BB%AD%E4%BC%98%E5%8C%96%E4%BD%A0%E7%9A%84-web-%E6%80%A7%E8%83%BD/"},{"categories":["Tool"],"content":"Lighthouse Lighthouse 是一个开源的、自动化的工具，用以提高网页质量。你可以在任何网页上运行它，公开的或需要认证的。它对性能、可访问性、渐进式web应用程序、SEO 等进行审计。 你可以在 Chrome DevTools、 命令行甚至是 Node 模块中运行 Lighthouse。 向 Lighthouse 提供一个要审计的 URL，它会对页面运行一系列审计，随即会生成一个关于页面运行情况的报告。对于失败的审计项，可以使用对应项的改进方案。每个审计项都有一个参考文档，解释为什么审核很重要，以及如何修复它。 使用方法非常简单，可以看一下我对我的开源项目 Powerboard 审计的结果。 ","date":"2022-03-27","objectID":"/2022/03/%E4%BD%BF%E7%94%A8-lighthouse-%E6%8C%81%E7%BB%AD%E4%BC%98%E5%8C%96%E4%BD%A0%E7%9A%84-web-%E6%80%A7%E8%83%BD/:3:0","tags":["lhci","Lighthouse","CI","CD","performance","webpref"],"title":"使用 Lighthouse 持续优化你的 Web 性能","uri":"/2022/03/%E4%BD%BF%E7%94%A8-lighthouse-%E6%8C%81%E7%BB%AD%E4%BC%98%E5%8C%96%E4%BD%A0%E7%9A%84-web-%E6%80%A7%E8%83%BD/"},{"categories":["Tool"],"content":"Lighthouse CI 及 Lighthouse Server 的使用 ","date":"2022-03-27","objectID":"/2022/03/%E4%BD%BF%E7%94%A8-lighthouse-%E6%8C%81%E7%BB%AD%E4%BC%98%E5%8C%96%E4%BD%A0%E7%9A%84-web-%E6%80%A7%E8%83%BD/:4:0","tags":["lhci","Lighthouse","CI","CD","performance","webpref"],"title":"使用 Lighthouse 持续优化你的 Web 性能","uri":"/2022/03/%E4%BD%BF%E7%94%A8-lighthouse-%E6%8C%81%E7%BB%AD%E4%BC%98%E5%8C%96%E4%BD%A0%E7%9A%84-web-%E6%80%A7%E8%83%BD/"},{"categories":["Tool"],"content":"Lighthouse CI （LHCI） Automate running Lighthouse for every commit, viewing the changes, and preventing regressions 为每个提交自动化运行Lighthouse，查看更改，并防止回归 – GoogleChrome/lighthouse-ci Lighthouse CI 是 Google Chrome 团队开发的一套可以让持续运行、保存、检索和对 Lighthouse 结果进行断言变得尽可能简单的工具,可以很方便的集成在 CI 上。 使用 LHCI 提供 npm 安装包，可以很好的在 Pipeline 上集成，只需要在对应目录下运行 autorun 命令即可，命令如下 npm install -g @lhci/cli lhci autorun 运行完成后，LHCI 会将结果存放在 .lighthouseci 目录下，用浏览器打开对应的报告即可。 ","date":"2022-03-27","objectID":"/2022/03/%E4%BD%BF%E7%94%A8-lighthouse-%E6%8C%81%E7%BB%AD%E4%BC%98%E5%8C%96%E4%BD%A0%E7%9A%84-web-%E6%80%A7%E8%83%BD/:4:1","tags":["lhci","Lighthouse","CI","CD","performance","webpref"],"title":"使用 Lighthouse 持续优化你的 Web 性能","uri":"/2022/03/%E4%BD%BF%E7%94%A8-lighthouse-%E6%8C%81%E7%BB%AD%E4%BC%98%E5%8C%96%E4%BD%A0%E7%9A%84-web-%E6%80%A7%E8%83%BD/"},{"categories":["Tool"],"content":"Lighthouse Server The LHCI server saves historical Lighthouse data, displays trends in a dashboard, and offers an in-depth build comparison UI to uncover differences between builds. LHCI Server 保存 Lighthouse 历史数据，并可在仪表板中显示趋势，并提供深入的构建比较 UI，以揭示构建之间的差异。 LHCI Server 的安装和使用 LHCI Server 的安装有多种方式，具体可参考这里，推荐使用 Docker 的方式运行。需要注意的是，第一次运行需要创建 Lighthouse App, 需要在容器中运行 lhci wizard 并填入相应的信息，最后记录下生成的 Build token 和 Admin token。 ","date":"2022-03-27","objectID":"/2022/03/%E4%BD%BF%E7%94%A8-lighthouse-%E6%8C%81%E7%BB%AD%E4%BC%98%E5%8C%96%E4%BD%A0%E7%9A%84-web-%E6%80%A7%E8%83%BD/:4:2","tags":["lhci","Lighthouse","CI","CD","performance","webpref"],"title":"使用 Lighthouse 持续优化你的 Web 性能","uri":"/2022/03/%E4%BD%BF%E7%94%A8-lighthouse-%E6%8C%81%E7%BB%AD%E4%BC%98%E5%8C%96%E4%BD%A0%E7%9A%84-web-%E6%80%A7%E8%83%BD/"},{"categories":["Tool"],"content":"Lighthouse CI 和 Lighthouse Server 集成 前面已经讲了 lhci 和 lhci server 如何安装了，接下来就是需要将两者结合起来一起使用了。这里我们以 GitHub Actions 为例来搞一个 Demo。 构建 GitHub workflow， 具体实践可参考 Powerboard 的实现细节 .github/workflows/Lighthouse.yml name:Lighthouse CIon:push:branches:- mainjobs:lhci:name:Lighthouseruns-on:ubuntu-lateststeps:- uses:actions/checkout@v2with:ref:${{ github.event.pull_request.head.sha }}- name:Use Node.js 10.xuses:actions/setup-node@v1with:node-version:16.14.2- name:npm install, buildrun:|npm install npm run build- name:Upload Lighthouse Reportrun:|npm install -g @lhci/cli lhci autorun --config=.github/config/lighthouserc-no-condition.json lhci upload --serverBaseUrl=${{ secrets.LHCI_SERVER_URL }} --token=${{ secrets.LHCI_BUILD_TOKEN }}env:LHCI_GITHUB_APP_TOKEN:${{ secrets.LHCI_GITHUB_APP_TOKEN }}- name:Check Lighthouse Reportrun:|lhci autorun --config=.github/config/lighthouserc.json .github/config/lighthouserc-no-condition.json { \"ci\": { \"collect\": { \"staticDistDir\": \"./dist\", \"settings\": { \"formFactor\": \"desktop\", \"screenEmulation\": { \"mobile\": false, \"width\": 1920, \"height\": 1080, \"deviceScaleFactor\": 1, \"disabled\": false } } }, \"assert\": { \"assertions\": { \"categories:performance\": \"off\", \"categories:accessibility\": \"off\", \"categories:best-practices\": \"off\", \"categories:seo\": \"off\", \"categories:pwa\": \"off\" } } } } .github/config/lighthouserc.json { \"ci\": { \"collect\": { \"staticDistDir\": \"./dist\", \"settings\": { \"formFactor\": \"desktop\", \"screenEmulation\": { \"mobile\": false, \"width\": 1920, \"height\": 1080, \"deviceScaleFactor\": 1, \"disabled\": false } } }, \"assert\": { \"assertions\": { \"categories:performance\": [\"error\", { \"minScore\": 0.8 }], \"categories:accessibility\": [\"error\", { \"minScore\": 0.95 }], \"categories:best-practices\": [\"error\", { \"minScore\": 1 }], \"categories:seo\": [\"error\", { \"minScore\": 0.9 }], \"categories:pwa\": [\"warn\", { \"minScore\": 0.99 }] } } } } 需要将 lhci Server 生成的 Build token 和 lhci Server 的地址存放在 GitHub 项目的 Secrets 中 这里执行了两次 lhci 命令。因为 lhci autorun 运行完成后会运行默认的断言(Assertion), 第一次用没有断言的命令，目的是将当前的网页性能可以上到 Server 端; 第二次配置了各项指标的阈值，如果不满足要求，Pipeline 将会阻断，实现 Web 性能测试左移。 ","date":"2022-03-27","objectID":"/2022/03/%E4%BD%BF%E7%94%A8-lighthouse-%E6%8C%81%E7%BB%AD%E4%BC%98%E5%8C%96%E4%BD%A0%E7%9A%84-web-%E6%80%A7%E8%83%BD/:4:3","tags":["lhci","Lighthouse","CI","CD","performance","webpref"],"title":"使用 Lighthouse 持续优化你的 Web 性能","uri":"/2022/03/%E4%BD%BF%E7%94%A8-lighthouse-%E6%8C%81%E7%BB%AD%E4%BC%98%E5%8C%96%E4%BD%A0%E7%9A%84-web-%E6%80%A7%E8%83%BD/"},{"categories":["Tool"],"content":"总结 对于：开发人员、技术领导或者市场营销人员 他们想：持续量化并展示 Web 页面的性能 这个：Lighthouse CI 是一个：由 Google 编写的一套工具，可以持续运行、保存、检索并对 Lighthouse 结果进行断言变得尽可能简单。它可以评估 Web 应用和页面，以及从开发的最佳实践中收集性能指标和洞见等信息 它可以：测试你的 Web 页面，得到 Web 页面的 Performance 、 Accessibility 、 Best Practices 、 SEO 和 PWA 在不同设备上的分数, 这些分数可以用于分析产品性能，帮助提升用户转化率等 不同于：treo 或者其他一些 Web 性能测试工具 它的优势是: Open-Source, Free, Self-hosted data and Server, Easy to integrate。 ","date":"2022-03-27","objectID":"/2022/03/%E4%BD%BF%E7%94%A8-lighthouse-%E6%8C%81%E7%BB%AD%E4%BC%98%E5%8C%96%E4%BD%A0%E7%9A%84-web-%E6%80%A7%E8%83%BD/:5:0","tags":["lhci","Lighthouse","CI","CD","performance","webpref"],"title":"使用 Lighthouse 持续优化你的 Web 性能","uri":"/2022/03/%E4%BD%BF%E7%94%A8-lighthouse-%E6%8C%81%E7%BB%AD%E4%BC%98%E5%8C%96%E4%BD%A0%E7%9A%84-web-%E6%80%A7%E8%83%BD/"},{"categories":["Tool"],"content":"Refs Get Down to Business: Why the Web Matters (Chrome Dev Summit 2018): https://web.dev/i18n/zh/why-speed-matters/ 为什么速度很重要？: https://web.dev/i18n/zh/why-speed-matters Lighthouse: https://developers.google.cn/web/tools/lighthouse 博客:https://guzhongren.github.io/ ","date":"2022-03-27","objectID":"/2022/03/%E4%BD%BF%E7%94%A8-lighthouse-%E6%8C%81%E7%BB%AD%E4%BC%98%E5%8C%96%E4%BD%A0%E7%9A%84-web-%E6%80%A7%E8%83%BD/:6:0","tags":["lhci","Lighthouse","CI","CD","performance","webpref"],"title":"使用 Lighthouse 持续优化你的 Web 性能","uri":"/2022/03/%E4%BD%BF%E7%94%A8-lighthouse-%E6%8C%81%E7%BB%AD%E4%BC%98%E5%8C%96%E4%BD%A0%E7%9A%84-web-%E6%80%A7%E8%83%BD/"},{"categories":["Tool"],"content":"Disclaimer 本文仅代表个人观点，与 Thoughtworks 公司无任何关系。 SHA256 checksum: f2fe1394e4ab9297ed69ff73ac32e9ac1375f01c2102183b509bf9379a5995d6 ","date":"2022-03-27","objectID":"/2022/03/%E4%BD%BF%E7%94%A8-lighthouse-%E6%8C%81%E7%BB%AD%E4%BC%98%E5%8C%96%E4%BD%A0%E7%9A%84-web-%E6%80%A7%E8%83%BD/:7:0","tags":["lhci","Lighthouse","CI","CD","performance","webpref"],"title":"使用 Lighthouse 持续优化你的 Web 性能","uri":"/2022/03/%E4%BD%BF%E7%94%A8-lighthouse-%E6%8C%81%E7%BB%AD%E4%BC%98%E5%8C%96%E4%BD%A0%E7%9A%84-web-%E6%80%A7%E8%83%BD/"},{"categories":["Tool"],"content":"赞助 SHA256 checksum: 964978ecd2059064abe542e51dc02e204d3ee2e6c320ca68e2b1399ce0c6953c 使用此文件进行校验： gpg --verify PayForGuzhongren.svg.sig ","date":"2022-03-27","objectID":"/2022/03/%E4%BD%BF%E7%94%A8-lighthouse-%E6%8C%81%E7%BB%AD%E4%BC%98%E5%8C%96%E4%BD%A0%E7%9A%84-web-%E6%80%A7%E8%83%BD/:8:0","tags":["lhci","Lighthouse","CI","CD","performance","webpref"],"title":"使用 Lighthouse 持续优化你的 Web 性能","uri":"/2022/03/%E4%BD%BF%E7%94%A8-lighthouse-%E6%8C%81%E7%BB%AD%E4%BC%98%E5%8C%96%E4%BD%A0%E7%9A%84-web-%E6%80%A7%E8%83%BD/"},{"categories":["碎碎念"],"content":"这个社会怎么了 最近的热点都被俄罗斯攻打乌克兰占领了，没有一点悬念的是社交网站上出现了完全不同立场的人的极端言论。 国家已经在各个发布会上表明了 ZF 的立场，个人还在自己的朋友圈、公众号、社交平台上发布各种言论；远远的只能是说一句 真是辛苦那些社交媒体了，以后的社交媒体恐怕又要加几条规则了；暴力机器在这，一个小小的零部件又怎能翻起大浪呢。 如此的凑热闹，看来还是房贷压力比较小，七大姑八大姨不催你。 ","date":"2022-02-27","objectID":"/2022/02/%E6%B5%AE%E8%BA%81%E7%9A%84%E6%97%B6%E4%BB%A3%E6%9B%B4%E9%9C%80%E8%A6%81%E6%B2%89%E6%B7%80%E8%87%AA%E5%B7%B1/:1:0","tags":["不要随便蹭热点","稳重点","成年人"],"title":"浮躁的时代更需要沉淀自己","uri":"/2022/02/%E6%B5%AE%E8%BA%81%E7%9A%84%E6%97%B6%E4%BB%A3%E6%9B%B4%E9%9C%80%E8%A6%81%E6%B2%89%E6%B7%80%E8%87%AA%E5%B7%B1/"},{"categories":["碎碎念"],"content":"短视频 不管是抖音，腾讯还是哪个巨头，都在尽可能的抢夺用户的时间。首先，巨头们通过各种手段让用户安装他们的短视频应用，然后再利用自己的 AI 平台向用户推送各种与用户相关的信息，导致用户形成一个个的信息茧 fang，用户看什么由平台决定，而且用户收到的永远都是自己感兴趣的。所以一打开手机的短视频应用，你就永远都停不下来了。 ","date":"2022-02-27","objectID":"/2022/02/%E6%B5%AE%E8%BA%81%E7%9A%84%E6%97%B6%E4%BB%A3%E6%9B%B4%E9%9C%80%E8%A6%81%E6%B2%89%E6%B7%80%E8%87%AA%E5%B7%B1/:1:1","tags":["不要随便蹭热点","稳重点","成年人"],"title":"浮躁的时代更需要沉淀自己","uri":"/2022/02/%E6%B5%AE%E8%BA%81%E7%9A%84%E6%97%B6%E4%BB%A3%E6%9B%B4%E9%9C%80%E8%A6%81%E6%B2%89%E6%B7%80%E8%87%AA%E5%B7%B1/"},{"categories":["碎碎念"],"content":"社交平台 社交媒体上有各式各样的图片与言论，比如最近的俄乌战争。有的人支持乌克兰，就把记得的社交头像换成 I stand with UKL的文字或者乌克兰的国旗，有的更是挖出了俄罗斯占领中国领土的地图，上面标注了时间和面积；有的人支持俄罗斯，理由可能是俄罗斯和中国比较亲。 社交媒体上所有的事不一定都是真事，不要轻易发表自己的看法；所谓让子弹飞一会儿，有些事，更是需要让历史来评判。 未经他人苦，莫劝他人善， 也不要随随便便去评判他人。 ","date":"2022-02-27","objectID":"/2022/02/%E6%B5%AE%E8%BA%81%E7%9A%84%E6%97%B6%E4%BB%A3%E6%9B%B4%E9%9C%80%E8%A6%81%E6%B2%89%E6%B7%80%E8%87%AA%E5%B7%B1/:1:2","tags":["不要随便蹭热点","稳重点","成年人"],"title":"浮躁的时代更需要沉淀自己","uri":"/2022/02/%E6%B5%AE%E8%BA%81%E7%9A%84%E6%97%B6%E4%BB%A3%E6%9B%B4%E9%9C%80%E8%A6%81%E6%B2%89%E6%B7%80%E8%87%AA%E5%B7%B1/"},{"categories":["碎碎念"],"content":"该怎么与这个世界相处 可能我们很难理解这个世界的运行规则，但我们还得跟这个世界好好相处。 ","date":"2022-02-27","objectID":"/2022/02/%E6%B5%AE%E8%BA%81%E7%9A%84%E6%97%B6%E4%BB%A3%E6%9B%B4%E9%9C%80%E8%A6%81%E6%B2%89%E6%B7%80%E8%87%AA%E5%B7%B1/:2:0","tags":["不要随便蹭热点","稳重点","成年人"],"title":"浮躁的时代更需要沉淀自己","uri":"/2022/02/%E6%B5%AE%E8%BA%81%E7%9A%84%E6%97%B6%E4%BB%A3%E6%9B%B4%E9%9C%80%E8%A6%81%E6%B2%89%E6%B7%80%E8%87%AA%E5%B7%B1/"},{"categories":["碎碎念"],"content":"考证 在中国可能有很多地方，证书是很有说服力的，实力不一定重要。作为计算机行业的从业者，可以考个软考之类的； 也可以考一些诸如公司要用的，比如云计算，DevOps 相关的证书，虽然有有效期，但是在相应的时间段说不定就有收入上的增加。 ","date":"2022-02-27","objectID":"/2022/02/%E6%B5%AE%E8%BA%81%E7%9A%84%E6%97%B6%E4%BB%A3%E6%9B%B4%E9%9C%80%E8%A6%81%E6%B2%89%E6%B7%80%E8%87%AA%E5%B7%B1/:2:1","tags":["不要随便蹭热点","稳重点","成年人"],"title":"浮躁的时代更需要沉淀自己","uri":"/2022/02/%E6%B5%AE%E8%BA%81%E7%9A%84%E6%97%B6%E4%BB%A3%E6%9B%B4%E9%9C%80%E8%A6%81%E6%B2%89%E6%B7%80%E8%87%AA%E5%B7%B1/"},{"categories":["碎碎念"],"content":"实践 现实的工作中我们不可能只专注一方面，所以我们得学习更多的技能，而且很多新技能是没有衡量体系的，所以我们只有不断的练习或者产出才能证明我们在这一方面的能力；也可以参与到开源项目中，当然是那种带着学习实践的心态，用学到的技术解决问题最有成就感，不是吗？ ","date":"2022-02-27","objectID":"/2022/02/%E6%B5%AE%E8%BA%81%E7%9A%84%E6%97%B6%E4%BB%A3%E6%9B%B4%E9%9C%80%E8%A6%81%E6%B2%89%E6%B7%80%E8%87%AA%E5%B7%B1/:2:2","tags":["不要随便蹭热点","稳重点","成年人"],"title":"浮躁的时代更需要沉淀自己","uri":"/2022/02/%E6%B5%AE%E8%BA%81%E7%9A%84%E6%97%B6%E4%BB%A3%E6%9B%B4%E9%9C%80%E8%A6%81%E6%B2%89%E6%B7%80%E8%87%AA%E5%B7%B1/"},{"categories":["碎碎念"],"content":"Refs 博客：https://guzhongren.github.io/ ","date":"2022-02-27","objectID":"/2022/02/%E6%B5%AE%E8%BA%81%E7%9A%84%E6%97%B6%E4%BB%A3%E6%9B%B4%E9%9C%80%E8%A6%81%E6%B2%89%E6%B7%80%E8%87%AA%E5%B7%B1/:3:0","tags":["不要随便蹭热点","稳重点","成年人"],"title":"浮躁的时代更需要沉淀自己","uri":"/2022/02/%E6%B5%AE%E8%BA%81%E7%9A%84%E6%97%B6%E4%BB%A3%E6%9B%B4%E9%9C%80%E8%A6%81%E6%B2%89%E6%B7%80%E8%87%AA%E5%B7%B1/"},{"categories":["碎碎念"],"content":"Disclaimer 本文仅代表个人观点，与 Thoughtworks 公司无任何关系。 SHA256 checksum: f2fe1394e4ab9297ed69ff73ac32e9ac1375f01c2102183b509bf9379a5995d6 ","date":"2022-02-27","objectID":"/2022/02/%E6%B5%AE%E8%BA%81%E7%9A%84%E6%97%B6%E4%BB%A3%E6%9B%B4%E9%9C%80%E8%A6%81%E6%B2%89%E6%B7%80%E8%87%AA%E5%B7%B1/:4:0","tags":["不要随便蹭热点","稳重点","成年人"],"title":"浮躁的时代更需要沉淀自己","uri":"/2022/02/%E6%B5%AE%E8%BA%81%E7%9A%84%E6%97%B6%E4%BB%A3%E6%9B%B4%E9%9C%80%E8%A6%81%E6%B2%89%E6%B7%80%E8%87%AA%E5%B7%B1/"},{"categories":["碎碎念"],"content":"赞助 SHA256 checksum: 964978ecd2059064abe542e51dc02e204d3ee2e6c320ca68e2b1399ce0c6953c 使用此 文件 进行校验： gpg --verify PayForGuzhongren.svg.sig ","date":"2022-02-27","objectID":"/2022/02/%E6%B5%AE%E8%BA%81%E7%9A%84%E6%97%B6%E4%BB%A3%E6%9B%B4%E9%9C%80%E8%A6%81%E6%B2%89%E6%B7%80%E8%87%AA%E5%B7%B1/:5:0","tags":["不要随便蹭热点","稳重点","成年人"],"title":"浮躁的时代更需要沉淀自己","uri":"/2022/02/%E6%B5%AE%E8%BA%81%E7%9A%84%E6%97%B6%E4%BB%A3%E6%9B%B4%E9%9C%80%E8%A6%81%E6%B2%89%E6%B7%80%E8%87%AA%E5%B7%B1/"},{"categories":["Tool"],"content":"使用 GitHub Action 完成 Algolia 索引数据上传并实践 GitHub Action","date":"2022-01-20","objectID":"/2022/01/%E6%9E%84%E5%BB%BA%E6%9B%B4%E4%BC%98%E7%9A%84github-action%E5%AE%8C%E6%88%90algolia%E6%95%B0%E6%8D%AE%E4%B8%8A%E4%BC%A0/","tags":["GitHub","Action","Performance"],"title":"构建更优的 GitHub Action 完成 Algolia 数据上传","uri":"/2022/01/%E6%9E%84%E5%BB%BA%E6%9B%B4%E4%BC%98%E7%9A%84github-action%E5%AE%8C%E6%88%90algolia%E6%95%B0%E6%8D%AE%E4%B8%8A%E4%BC%A0/"},{"categories":["Tool"],"content":"场景 程序员喜欢写博客，大都喜欢自己 Host 一个自己的 Blog, 通常 Blog 会有一个全局的搜索功能，开源博客一般都会选择 lunrjs 或者 algolia 等。我的 Blog 是基于 Hugo 构建的，使用的主题是 LoveIt, 集成的是 algolia 的搜索方式。 对于存储在 algolia 上的数据，我是通过 GitHub Action：Algolia Docsearch Indexer 来上传的，之前使用是没有问题的。 ","date":"2022-01-20","objectID":"/2022/01/%E6%9E%84%E5%BB%BA%E6%9B%B4%E4%BC%98%E7%9A%84github-action%E5%AE%8C%E6%88%90algolia%E6%95%B0%E6%8D%AE%E4%B8%8A%E4%BC%A0/:1:0","tags":["GitHub","Action","Performance"],"title":"构建更优的 GitHub Action 完成 Algolia 数据上传","uri":"/2022/01/%E6%9E%84%E5%BB%BA%E6%9B%B4%E4%BC%98%E7%9A%84github-action%E5%AE%8C%E6%88%90algolia%E6%95%B0%E6%8D%AE%E4%B8%8A%E4%BC%A0/"},{"categories":["Tool"],"content":"问题 突然有一天我要使用搜索功能，但是怎么也搜索不到我想搜索的内容，看了 GitHub 项目的构建状态，一切正常，然后登陆到 algolia 后台一看， 最后一次的数据更新是在 21 年 8 月； 然后打开最近的博客构建记录，看了执行如下 GitHub workflow 的 yaml 日志，大吃一惊：程序执行错误，但还是在最后给我们送了一个🚀，同样是写代码，你能忍？ - uses:darrenjennings/algolia-docsearch-action@masterwith:algolia_application_id:${{secrets.ALGOLIA_APPLICATION_ID}}algolia_api_key:${{secrets.ALGOLIA_API_KEY}}file:'./public/index.json' 运行日志 Run darrenjennings/algolia-docsearch-action@master /usr/bin/docker run --name a682564a13d76444749d3b720346ba2365371_9474ad --label 6a6825 --workdir /github/workspace --rm -e INPUT_ALGOLIA_APPLICATION_ID -e INPUT_ALGOLIA_API_KEY -e INPUT_FILE -e HOME -e GITHUB_JOB -e GITHUB_REF -e GITHUB_SHA -e GITHUB_REPOSITORY -e GITHUB_REPOSITORY_OWNER -e GITHUB_RUN_ID -e GITHUB_RUN_NUMBER -e GITHUB_RETENTION_DAYS -e GITHUB_RUN_ATTEMPT -e GITHUB_ACTOR -e GITHUB_WORKFLOW -e GITHUB_HEAD_REF -e GITHUB_BASE_REF -e GITHUB_EVENT_NAME -e GITHUB_SERVER_URL -e GITHUB_API_URL -e GITHUB_GRAPHQL_URL -e GITHUB_REF_NAME -e GITHUB_REF_PROTECTED -e GITHUB_REF_TYPE -e GITHUB_WORKSPACE -e GITHUB_ACTION -e GITHUB_EVENT_PATH -e GITHUB_ACTION_REPOSITORY -e GITHUB_ACTION_REF -e GITHUB_PATH -e GITHUB_ENV -e RUNNER_OS -e RUNNER_ARCH -e RUNNER_NAME -e RUNNER_TOOL_CACHE -e RUNNER_TEMP -e RUNNER_WORKSPACE -e ACTIONS_RUNTIME_URL -e ACTIONS_RUNTIME_TOKEN -e ACTIONS_CACHE_URL -e GITHUB_ACTIONS=true -e CI=true -v \"/var/run/docker.sock\":\"/var/run/docker.sock\" -v \"/home/runner/work/_temp/_github_home\":\"/github/home\" -v \"/home/runner/work/_temp/_github_workflow\":\"/github/workflow\" -v \"/home/runner/work/_temp/_runner_file_commands\":\"/github/file_commands\" -v \"/home/runner/work/blog/blog\":\"/github/workspace\" 6a6825:64a13d76444749d3b720346ba2365371 \"***\" \"***\" \"./public/index.json\" Cloning into 'docsearch-scraper'... Collecting pipenv Downloading pipenv-2021.11.23-py2.py3-none-any.whl (3.6 MB) Collecting virtualenv Downloading virtualenv-20.10.0-py2.py3-none-any.whl (5.6 MB) Requirement already satisfied: pip\u003e=18.0 in /usr/local/lib/python3.6/site-packages (from pipenv) (21.2.4) Requirement already satisfied: setuptools\u003e=36.2.1 in /usr/local/lib/python3.6/site-packages (from pipenv) (57.5.0) Collecting virtualenv-clone\u003e=0.2.5 Downloading virtualenv_clone-0.5.7-py3-none-any.whl (6.6 kB) Collecting certifi Downloading certifi-2021.10.8-py2.py3-none-any.whl (149 kB) Collecting importlib-resources\u003e=1.0 Downloading importlib_resources-5.4.0-py3-none-any.whl (28 kB) Collecting backports.entry-points-selectable\u003e=1.0.4 Downloading backports.entry_points_selectable-1.1.1-py2.py3-none-any.whl (6.2 kB) Collecting six\u003c2,\u003e=1.9.0 Downloading six-1.16.0-py2.py3-none-any.whl (11 kB) Collecting importlib-metadata\u003e=0.12 Downloading importlib_metadata-4.8.3-py3-none-any.whl (17 kB) Collecting filelock\u003c4,\u003e=3.2 Downloading filelock-3.4.1-py3-none-any.whl (9.9 kB) Collecting distlib\u003c1,\u003e=0.3.1 Downloading distlib-0.3.4-py2.py3-none-any.whl (461 kB) Collecting platformdirs\u003c3,\u003e=2 Downloading platformdirs-2.4.0-py3-none-any.whl (14 kB) Collecting zipp\u003e=0.5 Downloading zipp-3.6.0-py3-none-any.whl (5.3 kB) Collecting typing-extensions\u003e=3.6.4 Downloading typing_extensions-4.0.1-py3-none-any.whl (22 kB) Installing collected packages: zipp, typing-extensions, importlib-metadata, six, platformdirs, importlib-resources, filelock, distlib, backports.entry-points-selectable, virtualenv-clone, virtualenv, certifi, pipenv WARNING: Running pip as the 'root' user can result in broken permissions and conflicting behaviour with the system package manager. It is recommended to use a virtual environment instead: https://pip.pypa.io/warnings/venv Successfully installed backports.entry-points-selectable-1.1.1 certifi-2021.10.8 distlib-0.3.4 filelock-3.4.1 importlib-metadata-4.8.3 importlib-resources-5.4.0 pipenv-2021.11.23 platformdirs-2.4.0 six-1.16.0 typing-extensions-4.0.1 virtualenv-20.10.0 virtualenv-clone-0.5.7 zipp-3.6.0 WARNING: You are using pip version 21.2.4; however, version 21.3.1 is available. You should consider upgrading via the '/usr/l","date":"2022-01-20","objectID":"/2022/01/%E6%9E%84%E5%BB%BA%E6%9B%B4%E4%BC%98%E7%9A%84github-action%E5%AE%8C%E6%88%90algolia%E6%95%B0%E6%8D%AE%E4%B8%8A%E4%BC%A0/:2:0","tags":["GitHub","Action","Performance"],"title":"构建更优的 GitHub Action 完成 Algolia 数据上传","uri":"/2022/01/%E6%9E%84%E5%BB%BA%E6%9B%B4%E4%BC%98%E7%9A%84github-action%E5%AE%8C%E6%88%90algolia%E6%95%B0%E6%8D%AE%E4%B8%8A%E4%BC%A0/"},{"categories":["Tool"],"content":"面临的问题 工具损坏 镜像体积大 ","date":"2022-01-20","objectID":"/2022/01/%E6%9E%84%E5%BB%BA%E6%9B%B4%E4%BC%98%E7%9A%84github-action%E5%AE%8C%E6%88%90algolia%E6%95%B0%E6%8D%AE%E4%B8%8A%E4%BC%A0/:2:1","tags":["GitHub","Action","Performance"],"title":"构建更优的 GitHub Action 完成 Algolia 数据上传","uri":"/2022/01/%E6%9E%84%E5%BB%BA%E6%9B%B4%E4%BC%98%E7%9A%84github-action%E5%AE%8C%E6%88%90algolia%E6%95%B0%E6%8D%AE%E4%B8%8A%E4%BC%A0/"},{"categories":["Tool"],"content":"方案 Spike Item Option1 使用 algolia 自己的 Restful 接口 Option 2 algolia SDK 描述 使用 algolia 自己的 Restful 接口实现上传 使用其官方提供的 SDK 编写代码来集成 是否推荐 No Yes 实现难度 Middle Low 优点 流程可控 简单直接，无需担心错误情况的处理 缺点 需要写更多的代码来控制整个流程 整个上传过程不可控 安全问题 No No 相对难度 Middle Low 相对成本 Middle Low 综上分析，使用 Option2 SDK 的方案更佳。 ","date":"2022-01-20","objectID":"/2022/01/%E6%9E%84%E5%BB%BA%E6%9B%B4%E4%BC%98%E7%9A%84github-action%E5%AE%8C%E6%88%90algolia%E6%95%B0%E6%8D%AE%E4%B8%8A%E4%BC%A0/:3:0","tags":["GitHub","Action","Performance"],"title":"构建更优的 GitHub Action 完成 Algolia 数据上传","uri":"/2022/01/%E6%9E%84%E5%BB%BA%E6%9B%B4%E4%BC%98%E7%9A%84github-action%E5%AE%8C%E6%88%90algolia%E6%95%B0%E6%8D%AE%E4%B8%8A%E4%BC%A0/"},{"categories":["Tool"],"content":"执行方案 新建 GitHub Action 项目，我们使用 Dockerfile 的方式构建上传索引的方案； 新建 entrypoint.sh 并写入如下代码，脚本执行需要传入如下几个变量： Name Description Required FILE_PATH 要上传的文件路径 Yes ALGOLIA_APPLICATION_ID Algolia 平台的应用 Id Yes ADMIN_API_KEY Algolia 上传所用的 API Key Yes INDEX_NAME 在 Algolia 上你所创建的索引名 Yes #!/bin/sh set -eu npm install -g @algolia/cli algolia import -s $FILE_PATH -a $APPLICATION_ID -k $ADMIN_API_KEY -n $INDEX_NAME if [ \"$?\" != \"0\" ] ; then echo \"😢 Failed to upload your data to Algolia, PLZ report an issue, thx!\" exit 1 fi echo \"🚀 Successfully uploaded!\" 新建 Dockerfile 并写入如下代码，在此我们使用最小化的 Node 镜像 node:lts-alpine FROM node:lts-alpine COPY entrypoint.sh /entrypoint.sh ENTRYPOINT [\"/entrypoint.sh\"] 更新 README, 完善使用文档。 详细代码请参考 algolia-docsearch-upload-action。 ","date":"2022-01-20","objectID":"/2022/01/%E6%9E%84%E5%BB%BA%E6%9B%B4%E4%BC%98%E7%9A%84github-action%E5%AE%8C%E6%88%90algolia%E6%95%B0%E6%8D%AE%E4%B8%8A%E4%BC%A0/:4:0","tags":["GitHub","Action","Performance"],"title":"构建更优的 GitHub Action 完成 Algolia 数据上传","uri":"/2022/01/%E6%9E%84%E5%BB%BA%E6%9B%B4%E4%BC%98%E7%9A%84github-action%E5%AE%8C%E6%88%90algolia%E6%95%B0%E6%8D%AE%E4%B8%8A%E4%BC%A0/"},{"categories":["Tool"],"content":"验证结果 在完成 Action 并将其集成到 Pipeline 上之后，成功运行，数据可成功上传到 Algolia 平台上，并且博客的右上角的搜索功能可以成功搜索到最新的文章，说明我们的 Action 是可以完成我们的需求的。 ","date":"2022-01-20","objectID":"/2022/01/%E6%9E%84%E5%BB%BA%E6%9B%B4%E4%BC%98%E7%9A%84github-action%E5%AE%8C%E6%88%90algolia%E6%95%B0%E6%8D%AE%E4%B8%8A%E4%BC%A0/:5:0","tags":["GitHub","Action","Performance"],"title":"构建更优的 GitHub Action 完成 Algolia 数据上传","uri":"/2022/01/%E6%9E%84%E5%BB%BA%E6%9B%B4%E4%BC%98%E7%9A%84github-action%E5%AE%8C%E6%88%90algolia%E6%95%B0%E6%8D%AE%E4%B8%8A%E4%BC%A0/"},{"categories":["Tool"],"content":"运行效率比较 没有对比就没有伤害。下面对我自己写的 Action 和之前集成过的 Action 在镜像大小和执行效率方面进行对比。 ","date":"2022-01-20","objectID":"/2022/01/%E6%9E%84%E5%BB%BA%E6%9B%B4%E4%BC%98%E7%9A%84github-action%E5%AE%8C%E6%88%90algolia%E6%95%B0%E6%8D%AE%E4%B8%8A%E4%BC%A0/:5:1","tags":["GitHub","Action","Performance"],"title":"构建更优的 GitHub Action 完成 Algolia 数据上传","uri":"/2022/01/%E6%9E%84%E5%BB%BA%E6%9B%B4%E4%BC%98%E7%9A%84github-action%E5%AE%8C%E6%88%90algolia%E6%95%B0%E6%8D%AE%E4%B8%8A%E4%BC%A0/"},{"categories":["Tool"],"content":"镜像大小比较 ","date":"2022-01-20","objectID":"/2022/01/%E6%9E%84%E5%BB%BA%E6%9B%B4%E4%BC%98%E7%9A%84github-action%E5%AE%8C%E6%88%90algolia%E6%95%B0%E6%8D%AE%E4%B8%8A%E4%BC%A0/:5:2","tags":["GitHub","Action","Performance"],"title":"构建更优的 GitHub Action 完成 Algolia 数据上传","uri":"/2022/01/%E6%9E%84%E5%BB%BA%E6%9B%B4%E4%BC%98%E7%9A%84github-action%E5%AE%8C%E6%88%90algolia%E6%95%B0%E6%8D%AE%E4%B8%8A%E4%BC%A0/"},{"categories":["Tool"],"content":"Refs 博客：https://guzhongren.github.io/ Algolia Docsearch Indexer: https://github.com/marketplace/actions/algolia-docsearch-indexer GitHub Action: https://docs.github.com/en/actions ","date":"2022-01-20","objectID":"/2022/01/%E6%9E%84%E5%BB%BA%E6%9B%B4%E4%BC%98%E7%9A%84github-action%E5%AE%8C%E6%88%90algolia%E6%95%B0%E6%8D%AE%E4%B8%8A%E4%BC%A0/:6:0","tags":["GitHub","Action","Performance"],"title":"构建更优的 GitHub Action 完成 Algolia 数据上传","uri":"/2022/01/%E6%9E%84%E5%BB%BA%E6%9B%B4%E4%BC%98%E7%9A%84github-action%E5%AE%8C%E6%88%90algolia%E6%95%B0%E6%8D%AE%E4%B8%8A%E4%BC%A0/"},{"categories":["Tool"],"content":"Disclaimer 本文仅代表个人观点，与 Thoughtworks 公司无任何关系。 SHA256 checksum: f2fe1394e4ab9297ed69ff73ac32e9ac1375f01c2102183b509bf9379a5995d6 ","date":"2022-01-20","objectID":"/2022/01/%E6%9E%84%E5%BB%BA%E6%9B%B4%E4%BC%98%E7%9A%84github-action%E5%AE%8C%E6%88%90algolia%E6%95%B0%E6%8D%AE%E4%B8%8A%E4%BC%A0/:7:0","tags":["GitHub","Action","Performance"],"title":"构建更优的 GitHub Action 完成 Algolia 数据上传","uri":"/2022/01/%E6%9E%84%E5%BB%BA%E6%9B%B4%E4%BC%98%E7%9A%84github-action%E5%AE%8C%E6%88%90algolia%E6%95%B0%E6%8D%AE%E4%B8%8A%E4%BC%A0/"},{"categories":["Tool"],"content":"赞助 SHA256 checksum: 964978ecd2059064abe542e51dc02e204d3ee2e6c320ca68e2b1399ce0c6953c 使用此 文件 进行校验： gpg --verify PayForGuzhongren.svg.sig ","date":"2022-01-20","objectID":"/2022/01/%E6%9E%84%E5%BB%BA%E6%9B%B4%E4%BC%98%E7%9A%84github-action%E5%AE%8C%E6%88%90algolia%E6%95%B0%E6%8D%AE%E4%B8%8A%E4%BC%A0/:8:0","tags":["GitHub","Action","Performance"],"title":"构建更优的 GitHub Action 完成 Algolia 数据上传","uri":"/2022/01/%E6%9E%84%E5%BB%BA%E6%9B%B4%E4%BC%98%E7%9A%84github-action%E5%AE%8C%E6%88%90algolia%E6%95%B0%E6%8D%AE%E4%B8%8A%E4%BC%A0/"},{"categories":["Test"],"content":"缘由 最近在做一个 Buildkite 的 Dashboard 的项目 Powerboard，项目是托管在 GitHub 的 Git Pages 上的；项目只是一个纯前端项目，且 E2E 测试是用 Cypress 构建的；如果要进行 E2E 测试一般情况都是对着部署在 Git Pages 上的网站直接测试，而且也是这么做的😄。 ","date":"2022-01-16","objectID":"/2022/01/%E4%BD%BF%E7%94%A8cypress%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E9%95%9C%E5%83%8F%E5%B9%B6%E5%AE%8C%E6%88%90e2e%E6%B5%8B%E8%AF%95/:1:0","tags":["cypress","E2E","测试"],"title":"使用 Cypress 创建测试镜像并完成 E2E 测试","uri":"/2022/01/%E4%BD%BF%E7%94%A8cypress%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E9%95%9C%E5%83%8F%E5%B9%B6%E5%AE%8C%E6%88%90e2e%E6%B5%8B%E8%AF%95/"},{"categories":["Test"],"content":"痛点 ","date":"2022-01-16","objectID":"/2022/01/%E4%BD%BF%E7%94%A8cypress%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E9%95%9C%E5%83%8F%E5%B9%B6%E5%AE%8C%E6%88%90e2e%E6%B5%8B%E8%AF%95/:2:0","tags":["cypress","E2E","测试"],"title":"使用 Cypress 创建测试镜像并完成 E2E 测试","uri":"/2022/01/%E4%BD%BF%E7%94%A8cypress%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E9%95%9C%E5%83%8F%E5%B9%B6%E5%AE%8C%E6%88%90e2e%E6%B5%8B%E8%AF%95/"},{"categories":["Test"],"content":"测试滞后 这么做肯定是有问题的，产品都上线了才做测试，肯定已经迟了；如果程序有问题，那么就会影响所有用户。这种情况应该算是 P1 级别的产品事故，对用户来说简直就是灾难。应该在部署之前就应该完成 E2E 测试，如果测试通过不了，就不应该部署代码。所以测试应该前移。 ","date":"2022-01-16","objectID":"/2022/01/%E4%BD%BF%E7%94%A8cypress%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E9%95%9C%E5%83%8F%E5%B9%B6%E5%AE%8C%E6%88%90e2e%E6%B5%8B%E8%AF%95/:2:1","tags":["cypress","E2E","测试"],"title":"使用 Cypress 创建测试镜像并完成 E2E 测试","uri":"/2022/01/%E4%BD%BF%E7%94%A8cypress%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E9%95%9C%E5%83%8F%E5%B9%B6%E5%AE%8C%E6%88%90e2e%E6%B5%8B%E8%AF%95/"},{"categories":["Test"],"content":"解决方案 由于我们的测试需要自动化，需要在 Pipeline 上执行，所以必须是一个可以独立运行的程序和 Cypress 程序同时运行，并最终返回测试结果，由 Pipeline 来决定是否终止 Pipeline 运行。 在 GitHub Actions 的 Pipeline 上同时运行程序只能依靠 docker-compose, 在这我们可以使用 Cypress 官方出品的 cypress/included, 通过编排程序来进行测试。 ","date":"2022-01-16","objectID":"/2022/01/%E4%BD%BF%E7%94%A8cypress%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E9%95%9C%E5%83%8F%E5%B9%B6%E5%AE%8C%E6%88%90e2e%E6%B5%8B%E8%AF%95/:3:0","tags":["cypress","E2E","测试"],"title":"使用 Cypress 创建测试镜像并完成 E2E 测试","uri":"/2022/01/%E4%BD%BF%E7%94%A8cypress%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E9%95%9C%E5%83%8F%E5%B9%B6%E5%AE%8C%E6%88%90e2e%E6%B5%8B%E8%AF%95/"},{"categories":["Test"],"content":"cypress/included cypress/included 可以让我们挂载 cypress 的测试脚本，然后自动执行，并在最终返回 Linux 命令状态值，如 0 ， 非 0 值。 ","date":"2022-01-16","objectID":"/2022/01/%E4%BD%BF%E7%94%A8cypress%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E9%95%9C%E5%83%8F%E5%B9%B6%E5%AE%8C%E6%88%90e2e%E6%B5%8B%E8%AF%95/:3:1","tags":["cypress","E2E","测试"],"title":"使用 Cypress 创建测试镜像并完成 E2E 测试","uri":"/2022/01/%E4%BD%BF%E7%94%A8cypress%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E9%95%9C%E5%83%8F%E5%B9%B6%E5%AE%8C%E6%88%90e2e%E6%B5%8B%E8%AF%95/"},{"categories":["Test"],"content":"Docker-compose Docker-compose 是一套容器编排工具，可以很轻松的管理容器的启动顺序等。在本地项目搭建中非常有用，比如构建数据库，执行 shell/yaml lint 等。 ","date":"2022-01-16","objectID":"/2022/01/%E4%BD%BF%E7%94%A8cypress%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E9%95%9C%E5%83%8F%E5%B9%B6%E5%AE%8C%E6%88%90e2e%E6%B5%8B%E8%AF%95/:3:2","tags":["cypress","E2E","测试"],"title":"使用 Cypress 创建测试镜像并完成 E2E 测试","uri":"/2022/01/%E4%BD%BF%E7%94%A8cypress%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E9%95%9C%E5%83%8F%E5%B9%B6%E5%AE%8C%E6%88%90e2e%E6%B5%8B%E8%AF%95/"},{"categories":["Test"],"content":"执行方案 ","date":"2022-01-16","objectID":"/2022/01/%E4%BD%BF%E7%94%A8cypress%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E9%95%9C%E5%83%8F%E5%B9%B6%E5%AE%8C%E6%88%90e2e%E6%B5%8B%E8%AF%95/:4:0","tags":["cypress","E2E","测试"],"title":"使用 Cypress 创建测试镜像并完成 E2E 测试","uri":"/2022/01/%E4%BD%BF%E7%94%A8cypress%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E9%95%9C%E5%83%8F%E5%B9%B6%E5%AE%8C%E6%88%90e2e%E6%B5%8B%E8%AF%95/"},{"categories":["Test"],"content":"构建应用镜像 在测试之前需要将应用构建好并部署好，我们可以用 Node 镜像打包应用，并利用容器的多阶段构建 (multi-stage builds) 完成应用轻量化构建，并部署在 Nginx 中。 FROM node:17-alpine as distPackageCOPY ./ /appWORKDIR /appRUN yarnRUN yarn buildFROM nginx:latestCOPY --from=distPackage /app/dist /usr/share/nginx/html ","date":"2022-01-16","objectID":"/2022/01/%E4%BD%BF%E7%94%A8cypress%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E9%95%9C%E5%83%8F%E5%B9%B6%E5%AE%8C%E6%88%90e2e%E6%B5%8B%E8%AF%95/:4:1","tags":["cypress","E2E","测试"],"title":"使用 Cypress 创建测试镜像并完成 E2E 测试","uri":"/2022/01/%E4%BD%BF%E7%94%A8cypress%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E9%95%9C%E5%83%8F%E5%B9%B6%E5%AE%8C%E6%88%90e2e%E6%B5%8B%E8%AF%95/"},{"categories":["Test"],"content":"编排 service 因为我们的程序需要在测试的时候就要部署好，所以我们可以利用 Docker-compose 的 build 参数，在容器启动时构建应用并部署。并在 cypress/included 启动是执行测试命令 npx cy:docker, 具体就是cross-env ENV=docker cypress run --spec 'cypress/integration/dashboard.spec.js。 version:'3'services:web:build:context:./dockerfile:./Dockerfilecontainer_name:webrestart:alwaysports:- '80:80'e2e:image:cypress/included:9.2.1container_name:cypressdepends_on:- webenvironment:- CYPRESS_baseUrl=http://web- ENV=dockercommand:npx cy:dockerworking_dir:/e2evolumes:- ./:/e2e 这样我们就可以独立的运行起真实程序和正式的测试程序了，具体的 Pipeline 可以参考 Powerboard 的 Workflow。 - name:E2Erun:|docker-compose up --build e2e ","date":"2022-01-16","objectID":"/2022/01/%E4%BD%BF%E7%94%A8cypress%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E9%95%9C%E5%83%8F%E5%B9%B6%E5%AE%8C%E6%88%90e2e%E6%B5%8B%E8%AF%95/:4:2","tags":["cypress","E2E","测试"],"title":"使用 Cypress 创建测试镜像并完成 E2E 测试","uri":"/2022/01/%E4%BD%BF%E7%94%A8cypress%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E9%95%9C%E5%83%8F%E5%B9%B6%E5%AE%8C%E6%88%90e2e%E6%B5%8B%E8%AF%95/"},{"categories":["Test"],"content":"总结 Docker-compopse 有很好的应用编排能力，可以很轻松的构建多服务程序；并在构建应用的时候可以使用多阶段构建来优化镜像大小。使用 Cypress 可以提高开发效率并可在 Pipeline 上保证程序的正确性。 ","date":"2022-01-16","objectID":"/2022/01/%E4%BD%BF%E7%94%A8cypress%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E9%95%9C%E5%83%8F%E5%B9%B6%E5%AE%8C%E6%88%90e2e%E6%B5%8B%E8%AF%95/:5:0","tags":["cypress","E2E","测试"],"title":"使用 Cypress 创建测试镜像并完成 E2E 测试","uri":"/2022/01/%E4%BD%BF%E7%94%A8cypress%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E9%95%9C%E5%83%8F%E5%B9%B6%E5%AE%8C%E6%88%90e2e%E6%B5%8B%E8%AF%95/"},{"categories":["Test"],"content":"Refs 博客：https://guzhongren.github.io/ Cypress: https://www.cypress.io/ cypress/included: https://hub.docker.com/r/cypress/included GitHub Actions: https://docs.github.com/en/actions Powerboard: https://github.com/guzhongren/Powerboard ","date":"2022-01-16","objectID":"/2022/01/%E4%BD%BF%E7%94%A8cypress%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E9%95%9C%E5%83%8F%E5%B9%B6%E5%AE%8C%E6%88%90e2e%E6%B5%8B%E8%AF%95/:6:0","tags":["cypress","E2E","测试"],"title":"使用 Cypress 创建测试镜像并完成 E2E 测试","uri":"/2022/01/%E4%BD%BF%E7%94%A8cypress%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E9%95%9C%E5%83%8F%E5%B9%B6%E5%AE%8C%E6%88%90e2e%E6%B5%8B%E8%AF%95/"},{"categories":["Test"],"content":"Disclaimer 本文仅代表个人观点，与 Thoughtworks 公司无任何关系。 SHA256 checksum: f2fe1394e4ab9297ed69ff73ac32e9ac1375f01c2102183b509bf9379a5995d6 ","date":"2022-01-16","objectID":"/2022/01/%E4%BD%BF%E7%94%A8cypress%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E9%95%9C%E5%83%8F%E5%B9%B6%E5%AE%8C%E6%88%90e2e%E6%B5%8B%E8%AF%95/:7:0","tags":["cypress","E2E","测试"],"title":"使用 Cypress 创建测试镜像并完成 E2E 测试","uri":"/2022/01/%E4%BD%BF%E7%94%A8cypress%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E9%95%9C%E5%83%8F%E5%B9%B6%E5%AE%8C%E6%88%90e2e%E6%B5%8B%E8%AF%95/"},{"categories":["Test"],"content":"赞助 SHA256 checksum: 964978ecd2059064abe542e51dc02e204d3ee2e6c320ca68e2b1399ce0c6953c 使用此 文件 进行校验： gpg --verify PayForGuzhongren.svg.sig ","date":"2022-01-16","objectID":"/2022/01/%E4%BD%BF%E7%94%A8cypress%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E9%95%9C%E5%83%8F%E5%B9%B6%E5%AE%8C%E6%88%90e2e%E6%B5%8B%E8%AF%95/:8:0","tags":["cypress","E2E","测试"],"title":"使用 Cypress 创建测试镜像并完成 E2E 测试","uri":"/2022/01/%E4%BD%BF%E7%94%A8cypress%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E9%95%9C%E5%83%8F%E5%B9%B6%E5%AE%8C%E6%88%90e2e%E6%B5%8B%E8%AF%95/"},{"categories":["Tool"],"content":"缘由 Docker 公司在 2021 年 8 月更新了 Docker Desktop 的 使用条款，决定对大企业（员工超过 250 人或者年收入超过 1 千万美元）用户（包含员工的个人性质使用）开始执行收费订阅的策略，于 2021 年 8 月 31 日生效，同时，给了使用者一个缓冲时间，延续到 2022 年 1 月 31 日，在此之前可以继续免费使用。 很明显，开源公司在这个伸手的年代活不下去了，还有最近比较火的 Facker.js 删库事件。对删库这事多说几句，因为自家火灾，作者房子被烧了，然后他想让使用自己辛辛苦苦免费维护的 Facker.js 的这些商业公司来为自己捐款改善自己的生活环境，并继续维护 Facker.js, 但很多公司不鸟他，他只能删库来抱怨。要说呀，用这些库的人的人都是开发者，安装完你开发的库，然后就开开心心的写代码去了，除非不会用的库，不然没人去看你的 README 的。更何况你仓库边上的捐款信息。 ","date":"2022-01-14","objectID":"/2022/01/%E4%BE%9D%E6%97%A7%E5%85%8D%E8%B4%B9%E4%BD%BF%E7%94%A8docker-desktop%E7%9A%84%E6%96%B9%E6%A1%88/:1:0","tags":["Docker","收费","解决方案"],"title":"依旧免费使用 Docker Desktop 的方案","uri":"/2022/01/%E4%BE%9D%E6%97%A7%E5%85%8D%E8%B4%B9%E4%BD%BF%E7%94%A8docker-desktop%E7%9A%84%E6%96%B9%E6%A1%88/"},{"categories":["Tool"],"content":"问题 如果你现在下载最新的或者旧版的 Docker 安装包，安装包的使用条款都已经被悄悄的动了手脚，里面的 Liscense 的条款已经有了上面说的内容了。所以说你还是会被要求收费的。除非你在一个小公司，人数和收入不在条款之内，那你就开心的用吧。 但是还有一部分人就在这个条款的要求范围之内了。 安全无小事。 雪崩的时候，没有一片雪花是无辜的。 市面上还是有不少 Docker 的替代方案，比如 podman, lima 和 colima, 但用起来却没有 Docker 这么流畅，舒服。 ","date":"2022-01-14","objectID":"/2022/01/%E4%BE%9D%E6%97%A7%E5%85%8D%E8%B4%B9%E4%BD%BF%E7%94%A8docker-desktop%E7%9A%84%E6%96%B9%E6%A1%88/:2:0","tags":["Docker","收费","解决方案"],"title":"依旧免费使用 Docker Desktop 的方案","uri":"/2022/01/%E4%BE%9D%E6%97%A7%E5%85%8D%E8%B4%B9%E4%BD%BF%E7%94%A8docker-desktop%E7%9A%84%E6%96%B9%E6%A1%88/"},{"categories":["Tool"],"content":"解决方案 使用 2021 年 8 月 30 日之前的任何版本都是可以的，所以下载之前的旧版并且不升级就可以了。 ","date":"2022-01-14","objectID":"/2022/01/%E4%BE%9D%E6%97%A7%E5%85%8D%E8%B4%B9%E4%BD%BF%E7%94%A8docker-desktop%E7%9A%84%E6%96%B9%E6%A1%88/:3:0","tags":["Docker","收费","解决方案"],"title":"依旧免费使用 Docker Desktop 的方案","uri":"/2022/01/%E4%BE%9D%E6%97%A7%E5%85%8D%E8%B4%B9%E4%BD%BF%E7%94%A8docker-desktop%E7%9A%84%E6%96%B9%E6%A1%88/"},{"categories":["Tool"],"content":"安装旧版 Docker Desktop 我在百度网盘有备份 Mac 版 3.5.2 版本的 Docker Desktop 副本，可以下载安装。 链接：https://pan.baidu.com/s/1nmJezbYx8BmexK6eVXihtg 提取码：gedn 如果觉得慢，恰好我也有空，我可以将我本地的副本直接隔空给你。 ","date":"2022-01-14","objectID":"/2022/01/%E4%BE%9D%E6%97%A7%E5%85%8D%E8%B4%B9%E4%BD%BF%E7%94%A8docker-desktop%E7%9A%84%E6%96%B9%E6%A1%88/:3:1","tags":["Docker","收费","解决方案"],"title":"依旧免费使用 Docker Desktop 的方案","uri":"/2022/01/%E4%BE%9D%E6%97%A7%E5%85%8D%E8%B4%B9%E4%BD%BF%E7%94%A8docker-desktop%E7%9A%84%E6%96%B9%E6%A1%88/"},{"categories":["Tool"],"content":"验证安装的 Docker 副本的修改时间    ~/Downloads   19:54:48  ❯ ls -al /Applications/Docker.app/Contents/Resources/LICENSE.rtf /Applications/Docker.app/Contents/MacOS/Docker .rwxr-xr-x zhongren.gu admin 16 MB Thu Jul 8 01:58:59 2021  /Applications/Docker.app/Contents/MacOS/Docker .rw-r--r-- zhongren.gu admin 19 KB Thu Jul 8 01:59:00 2021  /Applications/Docker.app/Contents/Resources/LICENSE.rtf 可以看到，两个文件最后的修改时间是 2021 年 6 月 8 日，在 2021 年 8 月 30 日之前，所以是符合我们的要求的。 ","date":"2022-01-14","objectID":"/2022/01/%E4%BE%9D%E6%97%A7%E5%85%8D%E8%B4%B9%E4%BD%BF%E7%94%A8docker-desktop%E7%9A%84%E6%96%B9%E6%A1%88/:3:2","tags":["Docker","收费","解决方案"],"title":"依旧免费使用 Docker Desktop 的方案","uri":"/2022/01/%E4%BE%9D%E6%97%A7%E5%85%8D%E8%B4%B9%E4%BD%BF%E7%94%A8docker-desktop%E7%9A%84%E6%96%B9%E6%A1%88/"},{"categories":["Tool"],"content":"禁止 Docker 升级 安装完旧版的 Docker 之后，要禁止 Docker 升级，这样，Docker 的使用条款就永远是旧的，Docker 的律师也拿你没办法喽。 在这通过命令行修改 host 文件，使 desktop.docker.com 指向 127.0.0.1, 不然 Docker 升级服务访问真正的 Docker 服务器。 echo '127.0.0.1 desktop.docker.com' | sudo tee -a /etc/hosts ","date":"2022-01-14","objectID":"/2022/01/%E4%BE%9D%E6%97%A7%E5%85%8D%E8%B4%B9%E4%BD%BF%E7%94%A8docker-desktop%E7%9A%84%E6%96%B9%E6%A1%88/:3:3","tags":["Docker","收费","解决方案"],"title":"依旧免费使用 Docker Desktop 的方案","uri":"/2022/01/%E4%BE%9D%E6%97%A7%E5%85%8D%E8%B4%B9%E4%BD%BF%E7%94%A8docker-desktop%E7%9A%84%E6%96%B9%E6%A1%88/"},{"categories":["Tool"],"content":"验证未升级 ","date":"2022-01-14","objectID":"/2022/01/%E4%BE%9D%E6%97%A7%E5%85%8D%E8%B4%B9%E4%BD%BF%E7%94%A8docker-desktop%E7%9A%84%E6%96%B9%E6%A1%88/:3:4","tags":["Docker","收费","解决方案"],"title":"依旧免费使用 Docker Desktop 的方案","uri":"/2022/01/%E4%BE%9D%E6%97%A7%E5%85%8D%E8%B4%B9%E4%BD%BF%E7%94%A8docker-desktop%E7%9A%84%E6%96%B9%E6%A1%88/"},{"categories":["Tool"],"content":"Refs 博客：https://guzhongren.github.io/ ","date":"2022-01-14","objectID":"/2022/01/%E4%BE%9D%E6%97%A7%E5%85%8D%E8%B4%B9%E4%BD%BF%E7%94%A8docker-desktop%E7%9A%84%E6%96%B9%E6%A1%88/:4:0","tags":["Docker","收费","解决方案"],"title":"依旧免费使用 Docker Desktop 的方案","uri":"/2022/01/%E4%BE%9D%E6%97%A7%E5%85%8D%E8%B4%B9%E4%BD%BF%E7%94%A8docker-desktop%E7%9A%84%E6%96%B9%E6%A1%88/"},{"categories":["Tool"],"content":"Disclaimer 本文仅代表个人观点，与 Thoughtworks 公司无任何关系。 SHA256 checksum: f2fe1394e4ab9297ed69ff73ac32e9ac1375f01c2102183b509bf9379a5995d6 ","date":"2022-01-14","objectID":"/2022/01/%E4%BE%9D%E6%97%A7%E5%85%8D%E8%B4%B9%E4%BD%BF%E7%94%A8docker-desktop%E7%9A%84%E6%96%B9%E6%A1%88/:5:0","tags":["Docker","收费","解决方案"],"title":"依旧免费使用 Docker Desktop 的方案","uri":"/2022/01/%E4%BE%9D%E6%97%A7%E5%85%8D%E8%B4%B9%E4%BD%BF%E7%94%A8docker-desktop%E7%9A%84%E6%96%B9%E6%A1%88/"},{"categories":["Tool"],"content":"赞助 SHA256 checksum: 964978ecd2059064abe542e51dc02e204d3ee2e6c320ca68e2b1399ce0c6953c 使用此 文件 进行校验： gpg --verify PayForGuzhongren.svg.sig ","date":"2022-01-14","objectID":"/2022/01/%E4%BE%9D%E6%97%A7%E5%85%8D%E8%B4%B9%E4%BD%BF%E7%94%A8docker-desktop%E7%9A%84%E6%96%B9%E6%A1%88/:6:0","tags":["Docker","收费","解决方案"],"title":"依旧免费使用 Docker Desktop 的方案","uri":"/2022/01/%E4%BE%9D%E6%97%A7%E5%85%8D%E8%B4%B9%E4%BD%BF%E7%94%A8docker-desktop%E7%9A%84%E6%96%B9%E6%A1%88/"},{"categories":["Performance"],"content":"遇到的问题 22 年又开始了，西安 ZF 的防疫政策真的是在全国人民面前一遍又一遍的刷出了新的高度，过了魔幻的 2020，又过了艰难的 2021，2022，感觉你都找不到个合适的词来形容了。 最近西安大数据局搞得二维码已经连续崩溃两次了，更可笑的是自吹自擂的说把 1M 的图片优化到 500kB, 又艰难的优化到 100KB, 真的是艰难的不行，难道用 base64 算法搞成字符串会超过 10kB 么？还有把对外的图片放在了自己的服务器上，没有用到 CDN, 简直了，更何况是自己 host 的图片。一个字：简直了。 最近在优化我们组自己构建的开源项目 Powerboard 的使用体验。经过一遍遍的优化，我们现在的策略是将 token 和 config 放在 URL 中，config 是存储配置的 URL。目前，我们将 config 存放在 GitHub 的 Gist 上。 但是这有个问题，就是 Gist 的访问在国内被墙了，被🧱了，被🧱了；而且 GitHub 的资源访问也比较慢。 ","date":"2022-01-05","objectID":"/2022/01/%E4%BD%BF%E7%94%A8jsdelivr%E6%9D%A5%E5%8A%A0%E9%80%9Fgithub%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE/:1:0","tags":["jsdelivr","GitHub","Proxy",""],"title":"使用 jsdelivr 来加速 Github 资源访问","uri":"/2022/01/%E4%BD%BF%E7%94%A8jsdelivr%E6%9D%A5%E5%8A%A0%E9%80%9Fgithub%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE/"},{"categories":["Performance"],"content":"前置知识 内容分发网络（英语：Content Delivery Network 或 Content Distribution Network，缩写：CDN）是指一种透过互联网互相连接的电脑网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、视频、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。 —- wikipedia ","date":"2022-01-05","objectID":"/2022/01/%E4%BD%BF%E7%94%A8jsdelivr%E6%9D%A5%E5%8A%A0%E9%80%9Fgithub%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE/:2:0","tags":["jsdelivr","GitHub","Proxy",""],"title":"使用 jsdelivr 来加速 Github 资源访问","uri":"/2022/01/%E4%BD%BF%E7%94%A8jsdelivr%E6%9D%A5%E5%8A%A0%E9%80%9Fgithub%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE/"},{"categories":["Performance"],"content":"解决方案 之前想过提高 GitHub 资源的下载速度，了解过各种 GitHub 资源的 Proxy。比如 https://hub.fastgit.org https://github.com.cnpmjs.org 本地配置代理等 对于hub.fastgit.org, 在将 raw 资源地址配置到 URL 中后并不能直接获取到配置信息，存在跨域的问题。对此还有一个开源的代理方案，那就是jsdelivr。 ","date":"2022-01-05","objectID":"/2022/01/%E4%BD%BF%E7%94%A8jsdelivr%E6%9D%A5%E5%8A%A0%E9%80%9Fgithub%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE/:3:0","tags":["jsdelivr","GitHub","Proxy",""],"title":"使用 jsdelivr 来加速 Github 资源访问","uri":"/2022/01/%E4%BD%BF%E7%94%A8jsdelivr%E6%9D%A5%E5%8A%A0%E9%80%9Fgithub%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE/"},{"categories":["Performance"],"content":"jsdelivr jsdelivr 是为 npm, GitHub, JavaScript 和 ESM 加速构建的免费，快速，可靠的开源 CDN。此开源项目是 prospectone 公司开源的一个项目，而 prospectone 是在 CDN 方面也是很有经验的技术公司。 从其官网可以看到，jsdelivr CDN 遍布世界，在中国也有很多，更友好的是，在西安也有一个。 模式 https://cdn.staticaly.com/gh/{usernameOrOrgName}/{repoName@version}/{filePath} usernameOrOrgName: GitHub 用户名或者组织名 repoName: 存储文件的仓库名 @version: Release 版本号；如果不填写使用最新版 filePath: 存储在 GitHub 仓库上的相对路径 实现 创建组织的团队配置仓库，并写入要配置的内容，commit 并 push。 按照上面 jsdelivr 的模式配置路径，效果如下： https://cdn.staticaly.com/gh/guzhongren/Buildkite-Dashboard/cypress.json ","date":"2022-01-05","objectID":"/2022/01/%E4%BD%BF%E7%94%A8jsdelivr%E6%9D%A5%E5%8A%A0%E9%80%9Fgithub%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE/:3:1","tags":["jsdelivr","GitHub","Proxy",""],"title":"使用 jsdelivr 来加速 Github 资源访问","uri":"/2022/01/%E4%BD%BF%E7%94%A8jsdelivr%E6%9D%A5%E5%8A%A0%E9%80%9Fgithub%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE/"},{"categories":["Performance"],"content":"总结 CDN 是加速资源加载的有效方法，虽然我们没有能力去构建一个自己的 CDN, 但可以利用现有方案去解决自己的问题。只是需要扩大自己的眼界和提升自己的认知即可。 ","date":"2022-01-05","objectID":"/2022/01/%E4%BD%BF%E7%94%A8jsdelivr%E6%9D%A5%E5%8A%A0%E9%80%9Fgithub%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE/:4:0","tags":["jsdelivr","GitHub","Proxy",""],"title":"使用 jsdelivr 来加速 Github 资源访问","uri":"/2022/01/%E4%BD%BF%E7%94%A8jsdelivr%E6%9D%A5%E5%8A%A0%E9%80%9Fgithub%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE/"},{"categories":["Performance"],"content":"Refs 博客：https://guzhongren.github.io/ jsdelvr:https://www.jsdelivr.com/ prospectone: https://prospectone.io/ CDN: https://zh.wikipedia.org/wiki/%E5%85%A7%E5%AE%B9%E5%82%B3%E9%81%9E%E7%B6%B2%E8%B7%AF ","date":"2022-01-05","objectID":"/2022/01/%E4%BD%BF%E7%94%A8jsdelivr%E6%9D%A5%E5%8A%A0%E9%80%9Fgithub%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE/:5:0","tags":["jsdelivr","GitHub","Proxy",""],"title":"使用 jsdelivr 来加速 Github 资源访问","uri":"/2022/01/%E4%BD%BF%E7%94%A8jsdelivr%E6%9D%A5%E5%8A%A0%E9%80%9Fgithub%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE/"},{"categories":["Performance"],"content":"Disclaimer 本文仅代表个人观点，与 Thoughtworks 公司无任何关系。 SHA256 checksum: f2fe1394e4ab9297ed69ff73ac32e9ac1375f01c2102183b509bf9379a5995d6 ","date":"2022-01-05","objectID":"/2022/01/%E4%BD%BF%E7%94%A8jsdelivr%E6%9D%A5%E5%8A%A0%E9%80%9Fgithub%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE/:6:0","tags":["jsdelivr","GitHub","Proxy",""],"title":"使用 jsdelivr 来加速 Github 资源访问","uri":"/2022/01/%E4%BD%BF%E7%94%A8jsdelivr%E6%9D%A5%E5%8A%A0%E9%80%9Fgithub%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE/"},{"categories":["Performance"],"content":"赞助 SHA256 checksum: 964978ecd2059064abe542e51dc02e204d3ee2e6c320ca68e2b1399ce0c6953c 使用此 文件 进行校验： gpg --verify PayForGuzhongren.svg.sig ","date":"2022-01-05","objectID":"/2022/01/%E4%BD%BF%E7%94%A8jsdelivr%E6%9D%A5%E5%8A%A0%E9%80%9Fgithub%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE/:7:0","tags":["jsdelivr","GitHub","Proxy",""],"title":"使用 jsdelivr 来加速 Github 资源访问","uri":"/2022/01/%E4%BD%BF%E7%94%A8jsdelivr%E6%9D%A5%E5%8A%A0%E9%80%9Fgithub%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE/"},{"categories":["agile"],"content":"场景 最近西安疫情比较严重，不到一个月已经近 200 例了，而我也被确诊病例轨迹重重包围了；疫情刚开始我司就决定让大家居家办公，一直到现在；居家办公已经不是第一次了，但是在居家办公这个过程中，每个人都会遇到这样或者那样的事，今天就来说说，工作的常态就是被打断，以及如何有效的解决被打断这个问题。 早上，打开电脑，兴致勃勃的输入电脑密码，开始工作，文档和代码写的正酣，突然来了一个电话，电话那头劈头盖脸的来说你做一下这个那个，没有任何上下文，一个字就是“跟着我说的干“, 然而电话挂了，你也懵逼了，隐隐约约只记下了几个关键点。然而，看到自己的工作，始终想不起自己接下来要搞什么了。“丢了夫人又折兵”的真实写照啊。😇 在工作中不光光是被电话打断，更多的可能是别人突然来找你问问题或者打个招呼；场景各有各的不同，但结果都一样。 ","date":"2021-12-25","objectID":"/2021/12/%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%B8%B8%E6%80%81%E6%98%AF%E8%A2%AB%E6%89%93%E6%96%AD/:1:0","tags":["远程","Work from home","WFH","Task"],"title":"工作的常态是被打断","uri":"/2021/12/%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%B8%B8%E6%80%81%E6%98%AF%E8%A2%AB%E6%89%93%E6%96%AD/"},{"categories":["agile"],"content":"解决方案 在工作中不光光是被电话打断，更多的可能是别人突然来找你问问题或者打个招呼；场景各有各的不同，但结果都一样。 对于这类问题，可以有如下解决方案： ","date":"2021-12-25","objectID":"/2021/12/%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%B8%B8%E6%80%81%E6%98%AF%E8%A2%AB%E6%89%93%E6%96%AD/:2:0","tags":["远程","Work from home","WFH","Task"],"title":"工作的常态是被打断","uri":"/2021/12/%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%B8%B8%E6%80%81%E6%98%AF%E8%A2%AB%E6%89%93%E6%96%AD/"},{"categories":["agile"],"content":"Task 分而治之，此方法适用于在工作之前就将工作拆解，待所有的子任务完成后就可以完成整个功能，Task 可以记录在所做的卡上，或者写在某个 App 上，比如 Conflunence 或者 Trello 上都有 Tasklist 功能，很方便记录📝, 大致结构如下： - [x] subTask1 - [ ] subTask2 - [ ] subTask3 ","date":"2021-12-25","objectID":"/2021/12/%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%B8%B8%E6%80%81%E6%98%AF%E8%A2%AB%E6%89%93%E6%96%AD/:2:1","tags":["远程","Work from home","WFH","Task"],"title":"工作的常态是被打断","uri":"/2021/12/%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%B8%B8%E6%80%81%E6%98%AF%E8%A2%AB%E6%89%93%E6%96%AD/"},{"categories":["agile"],"content":"ToDo 如果没有地方记录，那么就可以找些 App 来记录，我常用的是 Microsoft-ToDo, 对于工作之外的事务，我都是列在上面；当完成一个小功能就点一下对应的子任务，直到所有的子功能完成，那么大目标也就完成了。 ","date":"2021-12-25","objectID":"/2021/12/%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%B8%B8%E6%80%81%E6%98%AF%E8%A2%AB%E6%89%93%E6%96%AD/:2:2","tags":["远程","Work from home","WFH","Task"],"title":"工作的常态是被打断","uri":"/2021/12/%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%B8%B8%E6%80%81%E6%98%AF%E8%A2%AB%E6%89%93%E6%96%AD/"},{"categories":["agile"],"content":"实践 万事都有章法。分析系统有 C4 Model 等，做事可以 分而治之。 当有人打电话或者突然来找你的时候，先来一句 “稍等”, 然后默默写下自己的 ToDo/Task 或者确认一下自己的 Task 已勾选，等到接完电话或者聊完天，只要瞅一眼 Todo 或者 Task 就又可以愉快的开始了。 ","date":"2021-12-25","objectID":"/2021/12/%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%B8%B8%E6%80%81%E6%98%AF%E8%A2%AB%E6%89%93%E6%96%AD/:3:0","tags":["远程","Work from home","WFH","Task"],"title":"工作的常态是被打断","uri":"/2021/12/%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%B8%B8%E6%80%81%E6%98%AF%E8%A2%AB%E6%89%93%E6%96%AD/"},{"categories":["agile"],"content":"Refs 博客：https://guzhongren.github.io/ ","date":"2021-12-25","objectID":"/2021/12/%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%B8%B8%E6%80%81%E6%98%AF%E8%A2%AB%E6%89%93%E6%96%AD/:4:0","tags":["远程","Work from home","WFH","Task"],"title":"工作的常态是被打断","uri":"/2021/12/%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%B8%B8%E6%80%81%E6%98%AF%E8%A2%AB%E6%89%93%E6%96%AD/"},{"categories":["agile"],"content":"Disclaimer 本文仅代表个人观点，与 Thoughtworks 公司无任何关系。 SHA256 checksum: f2fe1394e4ab9297ed69ff73ac32e9ac1375f01c2102183b509bf9379a5995d6 ","date":"2021-12-25","objectID":"/2021/12/%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%B8%B8%E6%80%81%E6%98%AF%E8%A2%AB%E6%89%93%E6%96%AD/:5:0","tags":["远程","Work from home","WFH","Task"],"title":"工作的常态是被打断","uri":"/2021/12/%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%B8%B8%E6%80%81%E6%98%AF%E8%A2%AB%E6%89%93%E6%96%AD/"},{"categories":["agile"],"content":"赞助 SHA256 checksum: 964978ecd2059064abe542e51dc02e204d3ee2e6c320ca68e2b1399ce0c6953c 使用此 文件 进行校验： gpg --verify PayForGuzhongren.svg.sig ","date":"2021-12-25","objectID":"/2021/12/%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%B8%B8%E6%80%81%E6%98%AF%E8%A2%AB%E6%89%93%E6%96%AD/:6:0","tags":["远程","Work from home","WFH","Task"],"title":"工作的常态是被打断","uri":"/2021/12/%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%B8%B8%E6%80%81%E6%98%AF%E8%A2%AB%E6%89%93%E6%96%AD/"},{"categories":["Web"],"content":"借助 Accept-Encoding/Content-Encoding 优化网络请求","date":"2021-10-20","objectID":"/2021/10/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-accept-encoding/","tags":["Performance","GZIP","Accept-Encoding"],"title":"性能优化 Accept-Encoding","uri":"/2021/10/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-accept-encoding/"},{"categories":["Web"],"content":"以前的网页请求 ","date":"2021-10-20","objectID":"/2021/10/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-accept-encoding/:1:0","tags":["Performance","GZIP","Accept-Encoding"],"title":"性能优化 Accept-Encoding","uri":"/2021/10/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-accept-encoding/"},{"categories":["Web"],"content":"人类总是在追求快，更快 随着带宽和基础设施的快速发展，网页显示速度也有迫切需求，随之，就出现了各种各样加速显示网页的技术。 HTTP compression HTTP compression is a capability that can be built into web servers and web clients to improve transfer speed and bandwidth utilization. –wikipedia Content Negotiation In HTTP, content negotiation is the mechanism that is used for serving different representations of a resource to the same URI to help the user agent specify which representation is best suited for the user (for example, which document language, which image format, or which content encoding). 在 HTTP 协议中，内容协商是这样一种机制，通过为同一 URI 指向的资源提供不同的展现形式，可以使用户代理选择与用户需求相适应的最佳匹配（例如，文档使用的自然语言，图片的格式，或者内容编码形式）。 ","date":"2021-10-20","objectID":"/2021/10/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-accept-encoding/:2:0","tags":["Performance","GZIP","Accept-Encoding"],"title":"性能优化 Accept-Encoding","uri":"/2021/10/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-accept-encoding/"},{"categories":["Web"],"content":"内容协商的基本原则 一份特定的文件称为一项资源。当客户端获取资源的时候，会使用其对应的 URL 发送请求。服务器通过这个 URL 来选择它指向的资源的某一变体——每一个变体称为一种展现形式——然后将这个选定的展现形式返回给客户端。整个资源，连同它的各种展现形式，共享一个特定的 URL 。当一项资源被访问的时候，特定展现形式的选取是通过内容协商机制来决定的，并且客户端和服务器端之间存在多种协商方式。 ","date":"2021-10-20","objectID":"/2021/10/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-accept-encoding/:3:0","tags":["Performance","GZIP","Accept-Encoding"],"title":"性能优化 Accept-Encoding","uri":"/2021/10/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-accept-encoding/"},{"categories":["Web"],"content":"内容协商类别 随着时间的推移，也有其他一些内容协商的提案被提出来，比如透明内容协商以及 Alternates 首部。但是它们都没有获得人们的认可从而被遗弃。 ","date":"2021-10-20","objectID":"/2021/10/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-accept-encoding/:3:1","tags":["Performance","GZIP","Accept-Encoding"],"title":"性能优化 Accept-Encoding","uri":"/2021/10/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-accept-encoding/"},{"categories":["Web"],"content":"服务端驱动型内容协商机制流程 当客户端携带消息头（header）发送请求给服务端后，服务端使用消息头里的指定的可接受的压缩方式，自己通过内部特定的算法，找出最佳的压缩方案，然后将数据压缩并返回给客户端。 用于启动服务端驱动型内容协商标准消息头 这些消息头都是可以带有 Q 因子的清单；比如 Item Example Note Accept 在获取 HTML 页面、图片文件、视频文件或者是脚本文件的时候，无论是通过在地址栏中输入资源地址来获取还是通过\u003cimg\u003e、\u003cvideo\u003e 或 \u003caudio\u003e 元素引用都是不一样的。浏览器可以自由使用它们认为最为合适的首部值； Accept-Charset ISO-8859-1,utf-8;q=0.7,*;q=0.7 如今 UTF-8 编码已经得到了广泛的支持，成为首选的字符编码类型，为了通过减少基于配置信息的信息熵来更好地保护隐私信息， 大多数浏览器会将 Accept-Charset 首部移除：Internet Explorer 8、Safari 5、Opera 11 以及 Firefox 10 都已经不再发送该首部。 Accept-Encoding br, gzip;q=0.8 将 HTTP 消息进行压缩是一种最重要的提升 Web 站点性能的方法。该方法会减小所要传输的数据量的大小，节省可用带宽。浏览器总是会发送该首部，服务器则应该配置为接受它，并且采用一定的压缩方案。 Accept-Language de, en;q=0.7 用户代理的图形界面上所采用的语言通常可以用来设置为默认值，但是大多数浏览器允许设置不同优先级的语言选项。 某些情况下，服务器会使用 Vary 消息头来说明实际上哪些消息头被用作内容协商的参考依据（确切来说是与之相关的响应消息头），这样可以使 缓存 的运作更有效。 Vary 响应首部 前面列举的 Accept-* 形式的首部都是由客户端 (Web Client) 给服务端的，Vary 首部是由服务器在响应 (Response) 中发送的。它标示了服务器在服务端驱动型内容协商阶段所使用的首部清单。这个首部是必要的，它是可以用来通知缓存服务器决策的依据，这样它可以进行复现，使得缓存服务器在预防将错误内容提供给用户方面发挥作用。 Vary 如果 Response 中 Vary 的值是’*’， 那么意味着在服务端驱动型内容协商过程中同时采纳了未在首部中传递的信息来选择合适的内容。 并且 Vary 的值是区分大消息的。 ","date":"2021-10-20","objectID":"/2021/10/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-accept-encoding/:3:2","tags":["Performance","GZIP","Accept-Encoding"],"title":"性能优化 Accept-Encoding","uri":"/2021/10/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-accept-encoding/"},{"categories":["Web"],"content":"代理驱动型内容协商机制 服务端驱动型内容协商机制由于一些缺点而为人诟病——它在规模化方面存在问题。在协商机制中，每一个特性需要对应一个首部。如果想要使用屏幕大小、分辨率或者其他方面的特性，就需要创建一个新的首部。而且在每一次请求中都必须发送这些首部。在首部很少的时候，这并不是问题，但是随着数量的增多，消息体的体积会导致性能的下降。带有精确信息的首部发送的越多，信息熵就会越大，也就准许了更多 HTTP 指纹识别行为，以及与此相关的隐私问题的发生。 从 HTTP 协议制定之初，该协议就准许另外一种协商机制：代理驱动型内容协商机制，或称为响应式协商机制。在这种协商机制中，当面临不明确的请求时，服务器会返回一个页面，其中包含了可供选择的资源的链接。资源呈现给用户，由用户做出选择。 不幸的是，HTTP 标准没有明确指定提供可选资源链接的页面的格式，这一点阻碍了将这一过程无痛自动化。除了退回至服务端驱动型内容协商机制外，这种自动化方法几乎无一例外都是通过脚本技术来完成的，尤其是 JavaScript 重定向技术：在检测了协商的条件之后，脚本会触发重定向动作。另外一个问题是，为了获得实际的资源，需要额外发送一次请求，减慢了将资源呈现给用户的速度。 ","date":"2021-10-20","objectID":"/2021/10/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-accept-encoding/:3:3","tags":["Performance","GZIP","Accept-Encoding"],"title":"性能优化 Accept-Encoding","uri":"/2021/10/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-accept-encoding/"},{"categories":["Web"],"content":"Accept-Encoding HTTP Request Header 中的 Accept-Encoding 会将客户端（e.g. 浏览器）能够理解的内容编码方式（通常是某种压缩算法）通知给服务端。通过内容协商的方式，服务端会选择一个客户端提议的方式，使用并在响应头 Content-Encoding 中通知客户端该选择。 ","date":"2021-10-20","objectID":"/2021/10/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-accept-encoding/:4:0","tags":["Performance","GZIP","Accept-Encoding"],"title":"性能优化 Accept-Encoding","uri":"/2021/10/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-accept-encoding/"},{"categories":["Web"],"content":"压缩的好处 http 压缩对纯文本可以压缩至原内容的 40%, 从而节省了 60%的数据传输。 实例：访问我的博客网站，可以看到是进过 gzip 压缩的，原始大小为 34kB, 经过压缩后为 7.3kB，只有原先的 21%，在带宽上有很大的性能提升。 文件大小 gzip 压缩 ","date":"2021-10-20","objectID":"/2021/10/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-accept-encoding/:4:1","tags":["Performance","GZIP","Accept-Encoding"],"title":"性能优化 Accept-Encoding","uri":"/2021/10/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-accept-encoding/"},{"categories":["Web"],"content":"Gzip 的缺点 JPEG 这类文件用 gzip 压缩的不够好。 ","date":"2021-10-20","objectID":"/2021/10/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-accept-encoding/:4:2","tags":["Performance","GZIP","Accept-Encoding"],"title":"性能优化 Accept-Encoding","uri":"/2021/10/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-accept-encoding/"},{"categories":["Web"],"content":"Gzip 是如何压缩的 简单来说， Gzip 压缩是在一个文本文件中找出类似的字符串， 并临时替换他们，使整个文件变小。这种形式的压缩对 Web 来说非常适合， 因为 HTML 和 CSS 文件通常包含大量的重复的字符串，例如空格，标签。 ","date":"2021-10-20","objectID":"/2021/10/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-accept-encoding/:4:3","tags":["Performance","GZIP","Accept-Encoding"],"title":"性能优化 Accept-Encoding","uri":"/2021/10/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-accept-encoding/"},{"categories":["Web"],"content":"语法 Accept-Encoding: gzip Accept-Encoding: compress Accept-Encoding: deflate Accept-Encoding: br Accept-Encoding: identity Accept-Encoding: * // Multiple algorithms, weighted with the quality value syntax: Accept-Encoding: deflate, gzip;q=1.0, *;q=0.5 Accept-Encoding type Note gzip 表示采用 Lempel-Ziv coding (LZ77) 压缩算法，以及 32 位 CRC 校验的编码方式。gzip 是 GNU zip 的缩写，是 GNU 自由软件的文件压缩程序，也用来表示 gzip 文件格式。浏览器支持的比较好。 compress 采用 Lempel-Ziv-Welch (LZW) 压缩算法。 deflate 采用 zlib 结构和 deflate 压缩算法。使用 LZ77 算法于哈夫曼编码（Huffman Coding）的一种无损压缩算法 br 表示采用 Brotli 算法的编码方式。 identity 用于指代自身（例如：未经过压缩和修改）。除非特别指明，这个标记始终可以被接受。 * 匹配其他任意未在该请求头字段中列出的编码方式。假如该请求头字段不存在的话，这个值是默认值。它并不代表任意算法都支持，而仅仅表示算法之间无优先次序。 ;q= （权重系数） 值代表优先顺序，用相对 权重系数 表示，又称为质量价值。 ","date":"2021-10-20","objectID":"/2021/10/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-accept-encoding/:4:4","tags":["Performance","GZIP","Accept-Encoding"],"title":"性能优化 Accept-Encoding","uri":"/2021/10/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-accept-encoding/"},{"categories":["Web"],"content":"示例 Accept-Encoding: gzip Accept-Encoding: gzip, compress, br Accept-Encoding: br;q=1.0, gzip;q=0.8, *;q=0.1 ","date":"2021-10-20","objectID":"/2021/10/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-accept-encoding/:4:5","tags":["Performance","GZIP","Accept-Encoding"],"title":"性能优化 Accept-Encoding","uri":"/2021/10/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-accept-encoding/"},{"categories":["Web"],"content":"浏览器兼容性 ","date":"2021-10-20","objectID":"/2021/10/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-accept-encoding/:4:6","tags":["Performance","GZIP","Accept-Encoding"],"title":"性能优化 Accept-Encoding","uri":"/2021/10/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-accept-encoding/"},{"categories":["Web"],"content":"最佳实践 对于 Accept-Encoding, 这个除了是后端请求，其他的只能由浏览器来自行设定，建议使用最新的浏览器即可。 对于 content-encoding 这个 header 只能由服务器来指定。针对不同的环境如 Nginx, Apache Tomcat 和 IIS 等，都有不同的配置，这里以 Nginx 为例，在 Nginx 的 *.conf 文件中加入如下代码即可。 [root@linux /]# vim /usr/local/nginx/conf.d/www.conf server { listen 80; server_name www.endvv.com endvv.com; root html/bk; index index.php index.html; access_log /usr/local/nginx/logs/www.log ; include /usr/local/nginx/php/www.conf; include /usr/local/nginx/wjt/typecho.conf; + gzip on; + gzip_buffers 4 16k; + gzip_comp_level 6; + gzip_vary on; + gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript; } ","date":"2021-10-20","objectID":"/2021/10/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-accept-encoding/:5:0","tags":["Performance","GZIP","Accept-Encoding"],"title":"性能优化 Accept-Encoding","uri":"/2021/10/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-accept-encoding/"},{"categories":["Web"],"content":"Refs 博客：https://guzhongren.github.io/ HTTP compression ","date":"2021-10-20","objectID":"/2021/10/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-accept-encoding/:6:0","tags":["Performance","GZIP","Accept-Encoding"],"title":"性能优化 Accept-Encoding","uri":"/2021/10/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-accept-encoding/"},{"categories":["Web"],"content":"Disclaimer 本文仅代表个人观点，与 Thoughtworks 公司无任何关系。 SHA256 checksum: f2fe1394e4ab9297ed69ff73ac32e9ac1375f01c2102183b509bf9379a5995d6 ","date":"2021-10-20","objectID":"/2021/10/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-accept-encoding/:7:0","tags":["Performance","GZIP","Accept-Encoding"],"title":"性能优化 Accept-Encoding","uri":"/2021/10/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-accept-encoding/"},{"categories":["Web"],"content":"赞助 SHA256 checksum: 964978ecd2059064abe542e51dc02e204d3ee2e6c320ca68e2b1399ce0c6953c 使用此 文件 进行校验： gpg --verify PayForGuzhongren.svg.sig ","date":"2021-10-20","objectID":"/2021/10/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-accept-encoding/:8:0","tags":["Performance","GZIP","Accept-Encoding"],"title":"性能优化 Accept-Encoding","uri":"/2021/10/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-accept-encoding/"},{"categories":["DevOps"],"content":"Container Image Scanner","date":"2021-10-11","objectID":"/2021/10/container-image-scanner-trivy/","tags":["Trivy","DevOps","Pipeline"],"title":"Container Image Scanner - Trivy","uri":"/2021/10/container-image-scanner-trivy/"},{"categories":["DevOps"],"content":"Abstract In modern software development, we leverage public images as base images to build up applications images quickly and deploy them into the production environment. With more and more applications containerized, container security is also becoming more important. To use vulnerability scanners, we can bring forward the security feedback cycle which is traditionally done towards the end. This aligns closely with our belief that by adopting agile, we will be able to get faster feedback. This is what we are doing in order to achieve it. ","date":"2021-10-11","objectID":"/2021/10/container-image-scanner-trivy/:1:0","tags":["Trivy","DevOps","Pipeline"],"title":"Container Image Scanner - Trivy","uri":"/2021/10/container-image-scanner-trivy/"},{"categories":["DevOps"],"content":"Pain points on application environment security Now, we use advanced technology to build up our application, like NodeJS, Java and so on, then store the code repository on git platforms like GitHub, Gitlab and so on. Code repository consists of our code and dependencies; For dependencies, we can use tools to ensure security like npm audit of NodeJS, and Dependabot of GitHub; And for our business code, there is another security tool to scan, like SoneQube. So, for the dependencies and our business code, those things are under our control, we can ensure the application’s security and get fast feedback and build confidence by using all kinds of tools before we deploy our application into the production environment. As you know, the basic system environment which our application runs is out of our control. Let’s consider from the opposite side, if we can’t ensure the security of our application and its system environment, it will lead to unexpected problems, like hackers attack, leakage of user information, property loss, what’s more, cause damage to the reputation of the company. So, it is important to ensure the security of our product. ","date":"2021-10-11","objectID":"/2021/10/container-image-scanner-trivy/:2:0","tags":["Trivy","DevOps","Pipeline"],"title":"Container Image Scanner - Trivy","uri":"/2021/10/container-image-scanner-trivy/"},{"categories":["DevOps"],"content":"The value of keeping container image secure ","date":"2021-10-11","objectID":"/2021/10/container-image-scanner-trivy/:3:0","tags":["Trivy","DevOps","Pipeline"],"title":"Container Image Scanner - Trivy","uri":"/2021/10/container-image-scanner-trivy/"},{"categories":["DevOps"],"content":"Protect the client’s property and reputation We supply professional services for our client, so we must ensure every line of code is reliable and secure. Because code is property and reputation. For ourselves, just ensure the security of code, and the environment of application, the client can achieve the maximum benefit. ","date":"2021-10-11","objectID":"/2021/10/container-image-scanner-trivy/:3:1","tags":["Trivy","DevOps","Pipeline"],"title":"Container Image Scanner - Trivy","uri":"/2021/10/container-image-scanner-trivy/"},{"categories":["DevOps"],"content":"Build our respected brand The work we do is to make our clients succeed. Only if our customers succeed, we can succeed. So, we did not only archive business value, but also protect the security of the product. ","date":"2021-10-11","objectID":"/2021/10/container-image-scanner-trivy/:3:2","tags":["Trivy","DevOps","Pipeline"],"title":"Container Image Scanner - Trivy","uri":"/2021/10/container-image-scanner-trivy/"},{"categories":["DevOps"],"content":"Best 2 solutions to keep container images secure ","date":"2021-10-11","objectID":"/2021/10/container-image-scanner-trivy/:4:0","tags":["Trivy","DevOps","Pipeline"],"title":"Container Image Scanner - Trivy","uri":"/2021/10/container-image-scanner-trivy/"},{"categories":["DevOps"],"content":"Solution 1: Scan the image at a regular time in the image registry In this way, we need to add a security scanner for the images’ registry. The scanner might be a cron job or an operable step that can be triggered by the operator. It will be automatically triggered by a cron job when a special time. For example, docker hub scans their official registry at a special time, it will send an alert to the organizer when there are any vulnerabilities. ","date":"2021-10-11","objectID":"/2021/10/container-image-scanner-trivy/:4:1","tags":["Trivy","DevOps","Pipeline"],"title":"Container Image Scanner - Trivy","uri":"/2021/10/container-image-scanner-trivy/"},{"categories":["DevOps"],"content":"Solution 2: Integrate the scanner within your CI/CD pipeline In another way, we can scan the image product in the pipeline, it is more simple and efficient. The pipeline will automatically execute the command that scans the image when we push code to the code repository. Because the pipeline scans the product mechanically for every time, so we can find any security problem and fix it in time. Now, more and more teams or groups use agile to develop their projects. If we can find any vulnerabilities as early as possible, we can reduce the risk of the product before the product is published. The pipeline is a good tool to ensure the security of your product every line of code because it can automatically execute when you commit your code. ","date":"2021-10-11","objectID":"/2021/10/container-image-scanner-trivy/:4:2","tags":["Trivy","DevOps","Pipeline"],"title":"Container Image Scanner - Trivy","uri":"/2021/10/container-image-scanner-trivy/"},{"categories":["DevOps"],"content":"Container image scanner comparison For the above solution, we surveyed several scanner tools, like Trivy,Claire, Anchore Engine, Quay,Docker Hub and GCR. We made a comparison from different dimensions. Scanner OS packages Application dependencies Easy to use Accuracy Suitable for CI Suitable for Solution Trivy ✅ ✅ ⭐ ⭐ ⭐ ⭐ ⭐ ⭐ ⭐ ⭐ ⭐ 2 Clair ✅ ❌ ⭐ ⭐ ⭐ ⭐ ⭐ 2 Anchore Engine ✅ ✅ ⭐ ⭐ ⭐ ⭐ ⭐ ⭐ ⭐ 2 Quay ✅ ❌ ⭐ ⭐ ⭐ ⭐ ⭐ ❌ 1 Docker Hub ✅ ❌ ⭐⭐⭐ ⭐ ❌ 1 GCR ✅ ❌ ⭐ ⭐ ⭐ ⭐ ⭐ ❌ 1 Firstly we can separate those scanners into 2 parts suitable for solution, the Trivy, Clair, Anchore Engine, and Quay are suitable for solution, the others are suitable for solution 1. For the first dimension: OS package, those scanners can do it, but for the second dimension: Application dependence, just only Trivy and Anchore engine can do it, and for the fifth dimension is it suitable for ci; only the first three left. For the Trivy, Clair, and Anchore Engine, the communities of these three are very active, so we could not care about anyone to solve your issues; And as a tool, it must be easy to use and there is good documentation to reference. The documentation of Trivy is very detailed and very friendly. But for the vulnerability database, Clair ingests vulnerability metadata at regular intervals from a configured set of sources and stores the data in its database. Trivy and Anchore Engine will download the latest vulnerability metadata and cache it in a local file, it will check the update to keep the metadata latest when the tool runs again. At the same time, the usage of Trivy is more friendly, because we can filter the different severity which you can specify, but it is not allowed for Anchore Engine. March 16, 2020, Aqua Security, the leading platform provider for securing cloud-native applications and infrastructure, announced today that its open-source Trivy vulnerability scanner is being added as an integrated option in widely used cloud-native platforms, CNCF’s Harbor registry and Mirantis Docker Enterprise. You can find this post here. ","date":"2021-10-11","objectID":"/2021/10/container-image-scanner-trivy/:5:0","tags":["Trivy","DevOps","Pipeline"],"title":"Container Image Scanner - Trivy","uri":"/2021/10/container-image-scanner-trivy/"},{"categories":["DevOps"],"content":"Trivy in Thoughtworks Technology radar volume 23 Thoughtworks Technology Radar is famous for accurately responding to technological trends; In the latest technology radar, Thoughtworks put the Trivy into the adopt area, which means Trivy is useful, valuable and practicable. ","date":"2021-10-11","objectID":"/2021/10/container-image-scanner-trivy/:6:0","tags":["Trivy","DevOps","Pipeline"],"title":"Container Image Scanner - Trivy","uri":"/2021/10/container-image-scanner-trivy/"},{"categories":["DevOps"],"content":"Inner working of Trivy Before we use Trivy, we need to know how Trivy works inside. As you see, there are 2 steps; first, we run the Trivy command, Trivy will download the vulnerability DB from the NVD website into the local machine. And then Trivy uses the vulnerability data to scan every layer of your image. ","date":"2021-10-11","objectID":"/2021/10/container-image-scanner-trivy/:7:0","tags":["Trivy","DevOps","Pipeline"],"title":"Container Image Scanner - Trivy","uri":"/2021/10/container-image-scanner-trivy/"},{"categories":["DevOps"],"content":"How To Use Trivy ","date":"2021-10-11","objectID":"/2021/10/container-image-scanner-trivy/:8:0","tags":["Trivy","DevOps","Pipeline"],"title":"Container Image Scanner - Trivy","uri":"/2021/10/container-image-scanner-trivy/"},{"categories":["DevOps"],"content":"Pipeline Now we have to know how Trivy works inside, we can integrate it into our pipeline; you can see this pipeline, first, we build code into docker image, next, Trivy will check the vulnerabilities in the docker image that build from the last step; if there is no vulnerability, the image will be pushed to the image registry and deploy it to the production environment. If there are some vulnerabilities, the pipeline will be broken by the Trivy command line, you need to fix the vulnerability to make the pipeline green. ","date":"2021-10-11","objectID":"/2021/10/container-image-scanner-trivy/:8:1","tags":["Trivy","DevOps","Pipeline"],"title":"Container Image Scanner - Trivy","uri":"/2021/10/container-image-scanner-trivy/"},{"categories":["DevOps"],"content":"Usage of Trivy Before we write code to integrate, we have to know how to use Trivy. As we know, Trivy is a binary application, so we can use it in the command line. At the same time, Trivy provides its docker image, so we can easily setup it and use it, the command is as follows. For this command, we need to highlight some parameters. ❯ docker run --rm \\ -v /var/run/docker.sock:/var/run/docker.sock \\ aquasec/trivy \\ image \\ --exit-code 1 \\ --ignore-unfixed \\ --severity HIGH,CRITICAL ${YOUR_IMAGE} -v /var/run/docker.sock:/var/run/docker.sock If you would like to scan the image on your local host machine, you need to mount docker.sock –ignore-unfixed Ignore the unfixed issue of vulnerability; If there are some unfixed vulnerabilities, trivy will ignore those vulnerabilities –severity Set the vulnerability level which you want to scan –exit-code Status of trivy when vulnerabilities were found (default: 0). In the pipeline if you set the value to 1, the pipeline will exit and not run continually if you set it to 0, the pipeline will continually run but report the result. So, if you wanna break the pipeline, you can set it to 1. For more information about the arguments and other usages with different ways, please visit the website of Trivy organization by this link: https://github.com/aquasecurity/trivy. ","date":"2021-10-11","objectID":"/2021/10/container-image-scanner-trivy/:8:2","tags":["Trivy","DevOps","Pipeline"],"title":"Container Image Scanner - Trivy","uri":"/2021/10/container-image-scanner-trivy/"},{"categories":["DevOps"],"content":"Demo Below is a demo to show how the trivy breaks the pipeline and what happens when we fix the issues; This project is about to build a Buildkite dashboard, it will filter the built information of your organization which you specify. We use Github actions to build application and setup the Trivy in the pipeline; - name:Trivy scannerrun:|docker run --rm \\ -v /var/run/docker.sock:/var/run/docker.sock \\ aquasec/trivy image \\ --severity HIGH,CRITICAL \\ --exit-code 1 \\ dashboard:${{ github.sha }} In this build job, we use Nignx:1.18 as a base image to build application images. This build failed because there are some vulnerabilities. Now, we must fix this issue to continue delivery. There are 2 steps to do, firstly, we should use the latest Nginx image as a base image; secondly, we could ignore unfixed vulnerabilities, because maybe we are unable to fix vulnerabilities at the system level. You can review the change of code by clicking this link: https://github.com/guzhongren/Buildkite-Dashboard/commit/90182b9b3770aeb28a6e566208334dd0c6f8f725#annotation_843974303 ","date":"2021-10-11","objectID":"/2021/10/container-image-scanner-trivy/:8:3","tags":["Trivy","DevOps","Pipeline"],"title":"Container Image Scanner - Trivy","uri":"/2021/10/container-image-scanner-trivy/"},{"categories":["DevOps"],"content":"Summary Security is a very important issue no matter where you are. We can Shift Left Security, so we can reduce the security risk in the production environment; For the scanner tool Trivy, it is very useful to keep the security of images, it can scan not only images but also git repositories, file systems, etc. ","date":"2021-10-11","objectID":"/2021/10/container-image-scanner-trivy/:9:0","tags":["Trivy","DevOps","Pipeline"],"title":"Container Image Scanner - Trivy","uri":"/2021/10/container-image-scanner-trivy/"},{"categories":["DevOps"],"content":"Refs https://www.sonarqube.org/ https://hub.docker.com/r/aquasec/trivy#ignore-unfixed-vulnerabilities https://github.com/marketplace/actions/aqua-security-trivy https://github.com/quay/clair https://github.com/aquasecurity/trivy https://github.com/anchore/anchore-engine https://github.com/quay/quay https://cloud.google.com/container-registry https://goharbor.io/blog/harbor-1.10-release/ https://www.thoughtworks.com/radar/tools?blipid=201911077 https://cve.mitre.org/index.html https://nvd.nist.gov https://blog.aquasec.com/trivy-vulnerability-scanner-joins-aqua-family https://guzhongren.github.io/ ","date":"2021-10-11","objectID":"/2021/10/container-image-scanner-trivy/:10:0","tags":["Trivy","DevOps","Pipeline"],"title":"Container Image Scanner - Trivy","uri":"/2021/10/container-image-scanner-trivy/"},{"categories":["DevOps"],"content":"Disclaimer 本文仅代表个人观点，与 Thoughtworks 公司无任何关系。 SHA256 checksum: f2fe1394e4ab9297ed69ff73ac32e9ac1375f01c2102183b509bf9379a5995d6 ","date":"2021-10-11","objectID":"/2021/10/container-image-scanner-trivy/:11:0","tags":["Trivy","DevOps","Pipeline"],"title":"Container Image Scanner - Trivy","uri":"/2021/10/container-image-scanner-trivy/"},{"categories":["DevOps"],"content":"赞助 SHA256 checksum: 964978ecd2059064abe542e51dc02e204d3ee2e6c320ca68e2b1399ce0c6953c 使用此 文件 进行校验： gpg --verify PayForGuzhongren.svg.sig ","date":"2021-10-11","objectID":"/2021/10/container-image-scanner-trivy/:12:0","tags":["Trivy","DevOps","Pipeline"],"title":"Container Image Scanner - Trivy","uri":"/2021/10/container-image-scanner-trivy/"},{"categories":["DevOps"],"content":"Container Image Scanner","date":"2021-09-26","objectID":"/2021/09/container-image-scanner-trivy/","tags":["Trivy","DevOps","Pipeline"],"title":"Container Image Scanner - Trivy","uri":"/2021/09/container-image-scanner-trivy/"},{"categories":["DevOps"],"content":"摘要 在现代软件开发中， 我们会使用一些公共镜像作为基础镜像来快速构建我们的应用镜像，并将其部署到生产环境中。 随着越来越多的应用程序被容器化，容器安全也随之变得越来越重要。在项目的 Pipeline 中， 我们可以使用漏洞扫描器（Vulnerability Scanners）进行扫描并提前获得反馈，实现 “安全左移” ，也可以更好的实践敏捷。 ","date":"2021-09-26","objectID":"/2021/09/container-image-scanner-trivy/:1:0","tags":["Trivy","DevOps","Pipeline"],"title":"Container Image Scanner - Trivy","uri":"/2021/09/container-image-scanner-trivy/"},{"categories":["DevOps"],"content":"基于容器的应用程序的安全痛点 现在，我们使用先进的技术来构建我们的应用程序，如 NodeJS、 Java 和 Kotlin 等，然后将代码库存储在托管的 Git 平台上，如 GitHub、Gitlab 等。代码库由我们的业务代码和依赖关系组成；对于依赖项，我们可以使用专业的扫描工具来确保安全，比如 NodeJS 的 npm audit , GitHub 的 Dependabot；至于我们的业务代码，可以使用其他的一些安全工具可以扫描，比如 SoneQube 等。 因此，对于依赖（ Dependencies）和我们的业务代码，这些都在我们的控制之下，我们可以确保应用程序的安全性，并且在 Pipeline 上获得快速反馈；同时在我们将应用程序部署到生产环境之前可以通过使用各种工具建立信心。但是，通常情况下我们的应用程序运行的系统环境是不受我们控制的，可能存在潜在的安全漏洞。在这我们可以换位思考一下，如果我们不能保证我们的应用程序运行的系统的环境安全，就会导致各种各样意想不到的问题，如黑客攻击、用户信息泄露、财产损失，更会对公司的声誉造成损害。所以，确保我们产出物（Artifact）的安全是很重要的。 ","date":"2021-09-26","objectID":"/2021/09/container-image-scanner-trivy/:2:0","tags":["Trivy","DevOps","Pipeline"],"title":"Container Image Scanner - Trivy","uri":"/2021/09/container-image-scanner-trivy/"},{"categories":["DevOps"],"content":"保持容器镜像安全的价值 ","date":"2021-09-26","objectID":"/2021/09/container-image-scanner-trivy/:3:0","tags":["Trivy","DevOps","Pipeline"],"title":"Container Image Scanner - Trivy","uri":"/2021/09/container-image-scanner-trivy/"},{"categories":["DevOps"],"content":"保护客户的财产（Property）和声誉（Reputation） 我们为公司或客户提供专业的服务，所以我们必须确保每一行代码都是可靠和安全的。因为代码就是公司或者客户的财产和名誉。作为开发者，只要保证代码及应用程序的环境的安全性，公司或者客户就能获得最大的效益。声誉即价值。 ","date":"2021-09-26","objectID":"/2021/09/container-image-scanner-trivy/:3:1","tags":["Trivy","DevOps","Pipeline"],"title":"Container Image Scanner - Trivy","uri":"/2021/09/container-image-scanner-trivy/"},{"categories":["DevOps"],"content":"打造受人尊敬的品牌（Branding） 我们的工作就是让我们的公司或客户成功。只有公司或客户成功，我们才能成功。因此，我们不仅要实现业务价值，还需要保护了产品的安全。用户使用安全的产品或者服务得到更大的价值，公司或者客户的品牌效应就会扩大，从而带来更大的价值。品牌及价值。 ","date":"2021-09-26","objectID":"/2021/09/container-image-scanner-trivy/:3:2","tags":["Trivy","DevOps","Pipeline"],"title":"Container Image Scanner - Trivy","uri":"/2021/09/container-image-scanner-trivy/"},{"categories":["DevOps"],"content":"保持容器镜像安全的 2 个最佳方案 ","date":"2021-09-26","objectID":"/2021/09/container-image-scanner-trivy/:4:0","tags":["Trivy","DevOps","Pipeline"],"title":"Container Image Scanner - Trivy","uri":"/2021/09/container-image-scanner-trivy/"},{"categories":["DevOps"],"content":"方案 1： 在镜像注册表中定期扫描 通过这种方式，我们需要为镜像注册表添加一个安全扫描程序，扫描程序可以是一个定时任务（Cron Job） 作业，也可以是由特定的人触发的可执行操作。 如果是一个定时任务，它将在特定时刻由定时任务自动触发。例如，Docker Hub 会在特定的时间扫描他们的官方注册表，当有任何漏洞被扫描出来时，它会向镜像维护者发送报警信息。 ","date":"2021-09-26","objectID":"/2021/09/container-image-scanner-trivy/:4:1","tags":["Trivy","DevOps","Pipeline"],"title":"Container Image Scanner - Trivy","uri":"/2021/09/container-image-scanner-trivy/"},{"categories":["DevOps"],"content":"方案 2：将扫描工具集成到 Pipeline 中 另一种方法是在 Pipeline 上对镜像产物进行扫描，这样更加简单高效。当我们将代码推送到代码存储库时， Pipeline 将自动执行扫描镜像的命令。因为 Pipeline 每次都是无差别地执行，所以我们可以发现任何安全问题并及时报警修复。 现在，越来越多的团队或公司使用敏捷来开发他们的项目。如果我们能够尽早地发现任何安全问题或者漏洞，我们就可以在产品发布之前降低产品的安全风险。 Pipeline 是确保每一行代码和基础运行环境的安全性是的最好方法之一，因为它可以在提交代码时自动执行。 ","date":"2021-09-26","objectID":"/2021/09/container-image-scanner-trivy/:4:2","tags":["Trivy","DevOps","Pipeline"],"title":"Container Image Scanner - Trivy","uri":"/2021/09/container-image-scanner-trivy/"},{"categories":["DevOps"],"content":"容器安全扫描工具对比 针对上述解决方案，我们调查了 Trivy、claire、Anchore Engine、Quay、Docker hub 和 GCR 等几种扫描工具，从不同维度进行对比。 Scanner OS packages Application dependencies Easy to use Accuracy Suitable for CI Suitable for Solution Trivy ✅ ✅ ⭐ ⭐ ⭐ ⭐ ⭐ ⭐ ⭐ ⭐ ⭐ 2 Clair ✅ ❌ ⭐ ⭐ ⭐ ⭐ ⭐ 2 Anchore Engine ✅ ✅ ⭐ ⭐ ⭐ ⭐ ⭐ ⭐ ⭐ 2 Quay ✅ ❌ ⭐ ⭐ ⭐ ⭐ ⭐ ❌ 1 Docker Hub ✅ ❌ ⭐⭐⭐ ⭐ ❌ 1 GCR ✅ ❌ ⭐ ⭐ ⭐ ⭐ ⭐ ❌ 1 首先，我们可以将这些扫描工具按照其执行的环境简单分类； 因为 Docker Hub、GCR 和 Quay 是需要在服务端也就是容器注册中心运行的， 所以适合方案 1； Trivy、Clair 和 Anchor Engine 可以在 Pipeline 上工作，所以适合解决方案 2。 对于第一个维度：OS Package，这些所有的扫描工具都可以做到，但是对于第二个维度：Application dependencies，只有 Trivy 和 Anchore Engine 可以做到，对于第五个维度：Suitable for CI, 只有前三个符合条件。 对于漏洞数据库的更新，Clair 会定期从一组配置的源中获取漏洞元数据库（Vulnerability Database），并将数据存储在其数据库中，只要不获取最新的漏洞元数据，每次执行都用之前的漏洞数据库，漏洞数据库的时效性有点差。 Trivy 和 Anchore Engine 则是每次运行都将下载最新的漏洞数据库并将其缓存在本地文件中，当扫描工具再次运行时，它将检查并更新数据库以保持数据库为最新状态。 同时，对于 Trivy、Clair 和 Anchore Engine，这三者的社区非常活跃，所以我们不能用没有人来帮你解决你的问题来评判； 而且作为一种工具，它必须易于使用并且有良好的文档可供参考。经过调研，发现 Trivy 的文档非常详细，非常友好， 而且 Trivy 的使用方式更加友好，比如我们可以过滤掉（.trivyignore）你指定的漏洞，对于最新发现的漏洞，官方没有给出修复版本，这时候我们就可以忽略这个漏洞继续构建，但 Anchore Engine 做不到。 2020 年 3 月 16 日，领先的云原生应用和基础设施安全平台供应商 Aqua Security 宣布，其开源的 Trivy 漏洞扫描器将作为一个集成选项添加到其使用的云原生平台、CNCF 的 Harbor 注册表和 Mirantis Docker Enterprise 中。你可以在这里找到这篇文章。 ","date":"2021-09-26","objectID":"/2021/09/container-image-scanner-trivy/:5:0","tags":["Trivy","DevOps","Pipeline"],"title":"Container Image Scanner - Trivy","uri":"/2021/09/container-image-scanner-trivy/"},{"categories":["DevOps"],"content":"Trivy 在 Thoughtworks 雷达 23 期中 Thoughtworks 技术雷达以准反应技术趋势而闻名；在最新的技术雷达中，Thoughtworks 将 Trivy 引入了置于 Adopt，说明 Trivy 是有用的、有价值的和可行的。 ","date":"2021-09-26","objectID":"/2021/09/container-image-scanner-trivy/:6:0","tags":["Trivy","DevOps","Pipeline"],"title":"Container Image Scanner - Trivy","uri":"/2021/09/container-image-scanner-trivy/"},{"categories":["DevOps"],"content":"Trivy 的工作原理 在我们使用 Trivy 之前，我们需要知道 Trivy 内部是如何运作的。如上图所示，有两个步骤；首先，我们运行 Trivy 命令，Trivy 将从 NVD 网站下载漏洞数据库到本地机器。然后， Trivy 利用漏洞数据扫描你的镜像的每一层（Layer）。 ","date":"2021-09-26","objectID":"/2021/09/container-image-scanner-trivy/:7:0","tags":["Trivy","DevOps","Pipeline"],"title":"Container Image Scanner - Trivy","uri":"/2021/09/container-image-scanner-trivy/"},{"categories":["DevOps"],"content":"实践 Trivy ","date":"2021-09-26","objectID":"/2021/09/container-image-scanner-trivy/:8:0","tags":["Trivy","DevOps","Pipeline"],"title":"Container Image Scanner - Trivy","uri":"/2021/09/container-image-scanner-trivy/"},{"categories":["DevOps"],"content":"Pipeline 现在我们已经知道 Trivy 是如何工作的，我们可以将它集成到我们的 Pipeline 中；首先，将代码构建到 Docker 镜像中，接下来，Trivy 会扫描上一步构建的 Docker 镜像； 如果没有漏洞，镜像会被推送到镜像注册中心并部署到 Test 或者 UAT 环境； 如果存在漏洞，Pipeline 会被 Trivy 的命令行打断退出，这时候你就需要修复漏洞以使 Pipeline 变绿通过。 ","date":"2021-09-26","objectID":"/2021/09/container-image-scanner-trivy/:8:1","tags":["Trivy","DevOps","Pipeline"],"title":"Container Image Scanner - Trivy","uri":"/2021/09/container-image-scanner-trivy/"},{"categories":["DevOps"],"content":"Trivy 的使用方法 在编写代码进行集成之前，我们必须知道如何使用 Trivy，Trivy 是一个二进制应用程序，所以我们可以在命令行中使用它。同时，Trivy 提供了它的 Docker 镜像，所以我们可以很容易地在 Pipeline 上设置和使用。命令如下，对于这个命令，我们需要重点说明一些参数。 ❯ docker run --rm \\ -v /var/run/docker.sock:/var/run/docker.sock \\ aquasec/trivy \\ image \\ --exit-code 1 \\ --ignore-unfixed \\ --severity HIGH,CRITICAL ${YOUR_IMAGE} -v /var/run/docker.sock:/var/run/docker.sock 如果想扫描本地主机上的镜像，需要挂载 docker.sock –ignore-unfixed 忽略未修复的漏洞问题；如果存在未修复的漏洞，Trivy 将忽略这些漏洞 –severity 设置要扫描的漏洞级别 –exit-code 发现漏洞时 Trivy 的退出状态（默认值：0)； 在 Pipeline 中，如果将该值设置为 1，且有漏洞被发现，则 Pipeline 将退出，而不会继续运行。如果将其设置为 0，则 Pipeline 将继续运行，但会报告结果。所以，如果你想在发现漏洞后阻止 Pipeline 继续执行，可以设置它为 1。 想了解更多关于参数和使用方法的信息，请访问 Trivy 的官方网站：https://github.com/aquasecurity/trivy。 ","date":"2021-09-26","objectID":"/2021/09/container-image-scanner-trivy/:8:2","tags":["Trivy","DevOps","Pipeline"],"title":"Container Image Scanner - Trivy","uri":"/2021/09/container-image-scanner-trivy/"},{"categories":["DevOps"],"content":"Demo 下面是一个 Demo，展示了 Trivy 如何打断 Pipeline 的执行 ，以及当我们修复问题后又发生什么。该项目将构建一个 Buildkite Dashboard（Buildkite 是一个 CI/CD 平台），它将过滤出你指定的组织下的项目的构建信息。这里我们使用 GitHub Actions 来构建这个应用程序，并在 Pipeline 中集成 Trivy，代码如下： - name:Trivy scannerrun:|docker run --rm \\ -v /var/run/docker.sock:/var/run/docker.sock \\ aquasec/trivy image \\ --severity HIGH,CRITICAL \\ --exit-code 1 \\ dashboard:${{ github.sha }} 在这个 Job 中，我们使用 Nignx:1.18 作为基础镜像来构建应用程序镜像。可以看到由于存在一些漏洞，本次构建失败了。 现在，我们必须解决这个问题来达到持续交付目的。这里有两个步骤要做，首先，我们应该使用最新的 Nginx 镜像作为基础镜像；其次，我们可以忽略未修复的漏洞，因为我们可能无法在系统级别修复某些最新的漏洞。你可以通过如下链接查看修复该问题的代码更改； https://github.com/guzhongren/Buildkite-Dashboard/commit/90182b9b3770aeb28a6e566208334dd0c6f8f725#annotation_843974303 ","date":"2021-09-26","objectID":"/2021/09/container-image-scanner-trivy/:8:3","tags":["Trivy","DevOps","Pipeline"],"title":"Container Image Scanner - Trivy","uri":"/2021/09/container-image-scanner-trivy/"},{"categories":["DevOps"],"content":"总结 无论你在哪里，安全都是一个非常重要的问题。我们可以将 “安全左移（Shift Left Security）”，这样就可以减少生产环境中的安全风险；对于扫描工具 Trivy 来说，它对于保证镜像的安全性非常有用，它不仅可以扫描镜像，还可以扫描 Git 仓库，文件系统等。 最后，非常感谢同事张思楚、王亦晨和邢砚敏等人的大力支持和指导，在他们热心帮助和辛苦付出之下才有了这篇文章。 ","date":"2021-09-26","objectID":"/2021/09/container-image-scanner-trivy/:9:0","tags":["Trivy","DevOps","Pipeline"],"title":"Container Image Scanner - Trivy","uri":"/2021/09/container-image-scanner-trivy/"},{"categories":["DevOps"],"content":"Refs https://www.sonarqube.org/ https://hub.docker.com/r/aquasec/trivy#ignore-unfixed-vulnerabilities https://github.com/marketplace/actions/aqua-security-trivy https://github.com/quay/clair https://github.com/aquasecurity/trivy https://github.com/anchore/anchore-engine https://github.com/quay/quay https://cloud.google.com/container-registry https://goharbor.io/blog/harbor-1.10-release/ https://www.thoughtworks.com/radar/tools?blipid=201911077 https://cve.mitre.org/index.html https://nvd.nist.gov https://blog.aquasec.com/trivy-vulnerability-scanner-joins-aqua-family https://guzhongren.github.io/ ","date":"2021-09-26","objectID":"/2021/09/container-image-scanner-trivy/:10:0","tags":["Trivy","DevOps","Pipeline"],"title":"Container Image Scanner - Trivy","uri":"/2021/09/container-image-scanner-trivy/"},{"categories":["DevOps"],"content":"Disclaimer 本文仅代表个人观点，与 Thoughtworks 公司无任何关系。 SHA256 checksum: f2fe1394e4ab9297ed69ff73ac32e9ac1375f01c2102183b509bf9379a5995d6 ","date":"2021-09-26","objectID":"/2021/09/container-image-scanner-trivy/:11:0","tags":["Trivy","DevOps","Pipeline"],"title":"Container Image Scanner - Trivy","uri":"/2021/09/container-image-scanner-trivy/"},{"categories":["DevOps"],"content":"赞助 SHA256 checksum: 964978ecd2059064abe542e51dc02e204d3ee2e6c320ca68e2b1399ce0c6953c 使用此 文件 进行校验： gpg --verify PayForGuzhongren.svg.sig ","date":"2021-09-26","objectID":"/2021/09/container-image-scanner-trivy/:12:0","tags":["Trivy","DevOps","Pipeline"],"title":"Container Image Scanner - Trivy","uri":"/2021/09/container-image-scanner-trivy/"},{"categories":["Agile"],"content":"常用会议 以下是一些我们在敏捷开发中常用的会议目录，我们可以使用这张表格对相关会议进行适当裁剪，应用到自身团队来提升团队的敏捷实践，提高效率。 Meeting name Frequency Duration Host Participators Main content \u0026 Target Standup meeting Everyday 10’~15’ Team member take turns All team member and your PO PM and so on Describe your job yesterday and today, call out the block, and give a deadline Showcase Fortnightly 30’ Team member take turns All team member and your PO PM and so on Show delivery value Code Review Everyday 1h Every dev All dev Go thought your code which is written today, feedback to others from tech and biz perspective Backlog grooming Fortnightly 1h BA All team member BA and others will explain what /why we will do Tech Huddle Twice a week(1 short , 1 long) 30’ or 1h Every dev take turns All dev Show some new tech, or deep work in some domain, Expand your influence Retro Fortnightly 1h Every dev take turns All team member, PO, PM Collection some tips which can improve team member work efficiency and make work env more safe and happy Delivery Health Check Fortnightly 30’ BA / TL/ Volunteer All team member Check spring’s all cards and hight light the abnormal card， explain it and collection some tips to improve the accuracy of estimating Poker Planning Fortnightly 1h BA All team member Estimate cost which you do the specific card, and BA will pull some cards into next spring which all points match some number Bug bash Every release Before go-live 1h QA All team member Find bugs from different perspective with different role 1 on 1 Monthly 20’ You or your PM/DM You and your PM/DM Talk about daily work and life, best to give feedbacks or suggestions ","date":"2021-08-14","objectID":"/2021/08/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%9A%E8%AE%AE/:1:0","tags":["敏捷","Agile","会议"],"title":"敏捷开发中有哪些会议？","uri":"/2021/08/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%9A%E8%AE%AE/"},{"categories":["Agile"],"content":"提升会议 上面这些都是些正常的日常会议，但是在日常的工作中还有其他不那么频繁的会议，并且这些会议大多数只是需要参与进去，而不是主持者；这些会议通常是扩大团队或者个人影响力的会议，所以建议你抓住机会。 Meeting name Frequency Duration Host Participators Main content \u0026 Target Vertical or All Hands Monthly 1h Volunteer or someone who has impact All team member and customer understand some direction from customer’s company, and show what your team do to customers or other teams, expand you and your team member’s influence Developer Cop(community of Practice) Monthly 1h TL/ Volunteer/TP All dev and customer Show some useful and practice tech, make everyone know and use your tech according to your suggestion Gamba work Once a year or half-yearly 1h TL/ Volunteer/TP All team member Show what your team members are doing and daily work to customer ","date":"2021-08-14","objectID":"/2021/08/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%9A%E8%AE%AE/:2:0","tags":["敏捷","Agile","会议"],"title":"敏捷开发中有哪些会议？","uri":"/2021/08/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%9A%E8%AE%AE/"},{"categories":["Agile"],"content":"按需裁减 会议只是流程，选择真正适合自己团队的会议才能发挥更好的作用，同时，也要根据自己团队的现实情况适当裁减会议流程。 ","date":"2021-08-14","objectID":"/2021/08/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%9A%E8%AE%AE/:3:0","tags":["敏捷","Agile","会议"],"title":"敏捷开发中有哪些会议？","uri":"/2021/08/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%9A%E8%AE%AE/"},{"categories":["Agile"],"content":"Refs 博客：https://guzhongren.github.io/ ","date":"2021-08-14","objectID":"/2021/08/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%9A%E8%AE%AE/:4:0","tags":["敏捷","Agile","会议"],"title":"敏捷开发中有哪些会议？","uri":"/2021/08/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%9A%E8%AE%AE/"},{"categories":["Agile"],"content":"Disclaimer 本文仅代表个人观点，与 Thoughtworks 公司无任何关系。 SHA256 checksum: f2fe1394e4ab9297ed69ff73ac32e9ac1375f01c2102183b509bf9379a5995d6 ","date":"2021-08-14","objectID":"/2021/08/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%9A%E8%AE%AE/:5:0","tags":["敏捷","Agile","会议"],"title":"敏捷开发中有哪些会议？","uri":"/2021/08/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%9A%E8%AE%AE/"},{"categories":["Agile"],"content":"赞助 SHA256 checksum: 964978ecd2059064abe542e51dc02e204d3ee2e6c320ca68e2b1399ce0c6953c 使用此 文件 进行校验： gpg --verify PayForGuzhongren.svg.sig ","date":"2021-08-14","objectID":"/2021/08/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%9A%E8%AE%AE/:6:0","tags":["敏捷","Agile","会议"],"title":"敏捷开发中有哪些会议？","uri":"/2021/08/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%9A%E8%AE%AE/"},{"categories":["Tool"],"content":" 因为我对我的所有的 git commit 都开启了签名，而且每次 GPG 签名的最长缓存时间我设置成了 1 天， 所以过了今天明天就得重新输入密码了，这估计是个无解的问题，除非我生成没有密码的 GPG 密钥对。 同时，在我本记会出现另一个问题，就是签名失败。 error: gpg failed to sign the data fatal: failed to write commit object 解决方法其实很简单，将 export GPG_TTY=$(tty) 这个加入你的 shell 启动文件里就可以了， 我这是 .zshrc, 然后使之生效。 source ~/.zshrc ","date":"2021-08-07","objectID":"/2021/08/the-soluction-of-git-adding-gpg-sign-failed/:0:0","tags":["gpg","sign","TTY"],"title":"The Solution of Git Adding GPG Sign Failed","uri":"/2021/08/the-soluction-of-git-adding-gpg-sign-failed/"},{"categories":["Tool"],"content":"Refs 博客：https://guzhongren.github.io/ ","date":"2021-08-07","objectID":"/2021/08/the-soluction-of-git-adding-gpg-sign-failed/:1:0","tags":["gpg","sign","TTY"],"title":"The Solution of Git Adding GPG Sign Failed","uri":"/2021/08/the-soluction-of-git-adding-gpg-sign-failed/"},{"categories":["Tool"],"content":"Disclaimer 本文仅代表个人观点，与 Thoughtworks 公司无任何关系。 SHA256 checksum: f2fe1394e4ab9297ed69ff73ac32e9ac1375f01c2102183b509bf9379a5995d6 ","date":"2021-08-07","objectID":"/2021/08/the-soluction-of-git-adding-gpg-sign-failed/:2:0","tags":["gpg","sign","TTY"],"title":"The Solution of Git Adding GPG Sign Failed","uri":"/2021/08/the-soluction-of-git-adding-gpg-sign-failed/"},{"categories":["Tool"],"content":"赞助 SHA256 checksum: 964978ecd2059064abe542e51dc02e204d3ee2e6c320ca68e2b1399ce0c6953c 使用此 文件 进行校验： gpg --verify PayForGuzhongren.svg.sig ","date":"2021-08-07","objectID":"/2021/08/the-soluction-of-git-adding-gpg-sign-failed/:3:0","tags":["gpg","sign","TTY"],"title":"The Solution of Git Adding GPG Sign Failed","uri":"/2021/08/the-soluction-of-git-adding-gpg-sign-failed/"},{"categories":["碎碎念"],"content":"工具的价值完全取决于你使用他的方式方法","date":"2021-07-12","objectID":"/2021/07/%E7%94%B1iwatch%E6%98%AF%E4%B8%8D%E6%98%AF%E7%94%9F%E4%BA%A7%E5%8A%9B%E5%B7%A5%E5%85%B7%E6%83%B3%E5%88%B0%E7%9A%84/","tags":["iWatch","生产力","效率"],"title":"由 iWatch 是不是生产力工具想到的","uri":"/2021/07/%E7%94%B1iwatch%E6%98%AF%E4%B8%8D%E6%98%AF%E7%94%9F%E4%BA%A7%E5%8A%9B%E5%B7%A5%E5%85%B7%E6%83%B3%E5%88%B0%E7%9A%84/"},{"categories":["碎碎念"],"content":"今天朋友发来一个 iWatch SE 的京东购买链接，然后问我这个手表怎么样。作为一个已经有 iWatch 的人来说，回答这个问题应该很简单吧？ 然并卵。 先不说，是不是生产力完全取决于你怎么使用它这个万能定律。 对我而言，我们公司都是把所有的会议时间都会以日历的形式发给需要参会的人。 然后我们只需要在特定的日历上登录我们的账号就可以跟踪参会了。对于 Apple 的设备，Mac, Pad, Watch， iPhone 都是互联的，所有只要你有一个账号登录的对应的应用，那么你的其他设备也是会时时收到消息的。比如，我将我的公司邮箱的日历订阅登陆到手机， Mac 和 pad 上，当有新的会议发过来的时候，我的这些设备都会收到消息；然后在你需要参会的时候，他会提前 15 分钟（默认）提醒你参加会议。还是很方便的，别的应用就先不说了。 那么， 问题就会是，你的生活中真的需要一部 iWatch 来辅助你么？ 如果你有像我这样的需求，参会，信息提示等，那么你需要它； 如果你想在带孩子的时候，不想被拿起手机影响你和孩子的互动，你需要它； 如果……你需要它； 每个产品都有他的价值，但是需要你用你的财富去买。作为使用者，我们如果能用它产生比产品更大的价值，那么它就买值了。 去买吧，用一次小小的尝试去满足一下你的小小的好奇心，下次，你就知道了你要买的东西值不值了。 ","date":"2021-07-12","objectID":"/2021/07/%E7%94%B1iwatch%E6%98%AF%E4%B8%8D%E6%98%AF%E7%94%9F%E4%BA%A7%E5%8A%9B%E5%B7%A5%E5%85%B7%E6%83%B3%E5%88%B0%E7%9A%84/:0:0","tags":["iWatch","生产力","效率"],"title":"由 iWatch 是不是生产力工具想到的","uri":"/2021/07/%E7%94%B1iwatch%E6%98%AF%E4%B8%8D%E6%98%AF%E7%94%9F%E4%BA%A7%E5%8A%9B%E5%B7%A5%E5%85%B7%E6%83%B3%E5%88%B0%E7%9A%84/"},{"categories":["碎碎念"],"content":"Refs 博客：https://guzhongren.github.io/ ","date":"2021-07-12","objectID":"/2021/07/%E7%94%B1iwatch%E6%98%AF%E4%B8%8D%E6%98%AF%E7%94%9F%E4%BA%A7%E5%8A%9B%E5%B7%A5%E5%85%B7%E6%83%B3%E5%88%B0%E7%9A%84/:1:0","tags":["iWatch","生产力","效率"],"title":"由 iWatch 是不是生产力工具想到的","uri":"/2021/07/%E7%94%B1iwatch%E6%98%AF%E4%B8%8D%E6%98%AF%E7%94%9F%E4%BA%A7%E5%8A%9B%E5%B7%A5%E5%85%B7%E6%83%B3%E5%88%B0%E7%9A%84/"},{"categories":["碎碎念"],"content":"Disclaimer 本文仅代表个人观点，与 Thoughtworks 公司无任何关系。 SHA256 checksum: f2fe1394e4ab9297ed69ff73ac32e9ac1375f01c2102183b509bf9379a5995d6 ","date":"2021-07-12","objectID":"/2021/07/%E7%94%B1iwatch%E6%98%AF%E4%B8%8D%E6%98%AF%E7%94%9F%E4%BA%A7%E5%8A%9B%E5%B7%A5%E5%85%B7%E6%83%B3%E5%88%B0%E7%9A%84/:2:0","tags":["iWatch","生产力","效率"],"title":"由 iWatch 是不是生产力工具想到的","uri":"/2021/07/%E7%94%B1iwatch%E6%98%AF%E4%B8%8D%E6%98%AF%E7%94%9F%E4%BA%A7%E5%8A%9B%E5%B7%A5%E5%85%B7%E6%83%B3%E5%88%B0%E7%9A%84/"},{"categories":["碎碎念"],"content":"赞助 SHA256 checksum: 964978ecd2059064abe542e51dc02e204d3ee2e6c320ca68e2b1399ce0c6953c 使用此 文件 进行校验： gpg --verify PayForGuzhongren.svg.sig ","date":"2021-07-12","objectID":"/2021/07/%E7%94%B1iwatch%E6%98%AF%E4%B8%8D%E6%98%AF%E7%94%9F%E4%BA%A7%E5%8A%9B%E5%B7%A5%E5%85%B7%E6%83%B3%E5%88%B0%E7%9A%84/:3:0","tags":["iWatch","生产力","效率"],"title":"由 iWatch 是不是生产力工具想到的","uri":"/2021/07/%E7%94%B1iwatch%E6%98%AF%E4%B8%8D%E6%98%AF%E7%94%9F%E4%BA%A7%E5%8A%9B%E5%B7%A5%E5%85%B7%E6%83%B3%E5%88%B0%E7%9A%84/"},{"categories":["碎碎念"],"content":"旅行就是，你离开了你讨厌的城市去看看别人讨厌的城市。 ","date":"2021-07-09","objectID":"/2021/07/%E8%8A%B1%E9%9D%9E%E8%8A%B1%E9%9B%BE%E9%9D%9E%E9%9B%BE-%E6%96%B0%E7%96%86%E4%B9%8B%E6%97%85/:0:0","tags":["旅游","碎碎念"],"title":"花非花，雾非雾 新疆之旅","uri":"/2021/07/%E8%8A%B1%E9%9D%9E%E8%8A%B1%E9%9B%BE%E9%9D%9E%E9%9B%BE-%E6%96%B0%E7%96%86%E4%B9%8B%E6%97%85/"},{"categories":["碎碎念"],"content":"旅行抱团-羊毛出在羊身上 ","date":"2021-07-09","objectID":"/2021/07/%E8%8A%B1%E9%9D%9E%E8%8A%B1%E9%9B%BE%E9%9D%9E%E9%9B%BE-%E6%96%B0%E7%96%86%E4%B9%8B%E6%97%85/:1:0","tags":["旅游","碎碎念"],"title":"花非花，雾非雾 新疆之旅","uri":"/2021/07/%E8%8A%B1%E9%9D%9E%E8%8A%B1%E9%9B%BE%E9%9D%9E%E9%9B%BE-%E6%96%B0%E7%96%86%E4%B9%8B%E6%97%85/"},{"categories":["碎碎念"],"content":"看山是山，又要不是山 ","date":"2021-07-09","objectID":"/2021/07/%E8%8A%B1%E9%9D%9E%E8%8A%B1%E9%9B%BE%E9%9D%9E%E9%9B%BE-%E6%96%B0%E7%96%86%E4%B9%8B%E6%97%85/:2:0","tags":["旅游","碎碎念"],"title":"花非花，雾非雾 新疆之旅","uri":"/2021/07/%E8%8A%B1%E9%9D%9E%E8%8A%B1%E9%9B%BE%E9%9D%9E%E9%9B%BE-%E6%96%B0%E7%96%86%E4%B9%8B%E6%97%85/"},{"categories":["碎碎念"],"content":"避免无效沟通 ","date":"2021-07-09","objectID":"/2021/07/%E8%8A%B1%E9%9D%9E%E8%8A%B1%E9%9B%BE%E9%9D%9E%E9%9B%BE-%E6%96%B0%E7%96%86%E4%B9%8B%E6%97%85/:3:0","tags":["旅游","碎碎念"],"title":"花非花，雾非雾 新疆之旅","uri":"/2021/07/%E8%8A%B1%E9%9D%9E%E8%8A%B1%E9%9B%BE%E9%9D%9E%E9%9B%BE-%E6%96%B0%E7%96%86%E4%B9%8B%E6%97%85/"},{"categories":["碎碎念"],"content":"“我就喜欢你看不惯我还干不掉我的样子” ","date":"2021-07-09","objectID":"/2021/07/%E8%8A%B1%E9%9D%9E%E8%8A%B1%E9%9B%BE%E9%9D%9E%E9%9B%BE-%E6%96%B0%E7%96%86%E4%B9%8B%E6%97%85/:4:0","tags":["旅游","碎碎念"],"title":"花非花，雾非雾 新疆之旅","uri":"/2021/07/%E8%8A%B1%E9%9D%9E%E8%8A%B1%E9%9B%BE%E9%9D%9E%E9%9B%BE-%E6%96%B0%E7%96%86%E4%B9%8B%E6%97%85/"},{"categories":["碎碎念"],"content":"每一份经历都是一份收获 ","date":"2021-07-09","objectID":"/2021/07/%E8%8A%B1%E9%9D%9E%E8%8A%B1%E9%9B%BE%E9%9D%9E%E9%9B%BE-%E6%96%B0%E7%96%86%E4%B9%8B%E6%97%85/:5:0","tags":["旅游","碎碎念"],"title":"花非花，雾非雾 新疆之旅","uri":"/2021/07/%E8%8A%B1%E9%9D%9E%E8%8A%B1%E9%9B%BE%E9%9D%9E%E9%9B%BE-%E6%96%B0%E7%96%86%E4%B9%8B%E6%97%85/"},{"categories":["碎碎念"],"content":"Refs 博客：https://guzhongren.github.io/ ","date":"2021-07-09","objectID":"/2021/07/%E8%8A%B1%E9%9D%9E%E8%8A%B1%E9%9B%BE%E9%9D%9E%E9%9B%BE-%E6%96%B0%E7%96%86%E4%B9%8B%E6%97%85/:6:0","tags":["旅游","碎碎念"],"title":"花非花，雾非雾 新疆之旅","uri":"/2021/07/%E8%8A%B1%E9%9D%9E%E8%8A%B1%E9%9B%BE%E9%9D%9E%E9%9B%BE-%E6%96%B0%E7%96%86%E4%B9%8B%E6%97%85/"},{"categories":["碎碎念"],"content":"Disclaimer 本文仅代表个人观点，与 Thoughtworks 公司无任何关系。 SHA256 checksum: f2fe1394e4ab9297ed69ff73ac32e9ac1375f01c2102183b509bf9379a5995d6 ","date":"2021-07-09","objectID":"/2021/07/%E8%8A%B1%E9%9D%9E%E8%8A%B1%E9%9B%BE%E9%9D%9E%E9%9B%BE-%E6%96%B0%E7%96%86%E4%B9%8B%E6%97%85/:7:0","tags":["旅游","碎碎念"],"title":"花非花，雾非雾 新疆之旅","uri":"/2021/07/%E8%8A%B1%E9%9D%9E%E8%8A%B1%E9%9B%BE%E9%9D%9E%E9%9B%BE-%E6%96%B0%E7%96%86%E4%B9%8B%E6%97%85/"},{"categories":["碎碎念"],"content":"赞助 SHA256 checksum: 964978ecd2059064abe542e51dc02e204d3ee2e6c320ca68e2b1399ce0c6953c 使用此 文件 进行校验： gpg --verify PayForGuzhongren.svg.sig ","date":"2021-07-09","objectID":"/2021/07/%E8%8A%B1%E9%9D%9E%E8%8A%B1%E9%9B%BE%E9%9D%9E%E9%9B%BE-%E6%96%B0%E7%96%86%E4%B9%8B%E6%97%85/:8:0","tags":["旅游","碎碎念"],"title":"花非花，雾非雾 新疆之旅","uri":"/2021/07/%E8%8A%B1%E9%9D%9E%E8%8A%B1%E9%9B%BE%E9%9D%9E%E9%9B%BE-%E6%96%B0%E7%96%86%E4%B9%8B%E6%97%85/"},{"categories":[""],"content":"原罪 \u003e 521.3*100 \u003c 52129.99999999999 用你的浏览器来执行上面的计算，你应该能得到这个神奇的结果（52129.99999999999）。 Why? ","date":"2021-06-19","objectID":"/2021/06/js%E6%95%B0%E6%8D%AE%E7%B2%BE%E5%BA%A6%E4%B9%8B521.3100/:1:0","tags":[""],"title":"Js 数据精度之 521.3*100","uri":"/2021/06/js%E6%95%B0%E6%8D%AE%E7%B2%BE%E5%BA%A6%E4%B9%8B521.3100/"},{"categories":[""],"content":"JS 数字丢失精度的原因 s eeeeeee eeeeffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff |1| 11 | 52 | 1 位用来表示符号位 11 位用来表示指数 52 位表示位数 ","date":"2021-06-19","objectID":"/2021/06/js%E6%95%B0%E6%8D%AE%E7%B2%BE%E5%BA%A6%E4%B9%8B521.3100/:2:0","tags":[""],"title":"Js 数据精度之 521.3*100","uri":"/2021/06/js%E6%95%B0%E6%8D%AE%E7%B2%BE%E5%BA%A6%E4%B9%8B521.3100/"},{"categories":[""],"content":"Example \u003e 0.1 + 0.2 \u003c 0.30000000000000004 为什么会是这样？ 首先，十进制的 0.1 和 0.2 都会被转换成二进制，但由于浮点数用二进制表达时是无穷的 0.1 -\u003e 0.0001100110011001...（无限） 0.2 -\u003e 0.0011001100110011...（无限） IEEE 754 标准的 64 位双精度浮点数的小数部分最多支持 53 位二进制位，所以两者相加之后得到二进制为： 0.0100110011001100110011001100110011001100110011001100 因浮点数小数位的限制而截断的二进制数字，再转换为十进制，就成了 0.30000000000000004。所以在进行算术计算时会产生误差 ","date":"2021-06-19","objectID":"/2021/06/js%E6%95%B0%E6%8D%AE%E7%B2%BE%E5%BA%A6%E4%B9%8B521.3100/:3:0","tags":[""],"title":"Js 数据精度之 521.3*100","uri":"/2021/06/js%E6%95%B0%E6%8D%AE%E7%B2%BE%E5%BA%A6%E4%B9%8B521.3100/"},{"categories":[""],"content":"如何解决 ","date":"2021-06-19","objectID":"/2021/06/js%E6%95%B0%E6%8D%AE%E7%B2%BE%E5%BA%A6%E4%B9%8B521.3100/:4:0","tags":[""],"title":"Js 数据精度之 521.3*100","uri":"/2021/06/js%E6%95%B0%E6%8D%AE%E7%B2%BE%E5%BA%A6%E4%B9%8B521.3100/"},{"categories":[""],"content":"toFix \u003e (0.1+0.2).toFixed(1) \u003c \"0.3\" ","date":"2021-06-19","objectID":"/2021/06/js%E6%95%B0%E6%8D%AE%E7%B2%BE%E5%BA%A6%E4%B9%8B521.3100/:4:1","tags":[""],"title":"Js 数据精度之 521.3*100","uri":"/2021/06/js%E6%95%B0%E6%8D%AE%E7%B2%BE%E5%BA%A6%E4%B9%8B521.3100/"},{"categories":[""],"content":"Math.round \u003e 621.3*100 \u003c 62129.99999999999 \u003e Math.round(621.3 * 100) \u003c 62130 ","date":"2021-06-19","objectID":"/2021/06/js%E6%95%B0%E6%8D%AE%E7%B2%BE%E5%BA%A6%E4%B9%8B521.3100/:4:2","tags":[""],"title":"Js 数据精度之 521.3*100","uri":"/2021/06/js%E6%95%B0%E6%8D%AE%E7%B2%BE%E5%BA%A6%E4%B9%8B521.3100/"},{"categories":[""],"content":"倍数 \u003e function toFixed(num, s) { var times = Math.pow(10, s) var des = num * times + 0.5 des = parseInt(des, 10) / times return des} \u003e toFixed(0.1+0.2, 1) \u003c 0.3 ","date":"2021-06-19","objectID":"/2021/06/js%E6%95%B0%E6%8D%AE%E7%B2%BE%E5%BA%A6%E4%B9%8B521.3100/:4:3","tags":[""],"title":"Js 数据精度之 521.3*100","uri":"/2021/06/js%E6%95%B0%E6%8D%AE%E7%B2%BE%E5%BA%A6%E4%B9%8B521.3100/"},{"categories":[""],"content":"Refs 博客：https://guzhongren.github.io/ ","date":"2021-06-19","objectID":"/2021/06/js%E6%95%B0%E6%8D%AE%E7%B2%BE%E5%BA%A6%E4%B9%8B521.3100/:5:0","tags":[""],"title":"Js 数据精度之 521.3*100","uri":"/2021/06/js%E6%95%B0%E6%8D%AE%E7%B2%BE%E5%BA%A6%E4%B9%8B521.3100/"},{"categories":[""],"content":"Disclaimer 本文仅代表个人观点，与 Thoughtworks 公司无任何关系。 SHA256 checksum: f2fe1394e4ab9297ed69ff73ac32e9ac1375f01c2102183b509bf9379a5995d6 ","date":"2021-06-19","objectID":"/2021/06/js%E6%95%B0%E6%8D%AE%E7%B2%BE%E5%BA%A6%E4%B9%8B521.3100/:6:0","tags":[""],"title":"Js 数据精度之 521.3*100","uri":"/2021/06/js%E6%95%B0%E6%8D%AE%E7%B2%BE%E5%BA%A6%E4%B9%8B521.3100/"},{"categories":[""],"content":"赞助 SHA256 checksum: 964978ecd2059064abe542e51dc02e204d3ee2e6c320ca68e2b1399ce0c6953c 使用此 文件 进行校验： gpg --verify PayForGuzhongren.svg.sig ","date":"2021-06-19","objectID":"/2021/06/js%E6%95%B0%E6%8D%AE%E7%B2%BE%E5%BA%A6%E4%B9%8B521.3100/:7:0","tags":[""],"title":"Js 数据精度之 521.3*100","uri":"/2021/06/js%E6%95%B0%E6%8D%AE%E7%B2%BE%E5%BA%A6%E4%B9%8B521.3100/"},{"categories":["JavaScript"],"content":"问题 有这么一个需求，有一个合法的数组，需要每隔 3 秒执行一个异步函数，直到最后得到所有异步函数执行结果。 ","date":"2021-06-06","objectID":"/2021/06/%E5%AF%B9foreach%E5%92%8Cfor%E4%B8%A4%E7%A7%8D%E5%BE%AA%E7%8E%AF%E7%B1%BB%E5%9E%8B%E4%B8%AD%E6%89%A7%E8%A1%8C%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E7%9A%84%E5%A4%8D%E7%9B%98/:1:0","tags":["js","forEach","for","Promise"],"title":"对 forEach 和 for 两种循环类型中执行异步函数的复盘","uri":"/2021/06/%E5%AF%B9foreach%E5%92%8Cfor%E4%B8%A4%E7%A7%8D%E5%BE%AA%E7%8E%AF%E7%B1%BB%E5%9E%8B%E4%B8%AD%E6%89%A7%E8%A1%8C%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E7%9A%84%E5%A4%8D%E7%9B%98/"},{"categories":["JavaScript"],"content":"伪解决方案 // testForEach.js const sleep = () =\u003e { return new Promise((resolve, reject) =\u003e { setTimeout(resolve, 3000) }) } const getDifferent = (startDate, endDate) =\u003e { return Math.floor((endDate - startDate) / 1000) } const startDate = new Date() let list = [1, 2, 3, 4, 5, 566, 7, 78, 8, 89, 9, 0] async function testForEach() { let promiseList = [] list.forEach(async item =\u003e { console.log('================1forEach================') await sleep() promiseList.push(await item * 2) console.log('================2forEach================') }) const result = await Promise.all([...promiseList]) const endDate = new Date() console.log(getDifferent(startDate, endDate)) return result } testForEach().then(result =\u003e { console.log(result) }) ","date":"2021-06-06","objectID":"/2021/06/%E5%AF%B9foreach%E5%92%8Cfor%E4%B8%A4%E7%A7%8D%E5%BE%AA%E7%8E%AF%E7%B1%BB%E5%9E%8B%E4%B8%AD%E6%89%A7%E8%A1%8C%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E7%9A%84%E5%A4%8D%E7%9B%98/:2:0","tags":["js","forEach","for","Promise"],"title":"对 forEach 和 for 两种循环类型中执行异步函数的复盘","uri":"/2021/06/%E5%AF%B9foreach%E5%92%8Cfor%E4%B8%A4%E7%A7%8D%E5%BE%AA%E7%8E%AF%E7%B1%BB%E5%9E%8B%E4%B8%AD%E6%89%A7%E8%A1%8C%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E7%9A%84%E5%A4%8D%E7%9B%98/"},{"categories":["JavaScript"],"content":"解释就是 sleep 函数用来等待函数执行； getDifferent 函数用来计算函数开始执行到结束的时间差； testForEach 中用 Array 的 forEach实现循环，并在其中使用休眠 3 秒的逻辑，且通过对原有数组进行异步计算（item * 2）, 然后返回 await Promise.all的结果。 最后一行，执行 Promise 函数，得到 Promise.all 的返回结果，打印，验证。 这一切是不是没有问题？ 最简单的验证办法就是在浏览器控制台运行一下； 这是我的运行结果 12================1forEach================ 0 [] Promise {\u003cfulfilled\u003e: undefined} 12================2forEach================ 前面的 12 代表 这行在最近被重复输出了 12 次，而且看下面，promise 的结果也还没得到，然后程序在输出 2 forEach 的时候停顿了 3 秒；总之，我们没有达到效果。 为什么呢？ ","date":"2021-06-06","objectID":"/2021/06/%E5%AF%B9foreach%E5%92%8Cfor%E4%B8%A4%E7%A7%8D%E5%BE%AA%E7%8E%AF%E7%B1%BB%E5%9E%8B%E4%B8%AD%E6%89%A7%E8%A1%8C%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E7%9A%84%E5%A4%8D%E7%9B%98/:2:1","tags":["js","forEach","for","Promise"],"title":"对 forEach 和 for 两种循环类型中执行异步函数的复盘","uri":"/2021/06/%E5%AF%B9foreach%E5%92%8Cfor%E4%B8%A4%E7%A7%8D%E5%BE%AA%E7%8E%AF%E7%B1%BB%E5%9E%8B%E4%B8%AD%E6%89%A7%E8%A1%8C%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E7%9A%84%E5%A4%8D%E7%9B%98/"},{"categories":["JavaScript"],"content":"掩饰 查看 MDN 官网中关于 Array.prototype.forEach() 的解释，可以看到有一行说明 Note: There is no way to stop or break a forEach() loop other than by throwing an exception. If you need such behavior, the forEach() method is the wrong tool. Early termination may be accomplished with: A simple for loop A for…of / for…in loops Array.prototype.every() Array.prototype.some() Array.prototype.find() Array.prototype.findIndex() Array methods: every(), some(), find(), and findIndex() test the array elements with a predicate returning a truthy value \u003e to determine if further iteration is required. 简单翻译一下，如果要让 forEach 停下，那么只有抛异常这一种方案；但是如果你想在循环中退出那么就需要考虑其他方案了。 但是在我们的案例中，我们需要让循环中的所有结果都正常运行，所以，我们得使用官方建议的方案。【试了一下， every 也是一样的效果，难道是我对文档理解有误？】 ","date":"2021-06-06","objectID":"/2021/06/%E5%AF%B9foreach%E5%92%8Cfor%E4%B8%A4%E7%A7%8D%E5%BE%AA%E7%8E%AF%E7%B1%BB%E5%9E%8B%E4%B8%AD%E6%89%A7%E8%A1%8C%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E7%9A%84%E5%A4%8D%E7%9B%98/:3:0","tags":["js","forEach","for","Promise"],"title":"对 forEach 和 for 两种循环类型中执行异步函数的复盘","uri":"/2021/06/%E5%AF%B9foreach%E5%92%8Cfor%E4%B8%A4%E7%A7%8D%E5%BE%AA%E7%8E%AF%E7%B1%BB%E5%9E%8B%E4%B8%AD%E6%89%A7%E8%A1%8C%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E7%9A%84%E5%A4%8D%E7%9B%98/"},{"categories":["JavaScript"],"content":"新方案 当遇到问题时，往往用原始的方法就可以解决问题。so 使用最原始的 for 循环来解决问题。 // testFor.js const sleep = () =\u003e { return new Promise((resolve, reject) =\u003e { setTimeout(resolve, 3000) }) } const getDifferent = (startDate, endDate) =\u003e { return Math.floor((endDate - startDate) / 1000) } const startDate = new Date() let list = [1, 2, 3, 4, 5, 566, 7, 78, 8, 89, 9, 0] async function testFor() { let promiseList = [] for (let i = 0; i \u003c list.length; i++) { console.log('================1for length================') await sleep() promiseList.push(await list[i] * 2) console.log('================2for length================') } const result = await Promise.all([...promiseList]) const endDate = new Date() console.log(getDifferent(startDate, endDate)) return result } testFor().then(value =\u003e { console.log(value) }) 代码很简单，没有什么可以解释的。在你的浏览器控制台中运行应该可以得到如下结果，在控制台输出的时候是每隔 3 秒输出 2for length 和 1for length 的，直到最后循环完成输出结果。 ================1for length================ Promise {\u003cpending\u003e} ================2for length================ ================1for length================ ================2for length================ ================1for length================ ================2for length================ ================1for length================ ================2for length================ ================1for length================ ================2for length================ ================1for length================ ================2for length================ ================1for length================ ================2for length================ ================1for length================ ================2for length================ ================1for length================ ================2for length================ ================1for length================ ================2for length================ ================1for length================ ================2for length================ ================1for length================ ================2for length================ 36 (12) [2, 4, 6, 8, 10, 1132, 14, 156, 16, 178, 18, 0] ","date":"2021-06-06","objectID":"/2021/06/%E5%AF%B9foreach%E5%92%8Cfor%E4%B8%A4%E7%A7%8D%E5%BE%AA%E7%8E%AF%E7%B1%BB%E5%9E%8B%E4%B8%AD%E6%89%A7%E8%A1%8C%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E7%9A%84%E5%A4%8D%E7%9B%98/:4:0","tags":["js","forEach","for","Promise"],"title":"对 forEach 和 for 两种循环类型中执行异步函数的复盘","uri":"/2021/06/%E5%AF%B9foreach%E5%92%8Cfor%E4%B8%A4%E7%A7%8D%E5%BE%AA%E7%8E%AF%E7%B1%BB%E5%9E%8B%E4%B8%AD%E6%89%A7%E8%A1%8C%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E7%9A%84%E5%A4%8D%E7%9B%98/"},{"categories":["JavaScript"],"content":"总结 如果遇到问题用新特性解决不了，就需要考虑使用最原始的方法了 零信任 要有质疑精神，只要不是自己写的，就有可能有 bug， 不然那么多漏洞是怎么发现的 Keep simple, Keep run ","date":"2021-06-06","objectID":"/2021/06/%E5%AF%B9foreach%E5%92%8Cfor%E4%B8%A4%E7%A7%8D%E5%BE%AA%E7%8E%AF%E7%B1%BB%E5%9E%8B%E4%B8%AD%E6%89%A7%E8%A1%8C%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E7%9A%84%E5%A4%8D%E7%9B%98/:5:0","tags":["js","forEach","for","Promise"],"title":"对 forEach 和 for 两种循环类型中执行异步函数的复盘","uri":"/2021/06/%E5%AF%B9foreach%E5%92%8Cfor%E4%B8%A4%E7%A7%8D%E5%BE%AA%E7%8E%AF%E7%B1%BB%E5%9E%8B%E4%B8%AD%E6%89%A7%E8%A1%8C%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E7%9A%84%E5%A4%8D%E7%9B%98/"},{"categories":["JavaScript"],"content":"Refs 博客：https://guzhongren.github.io/ Array.prototype.forEach() ","date":"2021-06-06","objectID":"/2021/06/%E5%AF%B9foreach%E5%92%8Cfor%E4%B8%A4%E7%A7%8D%E5%BE%AA%E7%8E%AF%E7%B1%BB%E5%9E%8B%E4%B8%AD%E6%89%A7%E8%A1%8C%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E7%9A%84%E5%A4%8D%E7%9B%98/:6:0","tags":["js","forEach","for","Promise"],"title":"对 forEach 和 for 两种循环类型中执行异步函数的复盘","uri":"/2021/06/%E5%AF%B9foreach%E5%92%8Cfor%E4%B8%A4%E7%A7%8D%E5%BE%AA%E7%8E%AF%E7%B1%BB%E5%9E%8B%E4%B8%AD%E6%89%A7%E8%A1%8C%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E7%9A%84%E5%A4%8D%E7%9B%98/"},{"categories":["JavaScript"],"content":"Disclaimer 本文仅代表个人观点，与 Thoughtworks 公司无任何关系。 SHA256 checksum: f2fe1394e4ab9297ed69ff73ac32e9ac1375f01c2102183b509bf9379a5995d6 ","date":"2021-06-06","objectID":"/2021/06/%E5%AF%B9foreach%E5%92%8Cfor%E4%B8%A4%E7%A7%8D%E5%BE%AA%E7%8E%AF%E7%B1%BB%E5%9E%8B%E4%B8%AD%E6%89%A7%E8%A1%8C%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E7%9A%84%E5%A4%8D%E7%9B%98/:7:0","tags":["js","forEach","for","Promise"],"title":"对 forEach 和 for 两种循环类型中执行异步函数的复盘","uri":"/2021/06/%E5%AF%B9foreach%E5%92%8Cfor%E4%B8%A4%E7%A7%8D%E5%BE%AA%E7%8E%AF%E7%B1%BB%E5%9E%8B%E4%B8%AD%E6%89%A7%E8%A1%8C%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E7%9A%84%E5%A4%8D%E7%9B%98/"},{"categories":["JavaScript"],"content":"赞助 SHA256 checksum: 964978ecd2059064abe542e51dc02e204d3ee2e6c320ca68e2b1399ce0c6953c 使用此 文件 进行校验： gpg --verify PayForGuzhongren.svg.sig ","date":"2021-06-06","objectID":"/2021/06/%E5%AF%B9foreach%E5%92%8Cfor%E4%B8%A4%E7%A7%8D%E5%BE%AA%E7%8E%AF%E7%B1%BB%E5%9E%8B%E4%B8%AD%E6%89%A7%E8%A1%8C%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E7%9A%84%E5%A4%8D%E7%9B%98/:8:0","tags":["js","forEach","for","Promise"],"title":"对 forEach 和 for 两种循环类型中执行异步函数的复盘","uri":"/2021/06/%E5%AF%B9foreach%E5%92%8Cfor%E4%B8%A4%E7%A7%8D%E5%BE%AA%E7%8E%AF%E7%B1%BB%E5%9E%8B%E4%B8%AD%E6%89%A7%E8%A1%8C%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E7%9A%84%E5%A4%8D%E7%9B%98/"},{"categories":["Test"],"content":"场景 一般的前端开发情况下，我们都会用到其他的第三方库，比如 UI 库 Ant Desgin， 请求库 axios 等，通常对于 UI 库，我们可以通过快照等操作对其进行测试，但是对于像 axios 这类第三方库，我们必须通过 mock 的方式来实现。 ","date":"2021-04-18","objectID":"/2021/04/test-with-3rd-party-library/:1:0","tags":["test","3rd party test","jest"],"title":"Test With 3rd Party Library","uri":"/2021/04/test-with-3rd-party-library/"},{"categories":["Test"],"content":"问题 上周四晚上突然收到同事的微信求助，怎么 mock 一个 jwt-decode 这个库。然而理想很丰满，现实很骨干。妹子找了 jest 官网的各种测试方式，没有成功，我岂能随随便便成功。 妹子的问题如下： import jwt_decode from 'jwt-decode' const cookieAccessToken = cookie.parse(window.document.cookie) { \"cookie-key\" } const userJwt = (cookieAccessToken \u0026\u0026 jwt_decode(cookieAccessToken)) .... ","date":"2021-04-18","objectID":"/2021/04/test-with-3rd-party-library/:2:0","tags":["test","3rd party test","jest"],"title":"Test With 3rd Party Library","uri":"/2021/04/test-with-3rd-party-library/"},{"categories":["Test"],"content":"解决方案 在构建项目前期，通过各种尝试启动一个支持 import 语法的项目，始终未遂。 最终还是按照 Jest 官网的提示一步步走，构建起了一个项目。 ","date":"2021-04-18","objectID":"/2021/04/test-with-3rd-party-library/:3:0","tags":["test","3rd party test","jest"],"title":"Test With 3rd Party Library","uri":"/2021/04/test-with-3rd-party-library/"},{"categories":["Test"],"content":"参考官网示例 官网示例如下，是一个 mock 有方法的类的，但是通过上面的代码可知，这个不是一个类，而是直接使用的一个方法。 import moduleName, {foo} from '../moduleName'; jest.mock('../moduleName', () =\u003e { return { __esModule: true, default: jest.fn(() =\u003e 42), foo: jest.fn(() =\u003e 43), }; }); moduleName(); // Will return 42 foo(); // Will return 43 很明显这是不符合我么场景的。通过观察可知，jest.mock 的第二参数是工参数，返回了一个对象，然后通过调用个这个对象的方法，返回特定的 mock 数据。 那么对于我们这种情况，我们只需要返回一个 mock 后的方法即可。 so, 方案可整理如下 import jwt_decode from \"jwt-decode\"; jest.mock(\"jwt-decode\", () =\u003e { return jest.fn().mockImplementation(() =\u003e { return \"test\"; }); }); it(\"jwt\", () =\u003e { var token = \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJmb28iOiJiYXIiLCJleHAiOjEzOTMyODY4OTMsImlhdCI6MTM5MzI2ODg5M30.4-iaDojEVl0pJQMjrbM1EzUIfAZgsbK_kgnVyVxFSVo\"; const decoded = jwt_decode(token); expect(decoded).toBe(\"test\"); }); 然后运行 test，通过。 Code 地址：https://github.com/guzhongren/awesome-unittest/tree/main/JavaScript/Frontend/src/3rd-part-test ","date":"2021-04-18","objectID":"/2021/04/test-with-3rd-party-library/:3:1","tags":["test","3rd party test","jest"],"title":"Test With 3rd Party Library","uri":"/2021/04/test-with-3rd-party-library/"},{"categories":["Test"],"content":"Refs 博客：https://guzhongren.github.io/ ","date":"2021-04-18","objectID":"/2021/04/test-with-3rd-party-library/:4:0","tags":["test","3rd party test","jest"],"title":"Test With 3rd Party Library","uri":"/2021/04/test-with-3rd-party-library/"},{"categories":["Test"],"content":"Disclaimer 本文仅代表个人观点，与 Thoughtworks 公司无任何关系。 SHA256 checksum: f2fe1394e4ab9297ed69ff73ac32e9ac1375f01c2102183b509bf9379a5995d6 ","date":"2021-04-18","objectID":"/2021/04/test-with-3rd-party-library/:5:0","tags":["test","3rd party test","jest"],"title":"Test With 3rd Party Library","uri":"/2021/04/test-with-3rd-party-library/"},{"categories":["Test"],"content":"赞助 SHA256 checksum: 964978ecd2059064abe542e51dc02e204d3ee2e6c320ca68e2b1399ce0c6953c 使用此 文件 进行校验： gpg --verify PayForGuzhongren.svg.sig ","date":"2021-04-18","objectID":"/2021/04/test-with-3rd-party-library/:6:0","tags":["test","3rd party test","jest"],"title":"Test With 3rd Party Library","uri":"/2021/04/test-with-3rd-party-library/"},{"categories":["Auth"],"content":"简介 GPG 是开源免费的身份验证工具，简单一句话就是对于公钥使用者可以和密钥拥有者秘密通信；对于密钥使用者，可以像外界证明某句话是你说的；在现实场景中，你可以写了一份信，但是大家怎么知道这份信是你写的呢？如果你身边有熟悉你的人，那 TA 可以通过你的笔迹或者你家生产的信纸来知道这份信是你的，但是对于别人呢？他们对你不了解，所以他们很难证明：你就是你？ 在程序的世界里，你身边都是陌生人，怎么证明你就是你？一般都使用公钥私钥的非对称加密算法。在网上有很多关于 GPG 和 Github 结合的说明，比如 GitHub 官网的 Doc; 最重要的另一件事是备份你的公钥和密钥。 ","date":"2021-04-10","objectID":"/2021/04/%E5%AF%BC%E5%87%BA%E5%B9%B6%E4%BF%9D%E5%AD%98gpg%E5%85%AC%E5%AF%86%E9%92%A5/:1:0","tags":["GPG","公钥","密钥","保存","Auth","security"],"title":"导出并保存 GPG 公密钥","uri":"/2021/04/%E5%AF%BC%E5%87%BA%E5%B9%B6%E4%BF%9D%E5%AD%98gpg%E5%85%AC%E5%AF%86%E9%92%A5/"},{"categories":["Auth"],"content":"备份 ","date":"2021-04-10","objectID":"/2021/04/%E5%AF%BC%E5%87%BA%E5%B9%B6%E4%BF%9D%E5%AD%98gpg%E5%85%AC%E5%AF%86%E9%92%A5/:2:0","tags":["GPG","公钥","密钥","保存","Auth","security"],"title":"导出并保存 GPG 公密钥","uri":"/2021/04/%E5%AF%BC%E5%87%BA%E5%B9%B6%E4%BF%9D%E5%AD%98gpg%E5%85%AC%E5%AF%86%E9%92%A5/"},{"categories":["Auth"],"content":"列出公钥 ❯ gpg --list-secret-keys --keyid-format LONG /Users/c4/.gnupg/pubring.kbx ---------------------------- sec rsa4096/XXXXXXXXXXXXXX 2021-04-10 [SC] XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX uid [ 绝对 ] user（仅用来签名 git, message) \u003cuser@email.com\u003e ssb rsa4096/202XXXXXXXXXXXXX 2021-04-10 [E] sec 下面的第二行 也就是所有字符都是 X 的那一行就是 keyId; ","date":"2021-04-10","objectID":"/2021/04/%E5%AF%BC%E5%87%BA%E5%B9%B6%E4%BF%9D%E5%AD%98gpg%E5%85%AC%E5%AF%86%E9%92%A5/:2:1","tags":["GPG","公钥","密钥","保存","Auth","security"],"title":"导出并保存 GPG 公密钥","uri":"/2021/04/%E5%AF%BC%E5%87%BA%E5%B9%B6%E4%BF%9D%E5%AD%98gpg%E5%85%AC%E5%AF%86%E9%92%A5/"},{"categories":["Auth"],"content":"导出公钥 ❯ gpg -a -o public-file.key --export keyId -a 为 –armor 的简写，表示密钥以 ASCII 的形式输出，默认以二进制的形式输出； -o 为 –output 的简写，指定写入的文件； 导出会有一个 public-file.key 在当前目录下生成，里面存放你的公钥。 ","date":"2021-04-10","objectID":"/2021/04/%E5%AF%BC%E5%87%BA%E5%B9%B6%E4%BF%9D%E5%AD%98gpg%E5%85%AC%E5%AF%86%E9%92%A5/:2:2","tags":["GPG","公钥","密钥","保存","Auth","security"],"title":"导出并保存 GPG 公密钥","uri":"/2021/04/%E5%AF%BC%E5%87%BA%E5%B9%B6%E4%BF%9D%E5%AD%98gpg%E5%85%AC%E5%AF%86%E9%92%A5/"},{"categories":["Auth"],"content":"导出私钥 ❯ gpg -a -o private-file.key --export-secret-keys keyId 导出一个私钥 private-file.key. ","date":"2021-04-10","objectID":"/2021/04/%E5%AF%BC%E5%87%BA%E5%B9%B6%E4%BF%9D%E5%AD%98gpg%E5%85%AC%E5%AF%86%E9%92%A5/:2:3","tags":["GPG","公钥","密钥","保存","Auth","security"],"title":"导出并保存 GPG 公密钥","uri":"/2021/04/%E5%AF%BC%E5%87%BA%E5%B9%B6%E4%BF%9D%E5%AD%98gpg%E5%85%AC%E5%AF%86%E9%92%A5/"},{"categories":["Auth"],"content":"导入公钥私钥 ❯ gpg --import xxxx.key xxxx.key 可以是公钥，也可以是私钥。 ","date":"2021-04-10","objectID":"/2021/04/%E5%AF%BC%E5%87%BA%E5%B9%B6%E4%BF%9D%E5%AD%98gpg%E5%85%AC%E5%AF%86%E9%92%A5/:2:4","tags":["GPG","公钥","密钥","保存","Auth","security"],"title":"导出并保存 GPG 公密钥","uri":"/2021/04/%E5%AF%BC%E5%87%BA%E5%B9%B6%E4%BF%9D%E5%AD%98gpg%E5%85%AC%E5%AF%86%E9%92%A5/"},{"categories":["Auth"],"content":"保存 公钥可以放在自己的网站或者信任的服务器上，但是私钥一定要自己保管，千万千万不能泄漏出去。否则在计算机的世界里，人人都可以是你。 推荐将你的公钥和私钥都保存在像1password, lastpassword 或者Bitwarden里，我用的是 bitwarden; 因为不能存文件，只能将公钥和私钥的内容复制并拷贝进去。但效果是一样的。 缓存 在设置了强密码的前提下， 我们可以稍微的牺牲一些安全性， 通过配置 gpg-agent 的 default-cache-ttl， 让我们解密后的私钥在内存中存在的时间稍微长一些（默认 10 分钟）， 比如， 一天： #~/.gnupg/gpg-agent.conf default-cache-ttl-ssh 86400 max-cache-ttl-ssh 86400 ","date":"2021-04-10","objectID":"/2021/04/%E5%AF%BC%E5%87%BA%E5%B9%B6%E4%BF%9D%E5%AD%98gpg%E5%85%AC%E5%AF%86%E9%92%A5/:2:5","tags":["GPG","公钥","密钥","保存","Auth","security"],"title":"导出并保存 GPG 公密钥","uri":"/2021/04/%E5%AF%BC%E5%87%BA%E5%B9%B6%E4%BF%9D%E5%AD%98gpg%E5%85%AC%E5%AF%86%E9%92%A5/"},{"categories":["Auth"],"content":"分发 将公钥发送到 CA 管理中间机构，方便别人验证。 ❯ gpg -k /Users/c4/.gnupg/pubring.kbx ---------------------------- pub rsa4096 2021-04-11 [SC] 3D4DC54CDDA6FAFDD13A4970D18Axxxxxxxxxx uid [ 绝对 ] guzhongren (used for git\u0026message) \u003cguzhongren@live.cn\u003e sub rsa4096 2021-04-11 [E] ❯ gpg --send-key 3D4DC54CDDA6FAFDD13A4970D18Axxxxxxxxxx ","date":"2021-04-10","objectID":"/2021/04/%E5%AF%BC%E5%87%BA%E5%B9%B6%E4%BF%9D%E5%AD%98gpg%E5%85%AC%E5%AF%86%E9%92%A5/:3:0","tags":["GPG","公钥","密钥","保存","Auth","security"],"title":"导出并保存 GPG 公密钥","uri":"/2021/04/%E5%AF%BC%E5%87%BA%E5%B9%B6%E4%BF%9D%E5%AD%98gpg%E5%85%AC%E5%AF%86%E9%92%A5/"},{"categories":["Auth"],"content":"⚠️ 注意 你的私钥差不多就是计算机世界里的另一个你，所以，把你自己保护好。 ","date":"2021-04-10","objectID":"/2021/04/%E5%AF%BC%E5%87%BA%E5%B9%B6%E4%BF%9D%E5%AD%98gpg%E5%85%AC%E5%AF%86%E9%92%A5/:4:0","tags":["GPG","公钥","密钥","保存","Auth","security"],"title":"导出并保存 GPG 公密钥","uri":"/2021/04/%E5%AF%BC%E5%87%BA%E5%B9%B6%E4%BF%9D%E5%AD%98gpg%E5%85%AC%E5%AF%86%E9%92%A5/"},{"categories":["Auth"],"content":"Refs 博客：https://guzhongren.github.io/ ","date":"2021-04-10","objectID":"/2021/04/%E5%AF%BC%E5%87%BA%E5%B9%B6%E4%BF%9D%E5%AD%98gpg%E5%85%AC%E5%AF%86%E9%92%A5/:5:0","tags":["GPG","公钥","密钥","保存","Auth","security"],"title":"导出并保存 GPG 公密钥","uri":"/2021/04/%E5%AF%BC%E5%87%BA%E5%B9%B6%E4%BF%9D%E5%AD%98gpg%E5%85%AC%E5%AF%86%E9%92%A5/"},{"categories":["Auth"],"content":"Disclaimer 本文仅代表个人观点，与 Thoughtworks 公司无任何关系。 SHA256 checksum: f2fe1394e4ab9297ed69ff73ac32e9ac1375f01c2102183b509bf9379a5995d6 ","date":"2021-04-10","objectID":"/2021/04/%E5%AF%BC%E5%87%BA%E5%B9%B6%E4%BF%9D%E5%AD%98gpg%E5%85%AC%E5%AF%86%E9%92%A5/:6:0","tags":["GPG","公钥","密钥","保存","Auth","security"],"title":"导出并保存 GPG 公密钥","uri":"/2021/04/%E5%AF%BC%E5%87%BA%E5%B9%B6%E4%BF%9D%E5%AD%98gpg%E5%85%AC%E5%AF%86%E9%92%A5/"},{"categories":["Auth"],"content":"赞助 SHA256 checksum: 964978ecd2059064abe542e51dc02e204d3ee2e6c320ca68e2b1399ce0c6953c 使用此 文件 进行校验： gpg --verify PayForGuzhongren.svg.sig ","date":"2021-04-10","objectID":"/2021/04/%E5%AF%BC%E5%87%BA%E5%B9%B6%E4%BF%9D%E5%AD%98gpg%E5%85%AC%E5%AF%86%E9%92%A5/:7:0","tags":["GPG","公钥","密钥","保存","Auth","security"],"title":"导出并保存 GPG 公密钥","uri":"/2021/04/%E5%AF%BC%E5%87%BA%E5%B9%B6%E4%BF%9D%E5%AD%98gpg%E5%85%AC%E5%AF%86%E9%92%A5/"},{"categories":["Test"],"content":"什么是性能测试 性能测试是一种软件测试过程，用于测试特定工作负载下软件应用程序的速度、响应时间、稳定性、可靠性、可伸缩性和资源使用情况。性能测试的主要目的是识别和消除软件应用程序中的性能瓶颈。它是性能工程的一个子集，也被称为\"Perf Testing\"。 性能测试的重点是检查软件程序的以下几个性能： 速度 ——确定应用程序是否快速响应 可伸缩性——确定软件应用程序能够处理的最大用户负载 稳定性 –确定应用程序在变化的负载下是否稳定 ","date":"2021-04-03","objectID":"/2021/04/%E5%88%9D%E6%8E%A2%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/:1:0","tags":["性能测试","性能","翻译"],"title":"[翻译] 初探性能测试","uri":"/2021/04/%E5%88%9D%E6%8E%A2%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"categories":["Test"],"content":"为什么要做性能测试 软件系统支持的特性和功能并不是唯一的关注点。软件应用程序的性能，如响应时间、可靠性、资源使用和可伸缩性都很重要。性能测试的目标不是发现 bug，而是消除性能瓶颈。 进行性能测试是为了向涉众提供有关其应用程序的速度、稳定性和可伸缩性方面的信息。更重要的是，性能测试揭示了在产品进入市场之前需要改进的地方。如果没有性能测试，软件很可能会遇到这样的问题：几个用户同时使用时运行缓慢，不同操作系统之间的不一致性以及易用性差。 性能测试将确定他们的软件在预期的工作负载下是否满足速度、可伸缩性和稳定性要求。由于不存在或糟糕的性能测试而将性能指标较差的应用程序发送到市场上，可能会获得坏名声，无法达到预期的销售目标等。 此外，诸如太空发射计划或救生医疗设备等关键任务应用程序应进行性能测试，以确保它们能够长期运行而无偏差。 据 Dunn \u0026 Bradstreet 公司统计，59%的财富 500 强公司每周的停机时间估计为 1.6 小时。考虑到拥有至少 1 万名员工的《财富》500 强公司的平均工资是每小时 56 美元，这样的组织的停工部分的劳动成本将是每周 89.6 万美元，换算成每年超过 4600 万美元。 据估计，Google.com(8 月 19 日至 13 日）仅 5 分钟的停机时间就会给这家搜索巨头带来 54.5 万美元的损失。 另外，由于最近一次亚马逊网络服务中断，公司每秒损失了价值 1100 美元的销售额。 鉴于此，性能测试在保障服务可用性等方面真的很重要。 ","date":"2021-04-03","objectID":"/2021/04/%E5%88%9D%E6%8E%A2%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/:2:0","tags":["性能测试","性能","翻译"],"title":"[翻译] 初探性能测试","uri":"/2021/04/%E5%88%9D%E6%8E%A2%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"categories":["Test"],"content":"性能测试的类型 负载测试 ——检查应用程序在预期用户负载下的执行能力。目标是在软件应用程序运行之前识别性能瓶颈。 压力测试 ——包括在极端工作负载下测试应用程序，以了解它如何处理高流量或数据处理。目标是识别应用程序的极限。 耐久性测 ——是为了确保软件能够在很长一段时间内处理预期的负载。 峰值测试 ——测试软件对用户产生的突然的负载峰值的反应。 体积测试 ——在大量测试数据被填充到数据库下，监测整个软件系统的行为。目标是检查软件应用程序在不同数据库容量下的性能。 可伸缩性测试——可伸缩性测试的目标是确定软件应用程序在“扩展”以支持用户负载增加方面的有效性。它有助于规划软件系统的容量。 ","date":"2021-04-03","objectID":"/2021/04/%E5%88%9D%E6%8E%A2%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/:3:0","tags":["性能测试","性能","翻译"],"title":"[翻译] 初探性能测试","uri":"/2021/04/%E5%88%9D%E6%8E%A2%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"categories":["Test"],"content":"常见的性能问题 大多数性能问题都与速度、响应时间、加载时间和较差的可伸缩性有关。速度通常是应用程序最重要的属性之一。运行缓慢的应用程序将失去潜在的用户。性能测试是为了确保应用运行速度足以吸引用户的注意和兴趣。看看下面的常见性能问题列表，并注意到速度是其中的一个常见因素： 加载时间长——加载时间通常是应用程序启动的初始时间。这通常应该保持在最低限度。虽然有些应用程序不可能在一分钟内完成加载，但加载时间应该尽可能保持在几秒钟以内。 响应时间短——响应时间是从用户向应用程序输入数据到应用程序输出对该输入的响应所花费的时间。一般来说，这应该很快。如果用户等待的时间过长，他们就会失去兴趣。 可伸缩性差——当软件产品不能处理预期的用户数量或不能容纳足够大的用户范围时，它就会受到可伸缩性差的困扰。应该进行负载测试，以确定应用程序能够处理预期的用户数量。 瓶颈-瓶颈是系统中会降低整体系统性能的障碍。瓶颈是编码错误或硬件问题导致在特定负载下吞吐量下降。瓶颈通常是由一个错误的代码部分引起的。修复瓶颈问题的关键是找到导致放缓的代码部分，并尝试修复它。瓶颈通常可以通过修复运行不良的进程或添加额外的硬件来解决。一些常见的性能瓶颈是： CPU 利用率 内存利用率 网络利用率 操作系统限制 磁盘使用情况 ","date":"2021-04-03","objectID":"/2021/04/%E5%88%9D%E6%8E%A2%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/:4:0","tags":["性能测试","性能","翻译"],"title":"[翻译] 初探性能测试","uri":"/2021/04/%E5%88%9D%E6%8E%A2%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"categories":["Test"],"content":"性能测试过程 为性能测试所采用的方法可能有很大的不同，但是性能测试的目标是相同的。它可以帮助证明您的软件系统满足某些预先定义的性能标准。或者它可以帮助比较两个软件系统的性能。它还可以帮助识别降低软件系统性能的部分。 下面是关于如何执行性能测试的一般流程： 确定您的测试环境 —— 了解您的物理测试环境、生产环境以及可用的测试工具。在开始测试过程之前，请了解测试过程中使用的硬件、软件和网络配置的详细信息。它将帮助测试人员创建更有效的测试。它还将帮助识别测试人员在性能测试过程中可能遇到的挑战。 确定性能验收标准 —— 这包括吞吐量、响应时间和资源分配的目标和约束。在这些目标和约束之外确定项目成功的标准也是必要的。测试人员应该被授权设置性能标准和目标，因为项目规范通常不会包括足够广泛的性能基准。有时可能根本没有。如果可能，找到一个类似的应用程序进行比较是设置性能目标的好方法。 计划和设计性能测试 —— 确定最终用户的使用可能如何变化，并确定测试所有可能用例的关键场景。模拟各种终端用户、计划性能测试数据并概述将要收集的度量标准是必要的。 配置测试环境—— 执行前准备测试环境。同时，安排工具和其他资源。 执行测试设计 —— 根据测试设计创建性能测试。 运行测试 – 执行和监视测试。 分析，调整和重新测试-合并，分析和共享测试结果。然后进行微调并再次测试，看看性能是否有改善或下降。由于每次重新测试的改进通常都会变小，所以当瓶颈是由 CPU 引起时就停止。然后，您可以考虑增加 CPU 功率。 ","date":"2021-04-03","objectID":"/2021/04/%E5%88%9D%E6%8E%A2%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/:5:0","tags":["性能测试","性能","翻译"],"title":"[翻译] 初探性能测试","uri":"/2021/04/%E5%88%9D%E6%8E%A2%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"categories":["Test"],"content":"性能测试指标：参数监测 在性能测试期间监视的基本参数包括： 处理器使用 (Processor Usage)——处理器执行非空闲线程所花费的时间。 内存使用 (Memory use)——计算机上进程可用的物理内存总量。 磁盘时间 (Disk time)——磁盘忙于执行读或写请求的时间。 带宽 (Bandwidth)——显示一个网络接口每秒使用的比特数。 私有字节数 (Private bytes)——一个进程分配的不能被其他进程共享的字节数。它们用于测量内存泄漏和使用情况。 已提交内存量 (Committed memory)——使用的虚拟内存量。 内存页数/秒 (Memory pages/second)–写入磁盘或从磁盘读取以解决硬页错误的页数。 硬页错误是指从其他位置调用不是来自当前工作集的代码并从磁盘中检索到的代码。 页面故障数/秒 (Page faults/second)—–处理器处理故障页面的总速率。 当流程需要来自其工作集之外的代码时，会再次发生这种情况。 CPU 每秒中断数 (CPU interrupts per second)———是一个处理器每秒接收和处理的硬件中断数的平均值。 磁盘队列长度 (Disk queue length)–为平均长度。在采样间隔内对选定磁盘排队的读和写请求的值。 网络输出队列长度 (Network output queue length)——报文输出队列的长度。如果超过两个，就意味着需要停止延误和瓶颈。 网络字节每秒总数 (Network bytes total per second)——在接口上发送和接收的字节的速率，包括分帧字符。 响应时间 (Response time)——从用户输入请求到收到响应的第一个字符的时间。 吞吐量 (Throughput)–计算机或网络每秒接收请求的速率。 连接池的数量 (Amount of connection pooling)–池连接所满足的用户请求的数量。池中的连接满足的请求越多，性能就越好。 最大激活会话数 (Maximum active sessions)–次可以激活的最大会话数。 命中率 (Hit ratios)——这与缓存数据处理 SQL 语句的数量有关，而不是昂贵的 I/O 操作。这是解决瓶颈问题的好起点。 每秒点击次数 (Hits per second)–在负载测试中，每秒钟在 web 服务器上的点击量。 回滚段 (Rollback segment)——在任何时间点都可以回滚的数据量。 数据库锁定 (Database locks)——表和数据库的锁定需要被监视和仔细调优。 顶级等待 (Top waits)——监视以确定在处理从内存检索数据的速度时可以减少哪些等待时间 线程计数 (Thread counts)——应用程序运行状况可以通过编号进行度量。正在运行且当前处于活动状态的线程。 垃圾回收 (Garbage collectio)——它与将未使用的内存返回给系统有关。需要监控垃圾收集的效率。 ","date":"2021-04-03","objectID":"/2021/04/%E5%88%9D%E6%8E%A2%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/:6:0","tags":["性能测试","性能","翻译"],"title":"[翻译] 初探性能测试","uri":"/2021/04/%E5%88%9D%E6%8E%A2%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"categories":["Test"],"content":"性能测试案例 当 1000 个用户同时访问网站时，验证响应时间不超过 4 秒。 当网络连接较慢时，验证负载下应用程序的响应时间在可接受的范围内 检查应用程序在崩溃前可以处理的最大用户数。 当同时读写 500 条记录时，请检查数据库执行时间。 检查高峰负载条件下应用程序和数据库服务器的 CPU 和内存使用情况 验证应用程序在低、正常、中等和高负载条件下的响应时间。 在实际的性能测试执行过程中，模糊的术语如可接受范围、重载等被具体的数字所取代。性能工程师根据业务需求和应用程序的技术前景来设置这些数字。 ","date":"2021-04-03","objectID":"/2021/04/%E5%88%9D%E6%8E%A2%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/:7:0","tags":["性能测试","性能","翻译"],"title":"[翻译] 初探性能测试","uri":"/2021/04/%E5%88%9D%E6%8E%A2%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"categories":["Test"],"content":"性能测试工具 市场上有各种各样的性能测试工具。您选择的测试工具将取决于许多因素，如支持的协议类型、许可证成本、硬件要求、平台支持等。下面是一些常用的测试工具。 LoadNinja 是一个革命性的加载测试的方式的工具。这个基于云的负载测试工具使团队能够记录和即时回放全面的负载测试，无需复杂的动态关联，并在真实的浏览器中大规模运行这些负载测试。团队能够增加测试覆盖率。将负载测试时间减少 60%以上。 HP LoadRunner -是当今市场上最流行的性能测试工具。该工具能够模拟成千上万的用户，将应用程序置于真实的负载下，以确定它们在预期负载下的行为。Loadrunner 有一个虚拟用户生成器，可以模拟真人用户的动作。 Jmeter ——用于 web 和应用服务器负载测试的主要工具之一。 ","date":"2021-04-03","objectID":"/2021/04/%E5%88%9D%E6%8E%A2%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/:8:0","tags":["性能测试","性能","翻译"],"title":"[翻译] 初探性能测试","uri":"/2021/04/%E5%88%9D%E6%8E%A2%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"categories":["Test"],"content":"FAQ ","date":"2021-04-03","objectID":"/2021/04/%E5%88%9D%E6%8E%A2%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/:9:0","tags":["性能测试","性能","翻译"],"title":"[翻译] 初探性能测试","uri":"/2021/04/%E5%88%9D%E6%8E%A2%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"categories":["Test"],"content":"我们应该对哪些应用程序进行性能测试？ 性能测试总是只针对基于客户机-服务器的系统。这意味着，任何不是基于客户机-服务器架构的应用程序都不需要性能测试。 例如，微软计算器既不是基于客户机-服务器，也不是运行多个用户；因此，它不是性能测试的候选对象。 ","date":"2021-04-03","objectID":"/2021/04/%E5%88%9D%E6%8E%A2%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/:9:1","tags":["性能测试","性能","翻译"],"title":"[翻译] 初探性能测试","uri":"/2021/04/%E5%88%9D%E6%8E%A2%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"categories":["Test"],"content":"性能测试和性能工程的区别是什么 理解性能测试与性能工程的区别具有重要意义。达成以下共识： 性能测试是一门与测试和报告软件应用程序在各种参数下的当前性能有关的学科。 性能工程是为了实现所需的性能而对软件进行测试和调优的过程。这个过程旨在优化最重要的应用性能特征，即用户体验。 从历史上看，测试和调优一直是截然分开的、经常相互竞争的领域。然而，在过去的几年里，一些测试人员和开发人员已经独立合作创建了调优团队。由于这些团队已经取得了巨大的成功，将性能测试与性能调优相结合的概念已经流行起来，现在我们称之为性能工程。 ","date":"2021-04-03","objectID":"/2021/04/%E5%88%9D%E6%8E%A2%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/:9:2","tags":["性能测试","性能","翻译"],"title":"[翻译] 初探性能测试","uri":"/2021/04/%E5%88%9D%E6%8E%A2%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"categories":["Test"],"content":"结论 在软件工程中，在任何软件产品上市之前，性能测试都是必要的。它确保了客户的满意度，保护投资者的投资不受产品失败的影响。性能测试的成本通常可以通过提高客户满意度、忠诚度和保留度来弥补。 ","date":"2021-04-03","objectID":"/2021/04/%E5%88%9D%E6%8E%A2%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/:10:0","tags":["性能测试","性能","翻译"],"title":"[翻译] 初探性能测试","uri":"/2021/04/%E5%88%9D%E6%8E%A2%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"categories":["Test"],"content":"Refs 博客：https://guzhongren.github.io/ Performance Testing Tutorial: What is, Types, Metrics \u0026 Example: https://www.guru99.com/performance-testing.html ","date":"2021-04-03","objectID":"/2021/04/%E5%88%9D%E6%8E%A2%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/:11:0","tags":["性能测试","性能","翻译"],"title":"[翻译] 初探性能测试","uri":"/2021/04/%E5%88%9D%E6%8E%A2%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"categories":["Test"],"content":"Disclaimer 本文仅代表个人观点，与 Thoughtworks 公司无任何关系。 ","date":"2021-04-03","objectID":"/2021/04/%E5%88%9D%E6%8E%A2%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/:12:0","tags":["性能测试","性能","翻译"],"title":"[翻译] 初探性能测试","uri":"/2021/04/%E5%88%9D%E6%8E%A2%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"categories":["碎碎念"],"content":"最近忙完了结婚大事，按计划接下来要开始装修房子了，那么第一件事就是找个容身之地-租房。在陪着媳妇逛了太白南路的两个房子和航天城那边的一个房子，又约了装修公司来家里看情况，半天下来累的都不想动了。然而之前联系的一个小哥，给我们推荐了朱雀大街上的一个酒店式公寓。在媳妇的催促下，只好抱着试试看的心态去看房。 到了酒店的房间，进去之后，看着环境还不错，在我看来还有点犹豫，三个人在房间里僵持了半个多小时，在我们看来也没得好的选择了，就说这个吧，然后就准备去最近的贝壳旗下的店面去签约，在路上，在经理人的怂恿下，给房东交了 500 块钱的定金，还是订金。然后在随便找的一个店里经过了各种麻烦的操作终于签订了合同，接下来就是最后一步，收房。 时间已经到了晚上 8:30 左右，天黑了，酒店里住的各式各样的人也回来了。刚到租的房子的那一层，就听到楼上在弹钢琴，我们一听，这要是以后每天都这样能行？然后就直接说，我们要解约，不租了，让贝壳这边解约，贝壳的经纪人说他会解决，然后我跟着他上了 7 楼，找到了弹钢琴的那家，然后敲了门，说了几句晚上弹琴会影响别人休息的话，人家也不弹了。我们就回房间了。 过了一会，我们刚才敲了人家门的那个人下来了，说了几句了解到，人家是音乐学院的老师，第二天有学生的课，在备课。抱怨了几句之后，重点戏来了，人家说，往年高考的时候有人大晚上的一直弹琴到睡觉，甚至，凌晨 3，4 点弹琴，唱歌的人都比比皆是。 一听到这，我们解约的心肯定是铁定的了，经纪人给房东打电话，然而房东说只给退三个月的租金，因为我们连押金一共交了 8 个月的房租，加上中介退的中介费，合起来要损失 4 个月，我们肯定呀。房子一天没住，就要损失 1800*4 个月的钱，感觉被抢劫了。 房东是个爱旅游的人，打电话过去一会说半小时后联系，一会 15 分钟后联系，完全就是大爷的姿态，说起退房租，人家还说，”房子刚租出去就退，你玩我呢“，态度强硬的不行。 那么对于这件事，作为租房者，我们感觉太委屈了。 租房的时候中介没人跟我们说，这地方音乐学院的人比较多，晚上会比较吵，从头到尾，没人提一个字。 我们还没有拿钥匙，我们要解约，中介都同意了，房东你再牛逼，合同上也只是说，扣留一个月的房租，凭什么要扣我 4 个月的房租。 打电话给贝壳投诉，人家接电话的就是个记录的，说联系解决，其实什么都不干，不解决问题，就是个传话筒。 你说上诉，人家才不怕呢，房东已经收到钱了，钱在人家的口袋里；贝壳，人家只是中介，大公司，怕你一个小楼楼？上诉，不拖个半年一年的，法院会给你办？前期上诉的费用还得自己出，更何况还要浪费自己的时间去做笔录，接受询问等等的。 ","date":"2021-03-24","objectID":"/2021/03/%E7%A7%9F%E6%88%BF%E4%B9%8B%E5%BC%B1%E5%8A%BF%E7%BE%A4%E4%BD%93/:0:0","tags":["租房","弱势群里","中介","法律"],"title":"租房之弱势群体","uri":"/2021/03/%E7%A7%9F%E6%88%BF%E4%B9%8B%E5%BC%B1%E5%8A%BF%E7%BE%A4%E4%BD%93/"},{"categories":["碎碎念"],"content":"建议 以后租房，还是要学聪明点。 要是要在繁华闹市或者学校附近租房，一定要白天去瞅一瞅，晚上再瞅一瞅，毕竟人生都百态呢，更何况是你控制不了的别人的环境 拿不定注意的时候不要做决定，任凭经纪人说过会，马上有人就要来看房了，要不你先叫个定（订）金之类的，经纪人就是拿这话来让你花钱的 对于所有的事物，尽量能拍照的时候拍照，能录音的时候录音，避免解约或者打官司的时候找不到证据 干房地产的这帮人，就是一群唯利是图的家伙，绝对不能把 ta 当朋友。你想买房，你就是大爷，你不买房了，你就是孙子，甚至连孙子都不如 多学点法律知识，干什么事都要有合同，要有验收标准，自己的钱只能到最后才能给别人。不然你就会成为下一个孙子。 ","date":"2021-03-24","objectID":"/2021/03/%E7%A7%9F%E6%88%BF%E4%B9%8B%E5%BC%B1%E5%8A%BF%E7%BE%A4%E4%BD%93/:1:0","tags":["租房","弱势群里","中介","法律"],"title":"租房之弱势群体","uri":"/2021/03/%E7%A7%9F%E6%88%BF%E4%B9%8B%E5%BC%B1%E5%8A%BF%E7%BE%A4%E4%BD%93/"},{"categories":["碎碎念"],"content":"Refs 博客：https://guzhongren.github.io/ ","date":"2021-03-24","objectID":"/2021/03/%E7%A7%9F%E6%88%BF%E4%B9%8B%E5%BC%B1%E5%8A%BF%E7%BE%A4%E4%BD%93/:2:0","tags":["租房","弱势群里","中介","法律"],"title":"租房之弱势群体","uri":"/2021/03/%E7%A7%9F%E6%88%BF%E4%B9%8B%E5%BC%B1%E5%8A%BF%E7%BE%A4%E4%BD%93/"},{"categories":["碎碎念"],"content":"Disclaimer 本文仅代表个人观点，与 Thoughtworks 公司无任何关系。 ","date":"2021-03-24","objectID":"/2021/03/%E7%A7%9F%E6%88%BF%E4%B9%8B%E5%BC%B1%E5%8A%BF%E7%BE%A4%E4%BD%93/:3:0","tags":["租房","弱势群里","中介","法律"],"title":"租房之弱势群体","uri":"/2021/03/%E7%A7%9F%E6%88%BF%E4%B9%8B%E5%BC%B1%E5%8A%BF%E7%BE%A4%E4%BD%93/"},{"categories":["Thinking"],"content":"人总是要成长的，尤其在毕业之后，进入社会这所大学，你所有的行为都得自己负责。 最好的方式，就是让自己成长，只有不再犯错或者可以避免犯错，你才有更多的时间和能力去解决更复杂的问题，获得更多的人生财富。以下几个思维方式可以借鉴。 ","date":"2021-02-23","objectID":"/2021/02/%E6%88%90%E9%95%BF%E6%80%A7%E6%80%9D%E7%BB%B4/:0:0","tags":["成长","全局观念","固执","复利"],"title":"成长性思维","uri":"/2021/02/%E6%88%90%E9%95%BF%E6%80%A7%E6%80%9D%E7%BB%B4/"},{"categories":["Thinking"],"content":"全局观念 人往高处走，水往低处流。在程序员这一行，一遍敲代码，一遍搞 升级，是必须的，毕竟你不可能一辈子就只在底层敲代码，和刚入行的小弟弟小妹妹们争夺那简单的几行代码。那么你就得成长，拿面试来说，刚工作那些年你去面试，面试题都考的是基础知识，面试官也问的是基础知识。但是当你工作 5 年以上以后，很难会遇到做面试题的工作，面试官也许是公司的总监，部门经理，亦或是老板，他们关注的不再是技术细节，而是你的到来能为公司带来什么价值。 上面这个案例是抽象的，可以举个🌰，如果你面试的架构师，那么老板们会考察你的抽象能力，设计能力，整合能力和归纳能力，因为只有对全局有了了解的能力才能更好的设计出最合适的架构。 再者，在平时工作中，一般都有上下级关系，而你怎么脱颖而出呢？想象一下，某天你的领导要离职了，公司希望你能顶上，那么你做到什么，或者之前做了设么，公司就会让你当这个领导？想想其实很明显，你要出色完成领导交给你的任务，可以站在公司的角度，帮助他人提升他人能力，可以通过各种形式的方法使公司或者项目获得最大的利益。….. 总结一句话，在其位要不谋其政。想的和做的永远要高于现有的范畴。 ","date":"2021-02-23","objectID":"/2021/02/%E6%88%90%E9%95%BF%E6%80%A7%E6%80%9D%E7%BB%B4/:1:0","tags":["成长","全局观念","固执","复利"],"title":"成长性思维","uri":"/2021/02/%E6%88%90%E9%95%BF%E6%80%A7%E6%80%9D%E7%BB%B4/"},{"categories":["Thinking"],"content":"消除固执 首先要想想，人为什么固执？ 固执，大多数都是由自己的认知不足导致的。导致认知不足的原因有很多，比如从小的家庭观念，见识少。….. 那么怎么消除固执呢？ ","date":"2021-02-23","objectID":"/2021/02/%E6%88%90%E9%95%BF%E6%80%A7%E6%80%9D%E7%BB%B4/:2:0","tags":["成长","全局观念","固执","复利"],"title":"成长性思维","uri":"/2021/02/%E6%88%90%E9%95%BF%E6%80%A7%E6%80%9D%E7%BB%B4/"},{"categories":["Thinking"],"content":"保持开放态度 对所有事要有宽阔的胸怀，让不同的意见在团队或者集体中存在，且不要随意批判。让人人都可以畅所欲言，但要紧扣主题。 多读书，读好书。樊登读书会的樊登说，你是什么样的人是由你周围人决定的，你仅有的思维就代表了你周围人的平均思维，我认为这个观点很对。你的现状是不可能一下改变的，想要有更多思想，你就的接触更多不同思想的人，而你的圈子基本就限制这点很难做到；但是，如果多读书，读上下五千年的书，读国内外的书，这样你就可以随时随地的与拥有不同思想的人打交道了。所谓腹有诗书气自华。 ","date":"2021-02-23","objectID":"/2021/02/%E6%88%90%E9%95%BF%E6%80%A7%E6%80%9D%E7%BB%B4/:2:1","tags":["成长","全局观念","固执","复利"],"title":"成长性思维","uri":"/2021/02/%E6%88%90%E9%95%BF%E6%80%A7%E6%80%9D%E7%BB%B4/"},{"categories":["Thinking"],"content":"复利思维 最近在忙结婚时事，联系婚庆公司就是一个必要环节。 因为婚礼要在老家县城酒店举办，所以就得联系县城周围的婚庆公司。出于程序员思维，所有的事都要列个表，做个 Todo，一件一件的 done 了才算完事。 可是我也是第一次结婚，都不知道婚庆公司有什么服务，就像去饭店吃饭，你第一反应就是看个菜单。联系了婚庆公司，我说能给个你们公司办婚礼的价目表吗？问了两个婚庆公司，没有一个能提供的，有的就是各种小视屏，说所有的内容都可以在他们的朋友圈看到，还有一个更坑的是，他们问，你想要什么服务？听到这话啊，心里的那个🐎呀，我 TM 是第一次办婚礼，我怎么知道有什么服务，有什么环节。 就拿开店或者卖产品来说，你提供服务供顾客选择，如果一个两个客户还好，你可以慢慢解释，但是当你有成千上百万的客户怎么办呢，更何况，客户的需求永远都是各式各样的。 如果有一个菜单或者网站，只要客户有需要，你手一甩，一句话资料都在这，请选择，而你的付出只是整理一份文档或者卖个网站，更简单一点，在某些平台上创建店铺。你可以用省下的时间和精力去做更多更有趣的事。 这就是复利思维，将频繁且固定的内容固化下来，用一个产品去挣所有服务的财富。 ","date":"2021-02-23","objectID":"/2021/02/%E6%88%90%E9%95%BF%E6%80%A7%E6%80%9D%E7%BB%B4/:3:0","tags":["成长","全局观念","固执","复利"],"title":"成长性思维","uri":"/2021/02/%E6%88%90%E9%95%BF%E6%80%A7%E6%80%9D%E7%BB%B4/"},{"categories":["Thinking"],"content":"Refs 博客：https://guzhongren.github.io/ ","date":"2021-02-23","objectID":"/2021/02/%E6%88%90%E9%95%BF%E6%80%A7%E6%80%9D%E7%BB%B4/:4:0","tags":["成长","全局观念","固执","复利"],"title":"成长性思维","uri":"/2021/02/%E6%88%90%E9%95%BF%E6%80%A7%E6%80%9D%E7%BB%B4/"},{"categories":["Thinking"],"content":"Disclaimer 本文仅代表个人观点，与 Thoughtworks 公司无任何关系。 ","date":"2021-02-23","objectID":"/2021/02/%E6%88%90%E9%95%BF%E6%80%A7%E6%80%9D%E7%BB%B4/:5:0","tags":["成长","全局观念","固执","复利"],"title":"成长性思维","uri":"/2021/02/%E6%88%90%E9%95%BF%E6%80%A7%E6%80%9D%E7%BB%B4/"},{"categories":["Thinking"],"content":"Key words 你创造的服务只能满足一小部分人 企业家思维-发现问题，找到解决方案，规模化。 GIS 是个好东西，可惜在现在的传统行业中体现不出它的价值。既不能让大众使用，更不能让大众看，对比最明显的就是红绿灯，敢问哪个 ZF 部门做的 GIS 产品敢投放到群众经常出现的地方。 没有哪个部门敢！因为做的东西不是为了完任务，就是为了捞钱。 敢问哪个传统 GIS 公司敢把公司开发的地址放出来！要在网上传播开来，估计连 C1K 都顶不住。 政府为了完任务，公司为了挣钱，推行用最小的代价糊弄甲方爸爸，只要交差验收了，至于后续。.. 慢慢的传统 GIS 行业就会内卷，那些技术创新都是互联网巨头的事了。传统行业就只能吃别人剩下的了，至于剩下的是什么，自个体会吧。 ","date":"2021-02-19","objectID":"/2021/02/2021-02-insight/:1:0","tags":["Thinking","Insight"],"title":"2021 01 Insight","uri":"/2021/02/2021-02-insight/"},{"categories":["Thinking"],"content":"Refs 博客：https://guzhongren.github.io/ ","date":"2021-02-19","objectID":"/2021/02/2021-02-insight/:2:0","tags":["Thinking","Insight"],"title":"2021 01 Insight","uri":"/2021/02/2021-02-insight/"},{"categories":["Thinking"],"content":"Disclaimer 本文仅代表个人观点，与 Thoughtworks 公司无任何关系。 ","date":"2021-02-19","objectID":"/2021/02/2021-02-insight/:3:0","tags":["Thinking","Insight"],"title":"2021 01 Insight","uri":"/2021/02/2021-02-insight/"},{"categories":["碎碎念"],"content":"疫情 2020 年，魔幻的一年，记得小学一年级的时候有个什么疫情，导致期末都没考试，下学期就直接上了二年级；五年级的时候在外面骑自行车把右胳膊给整折了，又在遇到了非典；接着就是各种国家大事，什么汶川地震，舟曲泥石流。….. 貌似二十一世纪就是多灾多难的一个世纪。 今年疫情，国家提倡高风险不回家，中风险，低风险尽量不回家。 ","date":"2021-01-30","objectID":"/2021/01/%E4%BB%8A%E5%B9%B4%E7%96%AB%E6%83%85%E4%B8%8D%E5%9B%9E%E5%AE%B6/:1:0","tags":["疫情"],"title":"今年疫情不回家","uri":"/2021/01/%E4%BB%8A%E5%B9%B4%E7%96%AB%E6%83%85%E4%B8%8D%E5%9B%9E%E5%AE%B6/"},{"categories":["碎碎念"],"content":"回家？ 对我们来说，不回应该是个明智的选择。 ","date":"2021-01-30","objectID":"/2021/01/%E4%BB%8A%E5%B9%B4%E7%96%AB%E6%83%85%E4%B8%8D%E5%9B%9E%E5%AE%B6/:2:0","tags":["疫情"],"title":"今年疫情不回家","uri":"/2021/01/%E4%BB%8A%E5%B9%B4%E7%96%AB%E6%83%85%E4%B8%8D%E5%9B%9E%E5%AE%B6/"},{"categories":["碎碎念"],"content":"为了安全 坐车回家，各种交通工具，各地区的人，指不定危险就在身边，谁都无法避免“黑天鹅事件”的出现。 ","date":"2021-01-30","objectID":"/2021/01/%E4%BB%8A%E5%B9%B4%E7%96%AB%E6%83%85%E4%B8%8D%E5%9B%9E%E5%AE%B6/:2:1","tags":["疫情"],"title":"今年疫情不回家","uri":"/2021/01/%E4%BB%8A%E5%B9%B4%E7%96%AB%E6%83%85%E4%B8%8D%E5%9B%9E%E5%AE%B6/"},{"categories":["碎碎念"],"content":"替国家着想 从去年武汉疫情开始，国家已经为这个社会付出了太多，没有哪个国家能做到如此。年，年年有，忍一忍，等国家彻底控制住疫情了，没有那么多危险的时候，年年都是年。 小不忍则乱大谋。 ","date":"2021-01-30","objectID":"/2021/01/%E4%BB%8A%E5%B9%B4%E7%96%AB%E6%83%85%E4%B8%8D%E5%9B%9E%E5%AE%B6/:2:2","tags":["疫情"],"title":"今年疫情不回家","uri":"/2021/01/%E4%BB%8A%E5%B9%B4%E7%96%AB%E6%83%85%E4%B8%8D%E5%9B%9E%E5%AE%B6/"},{"categories":["碎碎念"],"content":"嗯。 ","date":"2021-01-30","objectID":"/2021/01/%E4%BB%8A%E5%B9%B4%E7%96%AB%E6%83%85%E4%B8%8D%E5%9B%9E%E5%AE%B6/:2:3","tags":["疫情"],"title":"今年疫情不回家","uri":"/2021/01/%E4%BB%8A%E5%B9%B4%E7%96%AB%E6%83%85%E4%B8%8D%E5%9B%9E%E5%AE%B6/"},{"categories":["碎碎念"],"content":"期望 疫情快点过去吧，就可以休婚假，各种出去嗨了 ","date":"2021-01-30","objectID":"/2021/01/%E4%BB%8A%E5%B9%B4%E7%96%AB%E6%83%85%E4%B8%8D%E5%9B%9E%E5%AE%B6/:3:0","tags":["疫情"],"title":"今年疫情不回家","uri":"/2021/01/%E4%BB%8A%E5%B9%B4%E7%96%AB%E6%83%85%E4%B8%8D%E5%9B%9E%E5%AE%B6/"},{"categories":["碎碎念"],"content":"Refs 博客：https://guzhongren.github.io/ ","date":"2021-01-30","objectID":"/2021/01/%E4%BB%8A%E5%B9%B4%E7%96%AB%E6%83%85%E4%B8%8D%E5%9B%9E%E5%AE%B6/:4:0","tags":["疫情"],"title":"今年疫情不回家","uri":"/2021/01/%E4%BB%8A%E5%B9%B4%E7%96%AB%E6%83%85%E4%B8%8D%E5%9B%9E%E5%AE%B6/"},{"categories":["碎碎念"],"content":"Disclaimer 本文仅代表个人观点，与 Thoughtworks 公司无任何关系。 ","date":"2021-01-30","objectID":"/2021/01/%E4%BB%8A%E5%B9%B4%E7%96%AB%E6%83%85%E4%B8%8D%E5%9B%9E%E5%AE%B6/:5:0","tags":["疫情"],"title":"今年疫情不回家","uri":"/2021/01/%E4%BB%8A%E5%B9%B4%E7%96%AB%E6%83%85%E4%B8%8D%E5%9B%9E%E5%AE%B6/"},{"categories":["Agile"],"content":"缘由 做软件开发，不可避免的事就是用户需求的变化或者细化，和业务的不断迭代，那么对于开发者而言，最重要的事什么呢？我想有一条非常重要：及时将系统中存在的各种 bug，或者遗留问题快速解决。 比如前后端中的软件依赖升级，避免远端大版本升级导致项目需要进行大更改的问题；将系统中原有由 JDBC 实现的 Repository 层由 JPA 实现，提升开发效率，避免手写 SQL 的问题，且可以加快开发效率；再或者项目刚开始，将所有的功能都集中在一个项目中，随着项目的不断扩张，需要将系统的部分功能拆分出来作为一个单独的服务，实现服务的独立发布，部署；并且可以被其他服务消费，减轻原有服务的职责。 ","date":"2021-01-10","objectID":"/2021/01/tech-debt/:1:0","tags":["Agile","Tech debt","debt"],"title":"Tech Debt","uri":"/2021/01/tech-debt/"},{"categories":["Agile"],"content":"Tech debt 是什么 如上描述，在开发中我们会有各种各样的问题存在，在一个迭代里，一方面要实现客户价值，另一方面不能放入太多的技术债卡，所以哪些遗留问题不会被立即解决掉，那么随着时间的流失，遗留问题就会原来越多。 这是优先考虑快速交付而不是完美代码的结果。 Tech debt: 团队为了加快交付速度而降低了代码或者架构层面的良好设计，或者对已有系统缺少更好的设计或测试。 ","date":"2021-01-10","objectID":"/2021/01/tech-debt/:2:0","tags":["Agile","Tech debt","debt"],"title":"Tech Debt","uri":"/2021/01/tech-debt/"},{"categories":["Agile"],"content":"常用方案及设计 明白了什么是 Tech Debt，那么肯定有一些业界的 Best Practice 可以参考，下面列出我设计的方案。 步骤： 收集 分析 形成功能卡 ","date":"2021-01-10","objectID":"/2021/01/tech-debt/:3:0","tags":["Agile","Tech debt","debt"],"title":"Tech Debt","uri":"/2021/01/tech-debt/"},{"categories":["Agile"],"content":"Tech debt 收集 Id Problem description Difficulty[easy, hard] Importance[low, high] Service involved Related resource 1 Upgrade dependences easy high 说明 Problem description: 阐明问题原因，及导致的结果 Difficulty: 解决该问题的困难程度 Importance: 解决该问题后带来的价值 Service involved: 问题所涉及的服务 Related resource: 解决该问题可用的资源 根据上面的表格，组织会议，让大家填写自己所能想到的所有的技术债，然后对每一条技术债进行说明，对齐认识。然后对每一条从 Difficulty 和 Importance 角度进行投票。 分析 在投票完成后需要对所有条目进行梳理分类，可以按照下面的表格进行分类。 ^ I| View result immediately | Split \u0026 Plan m| | p| | o| | r| | t| | a| | n| | c| | e| | | | ------------------------------------------------------------------------------\u003e | | | Fix it if have spare time | Let it go ------------------------------------------------------------------------------\u003e Difficulty 说明： 横轴：从左到右 Difficulty 由简到难； 纵轴：从下到上 Importance 由低到高； Fix it if have spare time: 有时间就修复； View result immediately: 立即处理，因为简单且重要； Split \u0026 Plan: 问题困难并且比较重要，需要拆分并安排进迭代； Let it go： 问题简单但是实现比较困难，有记录就行，如果有时间再实现即可。 ","date":"2021-01-10","objectID":"/2021/01/tech-debt/:3:1","tags":["Agile","Tech debt","debt"],"title":"Tech Debt","uri":"/2021/01/tech-debt/"},{"categories":["Agile"],"content":"产出是什么 对于分析后的问题，按照其所在的不同区域的重要程度，一般需要将Fix it if have spare time, View result immediately和Split \u0026 Plan这三个区域的问题梳理为卡（业务卡，技术卡或者 Bug 卡），分在不同的迭代去做。 ","date":"2021-01-10","objectID":"/2021/01/tech-debt/:4:0","tags":["Agile","Tech debt","debt"],"title":"Tech Debt","uri":"/2021/01/tech-debt/"},{"categories":["Agile"],"content":"模板 介于此制作了一个可以复用的模板。 Tech debt: https://www.figma.com/file/7EzjLtMRXKcaJrGEmudLwC/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1?node-id=181%3A4 ","date":"2021-01-10","objectID":"/2021/01/tech-debt/:5:0","tags":["Agile","Tech debt","debt"],"title":"Tech Debt","uri":"/2021/01/tech-debt/"},{"categories":["Agile"],"content":"Refs 博客：https://guzhongren.github.io/ Technical Debt:https://www.productplan.com/glossary/technical-debt/ Tech debt: https://www.figma.com/file/7EzjLtMRXKcaJrGEmudLwC/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1?node-id=181%3A4 ","date":"2021-01-10","objectID":"/2021/01/tech-debt/:6:0","tags":["Agile","Tech debt","debt"],"title":"Tech Debt","uri":"/2021/01/tech-debt/"},{"categories":["Agile"],"content":"Disclaimer 本文仅代表个人观点，与 Thoughtworks 公司无任何关系。 ","date":"2021-01-10","objectID":"/2021/01/tech-debt/:7:0","tags":["Agile","Tech debt","debt"],"title":"Tech Debt","uri":"/2021/01/tech-debt/"},{"categories":["碎碎念"],"content":"缘起 在 2020 年公司的最后一天 (12 月 29 号），客户也放了圣诞节和新年的假，我们还在公司吭哧吭哧写着代码，因为我们做的是支付相关的业务，这块比较敏感，所以在客户放假期间，禁止一切代码部署到生产环境。而我就在这一天给自己加戏了。 在做关于使用 Sumo Logic 做 Dashboard 的卡，正值下午，感觉没睡醒，因为要在 UAT 环境做测试，不经意间点开了一个 pipeline, 然后点了部署按钮，也没注意，以为是部署到 UAT， 没想到，pipeline 挂了！pipeline 挂了！ 再次跑了一次测试，还是挂了，仔细一看，env: prod? 啊？ 明明跑的 UAT 为撒是 PROD, 内心的那个马啊，此处省去一万字。 然后报告了组里的 TL 兼安全员，按照流程，看了日志，商讨了解决方案，心惊胆战的终于在下班前成功的让 pipeline 绿了。将生产环境的程序部署正确。 ","date":"2021-01-07","objectID":"/2021/01/%E5%86%99%E4%BB%A3%E7%A0%81%E7%9A%84%E7%BB%88%E6%9E%81%E5%A5%A5%E7%A7%98-%E4%BA%BA%E6%98%AF%E4%B8%8D%E5%8F%AF%E4%BF%A1%E7%9A%84/:1:0","tags":["生产事故"],"title":"写代码的终极奥秘 人是不可信的","uri":"/2021/01/%E5%86%99%E4%BB%A3%E7%A0%81%E7%9A%84%E7%BB%88%E6%9E%81%E5%A5%A5%E7%A7%98-%E4%BA%BA%E6%98%AF%E4%B8%8D%E5%8F%AF%E4%BF%A1%E7%9A%84/"},{"categories":["碎碎念"],"content":"事发生了，下次怎么避免呢 ","date":"2021-01-07","objectID":"/2021/01/%E5%86%99%E4%BB%A3%E7%A0%81%E7%9A%84%E7%BB%88%E6%9E%81%E5%A5%A5%E7%A7%98-%E4%BA%BA%E6%98%AF%E4%B8%8D%E5%8F%AF%E4%BF%A1%E7%9A%84/:2:0","tags":["生产事故"],"title":"写代码的终极奥秘 人是不可信的","uri":"/2021/01/%E5%86%99%E4%BB%A3%E7%A0%81%E7%9A%84%E7%BB%88%E6%9E%81%E5%A5%A5%E7%A7%98-%E4%BA%BA%E6%98%AF%E4%B8%8D%E5%8F%AF%E4%BF%A1%E7%9A%84/"},{"categories":["碎碎念"],"content":"不要相信自己 再拿上面这件事说，客户都 code freeze 了，但我们作为人并不能通过管理自己来达到不能部署代码到生产环境这种事，但是工具可以，只要设定了，工具就回毫无疑问，毫无感情的执行。 ","date":"2021-01-07","objectID":"/2021/01/%E5%86%99%E4%BB%A3%E7%A0%81%E7%9A%84%E7%BB%88%E6%9E%81%E5%A5%A5%E7%A7%98-%E4%BA%BA%E6%98%AF%E4%B8%8D%E5%8F%AF%E4%BF%A1%E7%9A%84/:2:1","tags":["生产事故"],"title":"写代码的终极奥秘 人是不可信的","uri":"/2021/01/%E5%86%99%E4%BB%A3%E7%A0%81%E7%9A%84%E7%BB%88%E6%9E%81%E5%A5%A5%E7%A7%98-%E4%BA%BA%E6%98%AF%E4%B8%8D%E5%8F%AF%E4%BF%A1%E7%9A%84/"},{"categories":["碎碎念"],"content":"不要相信别人 你可以相信自己，知道自己工作的每一个步骤，每一个文件的权限，但是别人呢，别人不一定和你对项目的认知在一个水平线上，这就决定了你们的项目存在不确定性。 ","date":"2021-01-07","objectID":"/2021/01/%E5%86%99%E4%BB%A3%E7%A0%81%E7%9A%84%E7%BB%88%E6%9E%81%E5%A5%A5%E7%A7%98-%E4%BA%BA%E6%98%AF%E4%B8%8D%E5%8F%AF%E4%BF%A1%E7%9A%84/:2:2","tags":["生产事故"],"title":"写代码的终极奥秘 人是不可信的","uri":"/2021/01/%E5%86%99%E4%BB%A3%E7%A0%81%E7%9A%84%E7%BB%88%E6%9E%81%E5%A5%A5%E7%A7%98-%E4%BA%BA%E6%98%AF%E4%B8%8D%E5%8F%AF%E4%BF%A1%E7%9A%84/"},{"categories":["碎碎念"],"content":"结论 人是不可信的 不管是你，还是别人，对于写代码这事都别相信。 你写的代码，做的配置都是最优的。 ","date":"2021-01-07","objectID":"/2021/01/%E5%86%99%E4%BB%A3%E7%A0%81%E7%9A%84%E7%BB%88%E6%9E%81%E5%A5%A5%E7%A7%98-%E4%BA%BA%E6%98%AF%E4%B8%8D%E5%8F%AF%E4%BF%A1%E7%9A%84/:3:0","tags":["生产事故"],"title":"写代码的终极奥秘 人是不可信的","uri":"/2021/01/%E5%86%99%E4%BB%A3%E7%A0%81%E7%9A%84%E7%BB%88%E6%9E%81%E5%A5%A5%E7%A7%98-%E4%BA%BA%E6%98%AF%E4%B8%8D%E5%8F%AF%E4%BF%A1%E7%9A%84/"},{"categories":["碎碎念"],"content":"Refs 博客：https://guzhongren.github.io/ ","date":"2021-01-07","objectID":"/2021/01/%E5%86%99%E4%BB%A3%E7%A0%81%E7%9A%84%E7%BB%88%E6%9E%81%E5%A5%A5%E7%A7%98-%E4%BA%BA%E6%98%AF%E4%B8%8D%E5%8F%AF%E4%BF%A1%E7%9A%84/:4:0","tags":["生产事故"],"title":"写代码的终极奥秘 人是不可信的","uri":"/2021/01/%E5%86%99%E4%BB%A3%E7%A0%81%E7%9A%84%E7%BB%88%E6%9E%81%E5%A5%A5%E7%A7%98-%E4%BA%BA%E6%98%AF%E4%B8%8D%E5%8F%AF%E4%BF%A1%E7%9A%84/"},{"categories":["碎碎念"],"content":"Disclaimer 本文仅代表个人观点，与 Thoughtworks 公司无任何关系。 ","date":"2021-01-07","objectID":"/2021/01/%E5%86%99%E4%BB%A3%E7%A0%81%E7%9A%84%E7%BB%88%E6%9E%81%E5%A5%A5%E7%A7%98-%E4%BA%BA%E6%98%AF%E4%B8%8D%E5%8F%AF%E4%BF%A1%E7%9A%84/:5:0","tags":["生产事故"],"title":"写代码的终极奥秘 人是不可信的","uri":"/2021/01/%E5%86%99%E4%BB%A3%E7%A0%81%E7%9A%84%E7%BB%88%E6%9E%81%E5%A5%A5%E7%A7%98-%E4%BA%BA%E6%98%AF%E4%B8%8D%E5%8F%AF%E4%BF%A1%E7%9A%84/"},{"categories":["vim8.2","vim"],"content":"删除已有的 vim yum remove vim ","date":"2020-12-16","objectID":"/2020/12/centos%E5%AE%89%E8%A3%85vim8.2/:1:0","tags":["vim","centos"],"title":"Centos 安装 vim8.2","uri":"/2020/12/centos%E5%AE%89%E8%A3%85vim8.2/"},{"categories":["vim8.2","vim"],"content":"下载最新的 vim 到你的 centos 上 vim 官网：https://www.vim.org/ Vim8.2 下载：https://ftp.nluug.nl/pub/vim/unix/vim-8.2.tar.bz2 wget https://ftp.nluug.nl/pub/vim/unix/vim-8.2.tar.bz2 ","date":"2020-12-16","objectID":"/2020/12/centos%E5%AE%89%E8%A3%85vim8.2/:2:0","tags":["vim","centos"],"title":"Centos 安装 vim8.2","uri":"/2020/12/centos%E5%AE%89%E8%A3%85vim8.2/"},{"categories":["vim8.2","vim"],"content":"解压 tar -jxvf vim-8.2.tar.bz2 解压生成 vim82 文件夹 进入 cd /vim82/src ","date":"2020-12-16","objectID":"/2020/12/centos%E5%AE%89%E8%A3%85vim8.2/:3:0","tags":["vim","centos"],"title":"Centos 安装 vim8.2","uri":"/2020/12/centos%E5%AE%89%E8%A3%85vim8.2/"},{"categories":["vim8.2","vim"],"content":"配置 ./configure 如果遇到如下问题 no terminal library found checking for tgetent()… configure: error: NOT FOUND! You need to install a terminal library; for example ncurses. Or specify the name of the library with –with-tlib. 请执行如下命令安装依赖 yum install ncurses ncurses-devel ","date":"2020-12-16","objectID":"/2020/12/centos%E5%AE%89%E8%A3%85vim8.2/:4:0","tags":["vim","centos"],"title":"Centos 安装 vim8.2","uri":"/2020/12/centos%E5%AE%89%E8%A3%85vim8.2/"},{"categories":["vim8.2","vim"],"content":"编译 make ","date":"2020-12-16","objectID":"/2020/12/centos%E5%AE%89%E8%A3%85vim8.2/:5:0","tags":["vim","centos"],"title":"Centos 安装 vim8.2","uri":"/2020/12/centos%E5%AE%89%E8%A3%85vim8.2/"},{"categories":["vim8.2","vim"],"content":"安装 sudo make install 不出意外就安装完成了。 tencent@VM-0-9-centos  ~  vim --version  ✔  242  23:14:30 VIM - Vi IMproved 8.2 (2019 Dec 12, compiled Dec 16 2020 23:04:31) 编译者 tencent@VM-0-9-centos 巨型版本 无图形界面。 可使用 (+) 与不可使用 (-) 的功能： +acl -farsi -mouse_sysmouse -tag_old_static +arabic +file_in_path +mouse_urxvt -tag_any_white +autocmd +find_in_path +mouse_xterm -tcl +autochdir +float +multi_byte +termguicolors -autoservername +folding +multi_lang +terminal -balloon_eval -footer -mzscheme +terminfo +balloon_eval_term +fork() +netbeans_intg +termresponse -browse +gettext +num64 +textobjects ++builtin_terms -hangul_input +packages +textprop +byte_offset +iconv +path_extra +timers +channel +insert_expand -perl +title +cindent +job +persistent_undo -toolbar -clientserver +jumplist +popupwin +user_commands -clipboard +keymap +postscript +vartabs +cmdline_compl +lambda +printer +vertsplit +cmdline_hist +langmap +profile +virtualedit +cmdline_info +libcall -python +visual +comments +linebreak -python3 +visualextra +conceal +lispindent +quickfix +viminfo +cryptv +listcmds +reltime +vreplace +cscope +localmap +rightleft +wildignore +cursorbind -lua -ruby +wildmenu +cursorshape +menu +scrollbind +windows +dialog_con +mksession +signs +writebackup +diff +modify_fname +smartindent -X11 +digraphs +mouse -sound -xfontset -dnd -mouseshape +spell -xim -ebcdic +mouse_dec +startuptime -xpm +emacs_tags -mouse_gpm +statusline -xsmp +eval -mouse_jsbterm -sun_workshop -xterm_clipboard +ex_extra +mouse_netterm +syntax -xterm_save +extra_search +mouse_sgr +tag_binary 系统 vimrc 文件：\"$VIM/vimrc\" 用户 vimrc 文件：\"$HOME/.vimrc\" 第二用户 vimrc 文件：\"~/.vim/vimrc\" 用户 exrc 文件：\"$HOME/.exrc\" defaults file: \"$VIMRUNTIME/defaults.vim\" $VIM 预设值：\"/usr/local/share/vim\" 编译方式：gcc -c -I. -Iproto -DHAVE_CONFIG_H -g -O2 -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=1 链接方式：gcc -L/usr/local/lib -Wl,--as-needed -o vim -lm -ltinfo -lelf -ldl ","date":"2020-12-16","objectID":"/2020/12/centos%E5%AE%89%E8%A3%85vim8.2/:6:0","tags":["vim","centos"],"title":"Centos 安装 vim8.2","uri":"/2020/12/centos%E5%AE%89%E8%A3%85vim8.2/"},{"categories":["vim8.2","vim"],"content":"Refs 博客：https://guzhongren.github.io/ ","date":"2020-12-16","objectID":"/2020/12/centos%E5%AE%89%E8%A3%85vim8.2/:7:0","tags":["vim","centos"],"title":"Centos 安装 vim8.2","uri":"/2020/12/centos%E5%AE%89%E8%A3%85vim8.2/"},{"categories":["vim8.2","vim"],"content":"Disclaimer 本文仅代表个人观点，与 Thoughtworks 公司无任何关系。 ","date":"2020-12-16","objectID":"/2020/12/centos%E5%AE%89%E8%A3%85vim8.2/:8:0","tags":["vim","centos"],"title":"Centos 安装 vim8.2","uri":"/2020/12/centos%E5%AE%89%E8%A3%85vim8.2/"},{"categories":["碎碎念"],"content":"牢骚两句 你经常是不是会发现，某个人发了朋友圈或者在抖音上发了一条视频，就会在发完之后时不时的打开谁关注了那条动态？ 你经常是不是也发现，我们总是在意别人的观点，希望得到别人的赞扬或者肯定？ 那么问题是，你到底怎么了？ ","date":"2020-11-13","objectID":"/2020/11/%E4%B8%8D%E8%A6%81%E6%B4%BB%E5%9C%A8%E5%88%AB%E4%BA%BA%E7%9A%84%E7%9C%BC%E7%9D%9B%E9%87%8C/:1:0","tags":["碎碎念"],"title":"不要活在别人的眼睛里","uri":"/2020/11/%E4%B8%8D%E8%A6%81%E6%B4%BB%E5%9C%A8%E5%88%AB%E4%BA%BA%E7%9A%84%E7%9C%BC%E7%9D%9B%E9%87%8C/"},{"categories":["碎碎念"],"content":"你期望的就是我希望的？ 我们活着不是为了成为别人眼中的他人。 在小时候，你经常会跟你的父母犟嘴，强硬的要这要那。那时候的你是不是很有主见？都活成了最真实的自己。 但随着时间的流失，你慢慢的长大，融入了社会大学，开始夹着尾巴做人。还有现在的年轻人大多都买了房，房贷压力也很大，在工作上对领导也是点头哈腰，越来越没有自己的样子了。 ","date":"2020-11-13","objectID":"/2020/11/%E4%B8%8D%E8%A6%81%E6%B4%BB%E5%9C%A8%E5%88%AB%E4%BA%BA%E7%9A%84%E7%9C%BC%E7%9D%9B%E9%87%8C/:2:0","tags":["碎碎念"],"title":"不要活在别人的眼睛里","uri":"/2020/11/%E4%B8%8D%E8%A6%81%E6%B4%BB%E5%9C%A8%E5%88%AB%E4%BA%BA%E7%9A%84%E7%9C%BC%E7%9D%9B%E9%87%8C/"},{"categories":["碎碎念"],"content":"希望你起码的活出自己的样子 什么样子呢？大概呢。 至少有一天，你发了朋友圈或者抖音之类的，不再关注浏览量，不再在乎别人评论的好与坏。对每一条评论都可以随心所欲，淡定自若的恢复。 但愿有一天，可以找回小时候的自己。 ","date":"2020-11-13","objectID":"/2020/11/%E4%B8%8D%E8%A6%81%E6%B4%BB%E5%9C%A8%E5%88%AB%E4%BA%BA%E7%9A%84%E7%9C%BC%E7%9D%9B%E9%87%8C/:3:0","tags":["碎碎念"],"title":"不要活在别人的眼睛里","uri":"/2020/11/%E4%B8%8D%E8%A6%81%E6%B4%BB%E5%9C%A8%E5%88%AB%E4%BA%BA%E7%9A%84%E7%9C%BC%E7%9D%9B%E9%87%8C/"},{"categories":["碎碎念"],"content":"Refs 博客：https://guzhongren.github.io/ ","date":"2020-11-13","objectID":"/2020/11/%E4%B8%8D%E8%A6%81%E6%B4%BB%E5%9C%A8%E5%88%AB%E4%BA%BA%E7%9A%84%E7%9C%BC%E7%9D%9B%E9%87%8C/:4:0","tags":["碎碎念"],"title":"不要活在别人的眼睛里","uri":"/2020/11/%E4%B8%8D%E8%A6%81%E6%B4%BB%E5%9C%A8%E5%88%AB%E4%BA%BA%E7%9A%84%E7%9C%BC%E7%9D%9B%E9%87%8C/"},{"categories":["deno"],"content":"缘由 最近在用vscode写deno, 最佳拍档应该就是官方提供的插件了，但是使用插件需要对项目进行初始化 (deno:init)，其实就是在项目根目录创建一个文件 (.vscode/settings.json)， 然后在里面写入 deno 对该项目的配置。 在我刚开始写 deno 代码的时候，这个插件还是好的，但是参与到朋友的一个 demo 的时候就出问题了； 初始化：CMD+ Shift + P,deno:init, 然后右下角提示deno._init_project未找到，请重启 vscode。然后不管怎么重启，即使把插件的源码下载下来编译运行都不行。最终只有重新安装大法了。然而，重装了还是不行。 ","date":"2020-10-18","objectID":"/2020/10/%E8%A7%A3%E5%86%B3vscode%E9%85%8D%E7%BD%AEdeno%E6%97%B6%E5%91%BD%E4%BB%A4%E4%B8%8D%E5%8F%AF%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98%E7%9A%84%E8%AE%B0%E5%BD%95/:1:0","tags":["deno","deno._init_project"],"title":"解决 vscode 配置 deno 时命令不可用的问题的记录","uri":"/2020/10/%E8%A7%A3%E5%86%B3vscode%E9%85%8D%E7%BD%AEdeno%E6%97%B6%E5%91%BD%E4%BB%A4%E4%B8%8D%E5%8F%AF%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98%E7%9A%84%E8%AE%B0%E5%BD%95/"},{"categories":["deno"],"content":"解决方案 解决方案应该只能是将所有关于 vscode 的所有插件和配置都彻底删除重新安装才行。 ","date":"2020-10-18","objectID":"/2020/10/%E8%A7%A3%E5%86%B3vscode%E9%85%8D%E7%BD%AEdeno%E6%97%B6%E5%91%BD%E4%BB%A4%E4%B8%8D%E5%8F%AF%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98%E7%9A%84%E8%AE%B0%E5%BD%95/:2:0","tags":["deno","deno._init_project"],"title":"解决 vscode 配置 deno 时命令不可用的问题的记录","uri":"/2020/10/%E8%A7%A3%E5%86%B3vscode%E9%85%8D%E7%BD%AEdeno%E6%97%B6%E5%91%BD%E4%BB%A4%E4%B8%8D%E5%8F%AF%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98%E7%9A%84%E8%AE%B0%E5%BD%95/"},{"categories":["deno"],"content":"删除插件 rm -rf ~/.vscode/extensions ","date":"2020-10-18","objectID":"/2020/10/%E8%A7%A3%E5%86%B3vscode%E9%85%8D%E7%BD%AEdeno%E6%97%B6%E5%91%BD%E4%BB%A4%E4%B8%8D%E5%8F%AF%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98%E7%9A%84%E8%AE%B0%E5%BD%95/:2:1","tags":["deno","deno._init_project"],"title":"解决 vscode 配置 deno 时命令不可用的问题的记录","uri":"/2020/10/%E8%A7%A3%E5%86%B3vscode%E9%85%8D%E7%BD%AEdeno%E6%97%B6%E5%91%BD%E4%BB%A4%E4%B8%8D%E5%8F%AF%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98%E7%9A%84%E8%AE%B0%E5%BD%95/"},{"categories":["deno"],"content":"删除系统缓存数据 rm -rf ~/Library/Application\\ Support/Code ","date":"2020-10-18","objectID":"/2020/10/%E8%A7%A3%E5%86%B3vscode%E9%85%8D%E7%BD%AEdeno%E6%97%B6%E5%91%BD%E4%BB%A4%E4%B8%8D%E5%8F%AF%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98%E7%9A%84%E8%AE%B0%E5%BD%95/:2:2","tags":["deno","deno._init_project"],"title":"解决 vscode 配置 deno 时命令不可用的问题的记录","uri":"/2020/10/%E8%A7%A3%E5%86%B3vscode%E9%85%8D%E7%BD%AEdeno%E6%97%B6%E5%91%BD%E4%BB%A4%E4%B8%8D%E5%8F%AF%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98%E7%9A%84%E8%AE%B0%E5%BD%95/"},{"categories":["deno"],"content":"从应用程序中删除 vscode 打开 Mac 的应用程序管理文件夹，删除 Visual Studio Code ","date":"2020-10-18","objectID":"/2020/10/%E8%A7%A3%E5%86%B3vscode%E9%85%8D%E7%BD%AEdeno%E6%97%B6%E5%91%BD%E4%BB%A4%E4%B8%8D%E5%8F%AF%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98%E7%9A%84%E8%AE%B0%E5%BD%95/:2:3","tags":["deno","deno._init_project"],"title":"解决 vscode 配置 deno 时命令不可用的问题的记录","uri":"/2020/10/%E8%A7%A3%E5%86%B3vscode%E9%85%8D%E7%BD%AEdeno%E6%97%B6%E5%91%BD%E4%BB%A4%E4%B8%8D%E5%8F%AF%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98%E7%9A%84%E8%AE%B0%E5%BD%95/"},{"categories":["deno"],"content":"重新安装 vscode 直接下载安装包或者使用 Homebrew brew install visual-studio-code ","date":"2020-10-18","objectID":"/2020/10/%E8%A7%A3%E5%86%B3vscode%E9%85%8D%E7%BD%AEdeno%E6%97%B6%E5%91%BD%E4%BB%A4%E4%B8%8D%E5%8F%AF%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98%E7%9A%84%E8%AE%B0%E5%BD%95/:2:4","tags":["deno","deno._init_project"],"title":"解决 vscode 配置 deno 时命令不可用的问题的记录","uri":"/2020/10/%E8%A7%A3%E5%86%B3vscode%E9%85%8D%E7%BD%AEdeno%E6%97%B6%E5%91%BD%E4%BB%A4%E4%B8%8D%E5%8F%AF%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98%E7%9A%84%E8%AE%B0%E5%BD%95/"},{"categories":["deno"],"content":"安装 deno 插件 在 vscode 的扩展中搜索并安装 deno 插件。 ","date":"2020-10-18","objectID":"/2020/10/%E8%A7%A3%E5%86%B3vscode%E9%85%8D%E7%BD%AEdeno%E6%97%B6%E5%91%BD%E4%BB%A4%E4%B8%8D%E5%8F%AF%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98%E7%9A%84%E8%AE%B0%E5%BD%95/:2:5","tags":["deno","deno._init_project"],"title":"解决 vscode 配置 deno 时命令不可用的问题的记录","uri":"/2020/10/%E8%A7%A3%E5%86%B3vscode%E9%85%8D%E7%BD%AEdeno%E6%97%B6%E5%91%BD%E4%BB%A4%E4%B8%8D%E5%8F%AF%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98%E7%9A%84%E8%AE%B0%E5%BD%95/"},{"categories":["deno"],"content":"测试 打开 deno 相关的项目。CMD + Shift + P ， 输入 deno：init，应该不会再弹出命令找不到的错误提示了。 ","date":"2020-10-18","objectID":"/2020/10/%E8%A7%A3%E5%86%B3vscode%E9%85%8D%E7%BD%AEdeno%E6%97%B6%E5%91%BD%E4%BB%A4%E4%B8%8D%E5%8F%AF%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98%E7%9A%84%E8%AE%B0%E5%BD%95/:3:0","tags":["deno","deno._init_project"],"title":"解决 vscode 配置 deno 时命令不可用的问题的记录","uri":"/2020/10/%E8%A7%A3%E5%86%B3vscode%E9%85%8D%E7%BD%AEdeno%E6%97%B6%E5%91%BD%E4%BB%A4%E4%B8%8D%E5%8F%AF%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98%E7%9A%84%E8%AE%B0%E5%BD%95/"},{"categories":["deno"],"content":"Refs 博客：https://guzhongren.github.io/ ","date":"2020-10-18","objectID":"/2020/10/%E8%A7%A3%E5%86%B3vscode%E9%85%8D%E7%BD%AEdeno%E6%97%B6%E5%91%BD%E4%BB%A4%E4%B8%8D%E5%8F%AF%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98%E7%9A%84%E8%AE%B0%E5%BD%95/:4:0","tags":["deno","deno._init_project"],"title":"解决 vscode 配置 deno 时命令不可用的问题的记录","uri":"/2020/10/%E8%A7%A3%E5%86%B3vscode%E9%85%8D%E7%BD%AEdeno%E6%97%B6%E5%91%BD%E4%BB%A4%E4%B8%8D%E5%8F%AF%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98%E7%9A%84%E8%AE%B0%E5%BD%95/"},{"categories":["deno"],"content":"Disclaimer 本文仅代表个人观点，与 Thoughtworks 公司无任何关系。 ","date":"2020-10-18","objectID":"/2020/10/%E8%A7%A3%E5%86%B3vscode%E9%85%8D%E7%BD%AEdeno%E6%97%B6%E5%91%BD%E4%BB%A4%E4%B8%8D%E5%8F%AF%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98%E7%9A%84%E8%AE%B0%E5%BD%95/:5:0","tags":["deno","deno._init_project"],"title":"解决 vscode 配置 deno 时命令不可用的问题的记录","uri":"/2020/10/%E8%A7%A3%E5%86%B3vscode%E9%85%8D%E7%BD%AEdeno%E6%97%B6%E5%91%BD%E4%BB%A4%E4%B8%8D%E5%8F%AF%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98%E7%9A%84%E8%AE%B0%E5%BD%95/"},{"categories":["Tool"],"content":"缘由 在平时开发中，尤其在 mac 上，我们经常要用到iterm2, 然而默认的配置使用起来对于开发者来说并不是那么高效，比如平时我们需要用CMD+Delete来删除整行命令， 使用Opt+\u003c-来向右跳过单词等等的，这些快捷键在默认情况下并没有，那么接下来就来解决这个问题， ","date":"2020-10-09","objectID":"/2020/10/%E9%85%8D%E7%BD%AEiterm2%E4%BD%BF%E5%80%BC%E6%9B%B4%E9%AB%98%E6%95%88/:1:0","tags":["iTerm2","Preferences","Config"],"title":"配置 iTerm2 使值更高效","uri":"/2020/10/%E9%85%8D%E7%BD%AEiterm2%E4%BD%BF%E5%80%BC%E6%9B%B4%E9%AB%98%E6%95%88/"},{"categories":["Tool"],"content":"解决方案 使用CMD+,快捷键打开Preferences \u003e Profile \u003e Keys， 点击Presets...选择 Natural Text Editing 从此，你的 itemr2 如你的 IDE 一样高效。 再也不用为删除单个单词，整行代码，左右快速跳转烦恼了。 ","date":"2020-10-09","objectID":"/2020/10/%E9%85%8D%E7%BD%AEiterm2%E4%BD%BF%E5%80%BC%E6%9B%B4%E9%AB%98%E6%95%88/:2:0","tags":["iTerm2","Preferences","Config"],"title":"配置 iTerm2 使值更高效","uri":"/2020/10/%E9%85%8D%E7%BD%AEiterm2%E4%BD%BF%E5%80%BC%E6%9B%B4%E9%AB%98%E6%95%88/"},{"categories":["Tool"],"content":"Refs 博客：https://guzhongren.github.io/ ","date":"2020-10-09","objectID":"/2020/10/%E9%85%8D%E7%BD%AEiterm2%E4%BD%BF%E5%80%BC%E6%9B%B4%E9%AB%98%E6%95%88/:3:0","tags":["iTerm2","Preferences","Config"],"title":"配置 iTerm2 使值更高效","uri":"/2020/10/%E9%85%8D%E7%BD%AEiterm2%E4%BD%BF%E5%80%BC%E6%9B%B4%E9%AB%98%E6%95%88/"},{"categories":["Tool"],"content":"Disclaimer 本文仅代表个人观点，与 Thoughtworks 公司无任何关系。 ","date":"2020-10-09","objectID":"/2020/10/%E9%85%8D%E7%BD%AEiterm2%E4%BD%BF%E5%80%BC%E6%9B%B4%E9%AB%98%E6%95%88/:4:0","tags":["iTerm2","Preferences","Config"],"title":"配置 iTerm2 使值更高效","uri":"/2020/10/%E9%85%8D%E7%BD%AEiterm2%E4%BD%BF%E5%80%BC%E6%9B%B4%E9%AB%98%E6%95%88/"},{"categories":["DevOps"],"content":"最近，在做项目中的 DevOps，主要工作是备份，恢复并且更新 Parameter Store， 即Config as Code; 由于使用AWS 的服务，可靠性还是由很多个 9 来保证的，但是在后期就会由很多问题； Team 创建了多少资源 都有哪些资源 怎么确定某一资源是 Team 项目中要用的 如果 AWS 服务不稳定直接挂了，或者创建的资源被 team 成员不小心删除了，怎么办 如果要更新，我不想登录 AWS Console 或者使用 CLI 来一个个的更新，那怎么办 …… 对于以上问题，除了as code 还有什么好的方法么？如果有请告诉我。 接下来，我来简单说说我们项目的实践。在这个过程中遇到各种坑，但还是很有收获的。 在这先列个目录，主要罗列涉及到的服务，语言或者功能 AWS Parameter Store, KMS, cfn(Cloudformation) Shell Python 加解密 MD5 由于项目敏感性，在这就简单说说功能；项目中使用到 AWS Parameter Store 作为存储敏感数据的服务，而且所有的数据都是SecurityString（这种类型很重要，后面有坑），在每次项目部署或某些功能运行的时候需要使用其中的值，由于是经过 KMS加密的，要做备份和更新那么就需要调用AWS的服务或者CLI。 ","date":"2020-09-22","objectID":"/2020/09/%E6%9C%80%E8%BF%91%E6%88%91%E6%98%AFdevops/:0:0","tags":["DevOps","AWS","Shell","Python","Buildkite","DevOps","Cloudformation","subprocess"],"title":"最近我是 DevOps","uri":"/2020/09/%E6%9C%80%E8%BF%91%E6%88%91%E6%98%AFdevops/"},{"categories":["DevOps"],"content":"第一步 备份 第一步，在恢复数据之前，先要获取原有的数据，并将其存储为原始数据。 获取数据倒是不难，写个 shell 直接调用 AWS CLI，将获取到的数据存在文本文件里即可。可以参考官网 AWS CLI Get-Parameter by Path ","date":"2020-09-22","objectID":"/2020/09/%E6%9C%80%E8%BF%91%E6%88%91%E6%98%AFdevops/:1:0","tags":["DevOps","AWS","Shell","Python","Buildkite","DevOps","Cloudformation","subprocess"],"title":"最近我是 DevOps","uri":"/2020/09/%E6%9C%80%E8%BF%91%E6%88%91%E6%98%AFdevops/"},{"categories":["DevOps"],"content":"第二步 恢复 恢复，简单想一下就是将备份的数据执行命令，一条一条的插入就可以，然而，你这么想你就是小孩子了。原因自己体会。在这说说我做的过程。 首先将所有的数据分类，分为敏感数据和非敏感数据，对于非敏感的数据我们直接将其存储为明文，对于非敏感的数据，我们需要在本地就行加密为密文，保存起来。然后通过读取敏感数据和非敏感数据，将其恢复即可。 在这就遇到了第一个坑。 如果使用 cfn, 创建两个 cfn, 一个用来存储敏感数据，一个用来存储非敏感数据，然后通过 cfn 来对所有的数据进行统一管控。想象是美好的。当我将所有的数据都分好类，建好 cfn 模版，将一个一个的数据填上去，准备修改数据类型为 SecurityString的时候发现，文档上大大的写着，SecurityString 不支持 cfn ！SecurityString 不支持 cfn ！SecurityString 不支持 cfn ！ 想象是美好的，现实是骨感的。 既然不支持 cfn，那么只能想其他办法了；要么用支持的语言包，要么用 CLI, 貌似已经没有其他办法 as code 了。 ","date":"2020-09-22","objectID":"/2020/09/%E6%9C%80%E8%BF%91%E6%88%91%E6%98%AFdevops/:2:0","tags":["DevOps","AWS","Shell","Python","Buildkite","DevOps","Cloudformation","subprocess"],"title":"最近我是 DevOps","uri":"/2020/09/%E6%9C%80%E8%BF%91%E6%88%91%E6%98%AFdevops/"},{"categories":["DevOps"],"content":"语言包 因为做数据备份的项目是一个 DevOps 项目，所有的基础设施都是在这个项目中声明的，所以要使用 AWS 的 Java, Python 扩展包有点重，不合适。那么就剩下 CLI 这条路了。 ","date":"2020-09-22","objectID":"/2020/09/%E6%9C%80%E8%BF%91%E6%88%91%E6%98%AFdevops/:2:1","tags":["DevOps","AWS","Shell","Python","Buildkite","DevOps","Cloudformation","subprocess"],"title":"最近我是 DevOps","uri":"/2020/09/%E6%9C%80%E8%BF%91%E6%88%91%E6%98%AFdevops/"},{"categories":["DevOps"],"content":"CLI 在写代码之前，我先将数据重新整理成了 yaml 格式，毕竟比 JSON 好用（可以写注释）。格式大致如下 parameter:appName:- customKey:customKeyvalue:value 作为恢复更新脚本，肯定是在 pipeline 运行的时候执行的，所以第一想法就是使用 shell; 想到就直撸起袖子直接干呗。写啊写，虽然网上也有写好的 shell 来处理 yaml, 将读取结果 export 到环境变量中，比如 parameter_appName__customKey，但是问题是，那么多 parameter store, 我怎么一个一个的找到对应的数据的键和值呢？ 此路不通，那么立马换方案，使用 grep, awk,Regex进行匹配转换，终于所有的数据 (key， value) 对应上了，大致数据结构如下 parameter_appName__customKey=123; 然后就是对数据（key, value）进行循环处理了呗。 请注意，处理后的数据里有这么一种数据结构： parameter_app__key=test 1231; 当循环 value 到 test 1231 的时候，shell list 是以空格为分隔符的； 那么，就会造成 key 和 value 的长度不一致的问题，那么你的数据最终也会是错的。这个问题基本无解。所以此路又不通了。 考虑再三， Python 解析 YAML 需要安装第三方库，很不方便，但解析 JSON 很方便。在同事的帮助下，测试了 pipeline 是支持 python 的，又因为如果使用 AWS 的 Python 扩展包，需要额外安装依赖，所以直接考虑 Python 调用 Shell; Py 玩 Shell 综合以上因素，将 YAML格式的数据转换为 JSON, 由 Python 解析 JSON, 然后循环数据，循环过程中使用 subprocess 调用 shell, 在 shell中调用 AWS CLI 命令即可将数据更新上去或者执行解密操作等。 调用示例代码如下； subprocess. 在这需要重点说明一下的是，如果 subprocess调用的 shell是执行 docker命令，那么一定要在你要执行 subprocess.run(['docker-compose', 'run', '-T', '-rm', 'shush', value])这类命令前确保你已经拉取了 shush 涉及的镜像， 否则你第一次运行的输出结果里会有拉取镜像的日志。解决办法是在脚本真正运行之前获取镜像，可以使用如下密令 docker-compose pull shush ","date":"2020-09-22","objectID":"/2020/09/%E6%9C%80%E8%BF%91%E6%88%91%E6%98%AFdevops/:2:2","tags":["DevOps","AWS","Shell","Python","Buildkite","DevOps","Cloudformation","subprocess"],"title":"最近我是 DevOps","uri":"/2020/09/%E6%9C%80%E8%BF%91%E6%88%91%E6%98%AFdevops/"},{"categories":["DevOps"],"content":"总结 对于外部调用的 Shell 一定要写 Usage，也就是用户调用你的脚本的时候，如果出错，因该显示 help 信息 不要给可执行的脚本加 .sh ，.py 等后缀，只需要给其可执行权限即可 cfn 不支持 SecurityString shush 是个好工具，有 Docker 镜像，只要你的机器上有 Docker, 你就可以不用通过命令行安装它， 执行 docker 命令即可拿到结果；但需要注意的是：执行某个命令之前，需要先将镜像拉下来，不然第一次计算的结果中会有拉取镜像的日志。 ","date":"2020-09-22","objectID":"/2020/09/%E6%9C%80%E8%BF%91%E6%88%91%E6%98%AFdevops/:3:0","tags":["DevOps","AWS","Shell","Python","Buildkite","DevOps","Cloudformation","subprocess"],"title":"最近我是 DevOps","uri":"/2020/09/%E6%9C%80%E8%BF%91%E6%88%91%E6%98%AFdevops/"},{"categories":["DevOps"],"content":"Refs 博客：https://guzhongren.github.io/ ","date":"2020-09-22","objectID":"/2020/09/%E6%9C%80%E8%BF%91%E6%88%91%E6%98%AFdevops/:4:0","tags":["DevOps","AWS","Shell","Python","Buildkite","DevOps","Cloudformation","subprocess"],"title":"最近我是 DevOps","uri":"/2020/09/%E6%9C%80%E8%BF%91%E6%88%91%E6%98%AFdevops/"},{"categories":["DevOps"],"content":"Disclaimer 本文仅代表个人观点，与 Thoughtworks 公司无任何关系。 ","date":"2020-09-22","objectID":"/2020/09/%E6%9C%80%E8%BF%91%E6%88%91%E6%98%AFdevops/:5:0","tags":["DevOps","AWS","Shell","Python","Buildkite","DevOps","Cloudformation","subprocess"],"title":"最近我是 DevOps","uri":"/2020/09/%E6%9C%80%E8%BF%91%E6%88%91%E6%98%AFdevops/"},{"categories":["Summary"],"content":"一份合格的 ADR 应该包含哪些内容，怎么写","date":"2020-08-04","objectID":"/2020/08/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%BB%BD%E5%90%88%E6%A0%BC%E7%9A%84adr/","tags":["ADR","Architectural","Decision"],"title":"如何写一份合格的 ADR","uri":"/2020/08/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%BB%BD%E5%90%88%E6%A0%BC%E7%9A%84adr/"},{"categories":["Summary"],"content":"什么是 ADR ADR 即* Architectural Decision Records*，架构决策记录。 架构决策（AD）是一种软件设计选择，针对功能性或非功能性的需求进行的选择设计。 架构上重要的要求（ASR, Architecturally Significant Requirement）是对一个软件系统的体系结构和质量衡量效果的要求。 架构决策记录（ADR）捕捉 AD，如经常做写个人笔记或会议记录时；在项目中创建和维护的 ADR 集合构成其决策日志。 所有这些都属于架构知识管理 (AKM) 的主题。 ","date":"2020-08-04","objectID":"/2020/08/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%BB%BD%E5%90%88%E6%A0%BC%E7%9A%84adr/:1:0","tags":["ADR","Architectural","Decision"],"title":"如何写一份合格的 ADR","uri":"/2020/08/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%BB%BD%E5%90%88%E6%A0%BC%E7%9A%84adr/"},{"categories":["Summary"],"content":"ADR 能干什么 它可以记录某些决定背后的动机。 其实这一条就够了，在敏捷项目或者大型项目开发中，我们不难避免作出架构变更的操作。如果一次次的变更都没有记录，对于后来的开发者或者维护者都会是灾难。 在没有文档或者前人的指导下，如果使用新的架构变更可能会导致意想不到的 bug 出现。 为了能使后来者了解项目架构变化或者更好的维护项目，将重要的架构变更记录下来是非常重要的。 为客户更好的呈现现象及解决方案 当你作为乙方，为你的甲方开发系统，突然有一个功能要更改之前的架构设计，那么你的这次的架构变更应该需要让甲方知道并同意，最好的方案就是给他 show 一个 ADR. 梳理业务 ADR 是一个思考过程，也是一个记录过程； 将抽象的思考，以文字和图表等的形式记录下来，可以更好地辅助我们理解业务，共享知识。 ","date":"2020-08-04","objectID":"/2020/08/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%BB%BD%E5%90%88%E6%A0%BC%E7%9A%84adr/:2:0","tags":["ADR","Architectural","Decision"],"title":"如何写一份合格的 ADR","uri":"/2020/08/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%BB%BD%E5%90%88%E6%A0%BC%E7%9A%84adr/"},{"categories":["Summary"],"content":"什么情况下要使用 ADR 如上所说，在项目架构有重大变更的时候需要做记录，让所有关系人都了解到这次变更。在此需要说一下，对于敏捷宣言其中有一句，工作的软件高于详尽的文档， 这句话的意思不是不写文档。所以，必要的文档还是要写的。 ","date":"2020-08-04","objectID":"/2020/08/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%BB%BD%E5%90%88%E6%A0%BC%E7%9A%84adr/:3:0","tags":["ADR","Architectural","Decision"],"title":"如何写一份合格的 ADR","uri":"/2020/08/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%BB%BD%E5%90%88%E6%A0%BC%E7%9A%84adr/"},{"categories":["Summary"],"content":"怎么写呢 ","date":"2020-08-04","objectID":"/2020/08/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%BB%BD%E5%90%88%E6%A0%BC%E7%9A%84adr/:4:0","tags":["ADR","Architectural","Decision"],"title":"如何写一份合格的 ADR","uri":"/2020/08/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%BB%BD%E5%90%88%E6%A0%BC%E7%9A%84adr/"},{"categories":["Summary"],"content":"标题 标题 (Title) 建议以 ADR-[序号]-[项目/团队名称]-[ADR 主题] 这样的形式，直观且有序。 ","date":"2020-08-04","objectID":"/2020/08/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%BB%BD%E5%90%88%E6%A0%BC%E7%9A%84adr/:4:1","tags":["ADR","Architectural","Decision"],"title":"如何写一份合格的 ADR","uri":"/2020/08/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%BB%BD%E5%90%88%E6%A0%BC%E7%9A%84adr/"},{"categories":["Summary"],"content":"总结 (Summary) 这部分的主要任务是让别人快速知道你的这次 ADR 的上下文 (Context) 是什么，有哪些目标 (Objective), 有哪些备选方案 (Options)，谁在主导 (Owner), 有谁审阅了 (Reviews), 有哪些相关的决策 (Related Decisions), 当前 ADR 的状态 (Status) 是什么等。 一般情况下，在 ADR 开始的时候用一个表格来总体概括当前 ADR 的一些状态。比如： Item Content 名称 (Title) ADR 的标题 序号 (ID) ADR 序列号 主导人 (Owner) 负责人 审阅人 (Reviewers) 参与的审阅者 上下文 (Context) 这里介绍 ADR 的背景 (background)，目标 (objective)，是否紧急 (urgent)，如果不解决会有什么影响 (impact) 或者风险 (risk)，有什么限制，顾虑 (constraints) 等，所有可以为作出决定的内容都可以写在这里 目标 (Objective) 列出所有要达到的目标 备选方案 (Options) 以列表 (Option) 形式列出所有的备选方案 相关决策 (Title) 关于此次决策相关的一些其他辅助链接 状态 (Status) 本 ADR 的状态，INPROGRESS, PROPOSED, PENDING, DECIDED和REJECTED 中的一个 决定 (Decision) 接受 (Accepted) 或者拒绝 (Rejected) 决策 (Consequences) 选择了哪个方案，有什么后果或者代价 ","date":"2020-08-04","objectID":"/2020/08/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%BB%BD%E5%90%88%E6%A0%BC%E7%9A%84adr/:4:2","tags":["ADR","Architectural","Decision"],"title":"如何写一份合格的 ADR","uri":"/2020/08/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%BB%BD%E5%90%88%E6%A0%BC%E7%9A%84adr/"},{"categories":["Summary"],"content":"详细背景 (Background) 如果以上的表格并没有清楚的说明问题，那么在这块就可以详细说明了。 建议： 在阐述问题的时候尽量用图（截图，示意图，设计图，流程图）或者表来说明，因为图表比文字更直观，更容易理解； ","date":"2020-08-04","objectID":"/2020/08/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%BB%BD%E5%90%88%E6%A0%BC%E7%9A%84adr/:4:3","tags":["ADR","Architectural","Decision"],"title":"如何写一份合格的 ADR","uri":"/2020/08/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%BB%BD%E5%90%88%E6%A0%BC%E7%9A%84adr/"},{"categories":["Summary"],"content":"方案对比 (Option Comparison) 以上内容已经让你的甲方了解到了你们遇到了什么问题，接下来的内容就是在各个方案之间对比了，当然作为陈述 ADR 的人，你必须有一个你推荐 (prefer) 的方案。 方案对比一般也是一个表格，比如： 方案 (Options) 方案详细信息 (Solution Details) 优势 (pros) 劣势 (Cons) 决策后果或代价 (Consideration) 开发或测试成本 (Dev\u0026test Effort) 方案 1-option1 title 详细信息 有哪些优势 有哪些劣势 有什么要被顾虑 较小 (Small), 中等 (Medium)， 较难 (High) 中的一个 方案 2-option1 title 详细信息 有哪些优势 有哪些劣势 有什么要被顾虑 较小 (Small) 方案 3-option1 title 详细信息 有哪些优势 有哪些劣势 有什么要被顾虑 中等 (Medium) 方案 4-option1 title 详细信息 有哪些优势 有哪些劣势 有什么要被顾虑 较难 (High) ","date":"2020-08-04","objectID":"/2020/08/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%BB%BD%E5%90%88%E6%A0%BC%E7%9A%84adr/:4:4","tags":["ADR","Architectural","Decision"],"title":"如何写一份合格的 ADR","uri":"/2020/08/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%BB%BD%E5%90%88%E6%A0%BC%E7%9A%84adr/"},{"categories":["Summary"],"content":"讨论拉通 (Discuss) 上面所有做的工作都是为这一次讨论服务的，在拉通的会议上，需要拉上所有与本次变更有关系的人，当然最主要的是将甲方爸爸拉上；在会议上，你需要先陈述上上面的内容，最后把选择权交到甲方爸爸手里，千万不要把甲方爸爸的唯一的权利剥夺了。至于为什么，我也不知道。😄 在所有讨论完毕，要将 ADR 更新，并更新 ADR 的总结部分 (Summary)， 方便后面的人快速得到决策信息。 ","date":"2020-08-04","objectID":"/2020/08/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%BB%BD%E5%90%88%E6%A0%BC%E7%9A%84adr/:4:5","tags":["ADR","Architectural","Decision"],"title":"如何写一份合格的 ADR","uri":"/2020/08/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%BB%BD%E5%90%88%E6%A0%BC%E7%9A%84adr/"},{"categories":["Summary"],"content":"参考项目 MADR - Markdown 架构决策记录（MADR）。精益 ADR 可快速记录代码中的架构决策。 adr-log: https://adr.github.io/adr-log/ - 从 MADR 生成体系结构决策日志。 嵌入式架构决策记录：https://adr.github.io/e-adr/ 显示如何通过 ADR 注释将分布式 AD 日志嵌入 Java 代码中。 eadlsync:https://adr.github.io/eadlsync/ - 将嵌入式架构决策记录与架构决策存储库同步。 SE Repo: https://github.com/adr/serepo - 软件工程资料库。用于版本化软件工程工件的存储库，可以是架构决策，模式等。 ","date":"2020-08-04","objectID":"/2020/08/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%BB%BD%E5%90%88%E6%A0%BC%E7%9A%84adr/:5:0","tags":["ADR","Architectural","Decision"],"title":"如何写一份合格的 ADR","uri":"/2020/08/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%BB%BD%E5%90%88%E6%A0%BC%E7%9A%84adr/"},{"categories":["Summary"],"content":"总结 ADR 在大型项目或者大公司的项目中经常会用到，不管是对现有业务的澄清总结，还是对不确定的业务的拉通都有积极作用。当然也是一个甩锅利器。 建议： 使用版本控制工具来管理 ADR, 比如 Confluence, 国内的话有 语雀, 石墨, 还有些代码管理平台也有Wiki, 如阿里云的 云效, 腾讯的 Coding 等； 当然如果是小项目也可以存在代码仓库中。 万事皆可法；工作中的大部分事物都是有套路的；愿你选对套路，归来仍是高效 dev。 ","date":"2020-08-04","objectID":"/2020/08/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%BB%BD%E5%90%88%E6%A0%BC%E7%9A%84adr/:6:0","tags":["ADR","Architectural","Decision"],"title":"如何写一份合格的 ADR","uri":"/2020/08/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%BB%BD%E5%90%88%E6%A0%BC%E7%9A%84adr/"},{"categories":["Summary"],"content":"Refs 博客：https://guzhongren.github.io/ Why write adrs:https://github.blog/2020-08-13-why-write-adrs/ ADR: https://adr.github.io/ 架构设计实践之架构决策记录：https://zhuanlan.zhihu.com/p/141385447 【译文】架构决策记录（Architecture Decision Records） ","date":"2020-08-04","objectID":"/2020/08/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%BB%BD%E5%90%88%E6%A0%BC%E7%9A%84adr/:7:0","tags":["ADR","Architectural","Decision"],"title":"如何写一份合格的 ADR","uri":"/2020/08/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%BB%BD%E5%90%88%E6%A0%BC%E7%9A%84adr/"},{"categories":["Summary"],"content":"Disclaimer 本文仅代表个人观点，与 Thoughtworks 公司无任何关系。 ","date":"2020-08-04","objectID":"/2020/08/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%BB%BD%E5%90%88%E6%A0%BC%E7%9A%84adr/:8:0","tags":["ADR","Architectural","Decision"],"title":"如何写一份合格的 ADR","uri":"/2020/08/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%BB%BD%E5%90%88%E6%A0%BC%E7%9A%84adr/"},{"categories":["deno"],"content":"Talking is cheap! Show me code! 源码地址：Deno Restful API With PostgreSql \u0026 TDD ","date":"2020-07-24","objectID":"/2020/07/%E5%9F%BA%E4%BA%8Eoak%E7%9A%84%E4%B8%80%E6%AC%A1tdd%E5%AE%9E%E8%B7%B5/:1:0","tags":["deno","oak","tdd","git","mvc","fetch"],"title":"基于 oak 的一次 TDD 实践","uri":"/2020/07/%E5%9F%BA%E4%BA%8Eoak%E7%9A%84%E4%B8%80%E6%AC%A1tdd%E5%AE%9E%E8%B7%B5/"},{"categories":["deno"],"content":"简介 Deno 是ry(Ryan Dahl)的新项目，近期发布了其 1.0.0 版，在开发圈子里掀起了不小的风浪，与之创建的 Node 运行时有异曲同工之妙，真香定律又一次出现了。 在软件开发中，为了开发出可维护，高质量的程序，使用TDD开发可以有效提升项目质量和开发效率。 在这篇博客中，我将使用Deno, Typescript, PostgreSql来开发一个用户管理的 API 接口。 ","date":"2020-07-24","objectID":"/2020/07/%E5%9F%BA%E4%BA%8Eoak%E7%9A%84%E4%B8%80%E6%AC%A1tdd%E5%AE%9E%E8%B7%B5/:2:0","tags":["deno","oak","tdd","git","mvc","fetch"],"title":"基于 oak 的一次 TDD 实践","uri":"/2020/07/%E5%9F%BA%E4%BA%8Eoak%E7%9A%84%E4%B8%80%E6%AC%A1tdd%E5%AE%9E%E8%B7%B5/"},{"categories":["deno"],"content":"Deno \u0026 oak 下面都是来自官网的介绍，写的很通俗易懂，就不用我来解读了。 ","date":"2020-07-24","objectID":"/2020/07/%E5%9F%BA%E4%BA%8Eoak%E7%9A%84%E4%B8%80%E6%AC%A1tdd%E5%AE%9E%E8%B7%B5/:3:0","tags":["deno","oak","tdd","git","mvc","fetch"],"title":"基于 oak 的一次 TDD 实践","uri":"/2020/07/%E5%9F%BA%E4%BA%8Eoak%E7%9A%84%E4%B8%80%E6%AC%A1tdd%E5%AE%9E%E8%B7%B5/"},{"categories":["deno"],"content":"Deno Deno 是一个简单、现代且安全的 JavaScript 和 TypeScript 运行时环境，其基于 V8 引擎并采用 Rust 编程语言构建。 默认安全设置。除非 显式开启，否则没有文件、网络，也不能访问运行环境。 天生支持 TypeScript。 只有一个单一的可执行文件。 自带实用工具，例如依赖检查器（deno info）和 代码格式化工具（deno fmt）。 有一套经过审核（审计）的标准模块， 确保与 Deno 兼容： deno.land/std。 ","date":"2020-07-24","objectID":"/2020/07/%E5%9F%BA%E4%BA%8Eoak%E7%9A%84%E4%B8%80%E6%AC%A1tdd%E5%AE%9E%E8%B7%B5/:3:1","tags":["deno","oak","tdd","git","mvc","fetch"],"title":"基于 oak 的一次 TDD 实践","uri":"/2020/07/%E5%9F%BA%E4%BA%8Eoak%E7%9A%84%E4%B8%80%E6%AC%A1tdd%E5%AE%9E%E8%B7%B5/"},{"categories":["deno"],"content":"oak A middleware framework for Deno’s net server 🦕 oak 是借鉴 Node 框架Koa的设计思路开发的一个高性能的框架，其洋葱模型式的中间件等思路在开发中使用起来也是非常方便。 ","date":"2020-07-24","objectID":"/2020/07/%E5%9F%BA%E4%BA%8Eoak%E7%9A%84%E4%B8%80%E6%AC%A1tdd%E5%AE%9E%E8%B7%B5/:3:2","tags":["deno","oak","tdd","git","mvc","fetch"],"title":"基于 oak 的一次 TDD 实践","uri":"/2020/07/%E5%9F%BA%E4%BA%8Eoak%E7%9A%84%E4%B8%80%E6%AC%A1tdd%E5%AE%9E%E8%B7%B5/"},{"categories":["deno"],"content":"目标 基于对以上的基础知识的认识，我们计划开发一个用户管理的API平台；对于后端简单来说，就是提供关于用户的增删改查（CURD）操作。所以我们的主要目标就是提供 4 个对用户CURD的接口。 ","date":"2020-07-24","objectID":"/2020/07/%E5%9F%BA%E4%BA%8Eoak%E7%9A%84%E4%B8%80%E6%AC%A1tdd%E5%AE%9E%E8%B7%B5/:4:0","tags":["deno","oak","tdd","git","mvc","fetch"],"title":"基于 oak 的一次 TDD 实践","uri":"/2020/07/%E5%9F%BA%E4%BA%8Eoak%E7%9A%84%E4%B8%80%E6%AC%A1tdd%E5%AE%9E%E8%B7%B5/"},{"categories":["deno"],"content":"工具 工欲善其事，必先利其器。 ","date":"2020-07-24","objectID":"/2020/07/%E5%9F%BA%E4%BA%8Eoak%E7%9A%84%E4%B8%80%E6%AC%A1tdd%E5%AE%9E%E8%B7%B5/:5:0","tags":["deno","oak","tdd","git","mvc","fetch"],"title":"基于 oak 的一次 TDD 实践","uri":"/2020/07/%E5%9F%BA%E4%BA%8Eoak%E7%9A%84%E4%B8%80%E6%AC%A1tdd%E5%AE%9E%E8%B7%B5/"},{"categories":["deno"],"content":"开发工具 VS Code, Docker ","date":"2020-07-24","objectID":"/2020/07/%E5%9F%BA%E4%BA%8Eoak%E7%9A%84%E4%B8%80%E6%AC%A1tdd%E5%AE%9E%E8%B7%B5/:5:1","tags":["deno","oak","tdd","git","mvc","fetch"],"title":"基于 oak 的一次 TDD 实践","uri":"/2020/07/%E5%9F%BA%E4%BA%8Eoak%E7%9A%84%E4%B8%80%E6%AC%A1tdd%E5%AE%9E%E8%B7%B5/"},{"categories":["deno"],"content":"环境工具 Deno, Typescript, Node 注： Node 是用来调试 Deno 的 ","date":"2020-07-24","objectID":"/2020/07/%E5%9F%BA%E4%BA%8Eoak%E7%9A%84%E4%B8%80%E6%AC%A1tdd%E5%AE%9E%E8%B7%B5/:5:2","tags":["deno","oak","tdd","git","mvc","fetch"],"title":"基于 oak 的一次 TDD 实践","uri":"/2020/07/%E5%9F%BA%E4%BA%8Eoak%E7%9A%84%E4%B8%80%E6%AC%A1tdd%E5%AE%9E%E8%B7%B5/"},{"categories":["deno"],"content":"基础环境信息 我的环境信息如下： ❯ node -v v12.13.0 ❯ deno --version deno 1.2.0 v8 8.5.216 typescript 3.9.2 ❯ docker --version Docker version 19.03.8, build afacb8b 其他信息 类型 版本 备注 PostgreSql 12 PGAdmin latest ","date":"2020-07-24","objectID":"/2020/07/%E5%9F%BA%E4%BA%8Eoak%E7%9A%84%E4%B8%80%E6%AC%A1tdd%E5%AE%9E%E8%B7%B5/:6:0","tags":["deno","oak","tdd","git","mvc","fetch"],"title":"基于 oak 的一次 TDD 实践","uri":"/2020/07/%E5%9F%BA%E4%BA%8Eoak%E7%9A%84%E4%B8%80%E6%AC%A1tdd%E5%AE%9E%E8%B7%B5/"},{"categories":["deno"],"content":"项目结构 ❯ tree -L 1 deno-restful-api-with-postgresql-tdd deno-restful-api-with-postgresql-tdd ├── .github // github action ├── .vscode // debug 及 vscode 配置文件 ├── LICENSE // 仓库许可 ├── README.md // 项目说明，包括数据库连接，简化后的运行命令等 ├── _resources // 基础资源 │ ├── IaaS // 基础设施，docker-compose 启动 postgresql │ ├── httpClient // http 请求测试 │ └── migration // 负责生成数据库表 ├── deps.ts // 项目依赖的库及项目中要用到的资源（import） ├── lock.json // 完整性检查与锁定文件，参考：https://nugine.github.io/deno-manual-cn/linking_to_external_code/integrity_checking.html ├── makefile // 将开发需要的命令行简化后目录 ├── src // 源代码目录 └── tests // 测试目录 5 directories, 5 files ","date":"2020-07-24","objectID":"/2020/07/%E5%9F%BA%E4%BA%8Eoak%E7%9A%84%E4%B8%80%E6%AC%A1tdd%E5%AE%9E%E8%B7%B5/:6:1","tags":["deno","oak","tdd","git","mvc","fetch"],"title":"基于 oak 的一次 TDD 实践","uri":"/2020/07/%E5%9F%BA%E4%BA%8Eoak%E7%9A%84%E4%B8%80%E6%AC%A1tdd%E5%AE%9E%E8%B7%B5/"},{"categories":["deno"],"content":"实现过程 先说明一下，如果要用文字写完整个开发过程个人认为是没有必要的，所以就以最开始的health和addUser(post接口）为例， 其他接口请参考 代码实现。 ","date":"2020-07-24","objectID":"/2020/07/%E5%9F%BA%E4%BA%8Eoak%E7%9A%84%E4%B8%80%E6%AC%A1tdd%E5%AE%9E%E8%B7%B5/:7:0","tags":["deno","oak","tdd","git","mvc","fetch"],"title":"基于 oak 的一次 TDD 实践","uri":"/2020/07/%E5%9F%BA%E4%BA%8Eoak%E7%9A%84%E4%B8%80%E6%AC%A1tdd%E5%AE%9E%E8%B7%B5/"},{"categories":["deno"],"content":"启动基础设施（数据库）并初始化数据表 启动数据库 ❯ make db cd ./_resources/Iaas \u0026\u0026 docker-compose up -d Starting iaas_db_1 ... done Starting iaas_pgadmin_1 ... done 登录pgadmin, 在默认的数据库postgres中新建Query并执行如下操作，完成初始化数据库 CREATETABLEpublic.\"user\"(iduuidNOTNULL,usernamecharactervarying(50)NOTNULL,registration_datetimestampwithouttimezone,passwordcharactervarying(20)NOTNULL,deletedboolean); ","date":"2020-07-24","objectID":"/2020/07/%E5%9F%BA%E4%BA%8Eoak%E7%9A%84%E4%B8%80%E6%AC%A1tdd%E5%AE%9E%E8%B7%B5/:7:1","tags":["deno","oak","tdd","git","mvc","fetch"],"title":"基于 oak 的一次 TDD 实践","uri":"/2020/07/%E5%9F%BA%E4%BA%8Eoak%E7%9A%84%E4%B8%80%E6%AC%A1tdd%E5%AE%9E%E8%B7%B5/"},{"categories":["deno"],"content":"src 最终目录 ❯ tree -a -L 4 src src ├── Utils │ └── client.ts ├── config.ts ├── controllers │ ├── UserController.ts │ ├── health.ts │ └── model │ └── IResponse.ts ├── entity │ └── User.ts ├── exception │ ├── InvalidedParamsException.ts │ └── NotFoundException.ts ├── index.ts ├── middlewares │ ├── error.ts │ ├── logger.ts │ └── time.ts ├── repositories │ └── userRepo.ts ├── router.ts └── services ├── UserService.ts └── fetchResource.ts 8 directories, 16 files 在开始之前，我们先定义一些常用的结构体和对象，如：response，exception 等 // src/controllers/model/IResponse.ts export default interface IResponse { success: boolean; // 表示此次请求是否成功 msg?: String; // 发生错误时的一些日志信息 data?: any; // 请求成功时返回给前端的数据 } // src/entity/User.ts export default interface IUser { id?: string; username?: string; password?: string; registrationDate?: string; deleted?: boolean; } export class User implements IUser {} 异常用来处理错误情况，在最终返回给用户结果的时候，我们不能将异常返回给用户，而是以一种更友好的方式返回，具体流程可以参考src/middlewares/error.ts这个中间件的处理方式。 // src/exception/InvalidedParamsException.ts export default class InvalidedParamsException extends Error { constructor(message: string) { super(`Invalided parameters, please check, ${message}`); } } // src/exception/NotFoundException.ts export default class NotFoundException extends Error { constructor(message: string) { super(`Not found resource, ${message}`); } } ","date":"2020-07-24","objectID":"/2020/07/%E5%9F%BA%E4%BA%8Eoak%E7%9A%84%E4%B8%80%E6%AC%A1tdd%E5%AE%9E%E8%B7%B5/:7:2","tags":["deno","oak","tdd","git","mvc","fetch"],"title":"基于 oak 的一次 TDD 实践","uri":"/2020/07/%E5%9F%BA%E4%BA%8Eoak%E7%9A%84%E4%B8%80%E6%AC%A1tdd%E5%AE%9E%E8%B7%B5/"},{"categories":["deno"],"content":"依赖管理 Deno 没有像 Node 一样的诸如package.json来管理依赖，因为Deno的依赖是去中心化的，也就是以远程文件作为库，这一点和Golang很像。 我将系统中用到的依赖存放在根目录的deps.ts中，在最终提交的时候做一次 完整性检查与锁定文件, 来保证我所有的依赖在与其他协作者之间是相同的。 首先导入用到的测试相关的依赖。在后面开发中用到的相关依赖请自行添加到本文件中。 比较重要的我会列出来。 export { assert, equal, } from \"https://deno.land/std/testing/asserts.ts\"; ","date":"2020-07-24","objectID":"/2020/07/%E5%9F%BA%E4%BA%8Eoak%E7%9A%84%E4%B8%80%E6%AC%A1tdd%E5%AE%9E%E8%B7%B5/:7:3","tags":["deno","oak","tdd","git","mvc","fetch"],"title":"基于 oak 的一次 TDD 实践","uri":"/2020/07/%E5%9F%BA%E4%BA%8Eoak%E7%9A%84%E4%B8%80%E6%AC%A1tdd%E5%AE%9E%E8%B7%B5/"},{"categories":["deno"],"content":"测试先行 现在tests目录下新建一个测试命名为index.test.ts, 写基本测试，证明测试和程序是可以work的。 import { assert, equal } from \"../deps.ts\"; const { test } = Deno; test(\"should work\", () =\u003e { const universal = 42; equal(42, universal); assert(42 === universal); }); ","date":"2020-07-24","objectID":"/2020/07/%E5%9F%BA%E4%BA%8Eoak%E7%9A%84%E4%B8%80%E6%AC%A1tdd%E5%AE%9E%E8%B7%B5/:7:4","tags":["deno","oak","tdd","git","mvc","fetch"],"title":"基于 oak 的一次 TDD 实践","uri":"/2020/07/%E5%9F%BA%E4%BA%8Eoak%E7%9A%84%E4%B8%80%E6%AC%A1tdd%E5%AE%9E%E8%B7%B5/"},{"categories":["deno"],"content":"第一次运行测试 ❯ make test deno test --allow-env --allow-net -L info Check file:///xxxx/deno-restful-api-with-postgresql-tdd/.deno.test.ts running 1 tests test should work ... ok (6ms) test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out (6ms) ","date":"2020-07-24","objectID":"/2020/07/%E5%9F%BA%E4%BA%8Eoak%E7%9A%84%E4%B8%80%E6%AC%A1tdd%E5%AE%9E%E8%B7%B5/:7:5","tags":["deno","oak","tdd","git","mvc","fetch"],"title":"基于 oak 的一次 TDD 实践","uri":"/2020/07/%E5%9F%BA%E4%BA%8Eoak%E7%9A%84%E4%B8%80%E6%AC%A1tdd%E5%AE%9E%E8%B7%B5/"},{"categories":["deno"],"content":"建立测试固件 将测试中用到的通用的测试信息存放在测试固件（testFixtures）中，可以在测试中复用，且可以简化代码。 // tests/testFixtures.ts export const TEST_PORT = 9000 ","date":"2020-07-24","objectID":"/2020/07/%E5%9F%BA%E4%BA%8Eoak%E7%9A%84%E4%B8%80%E6%AC%A1tdd%E5%AE%9E%E8%B7%B5/:7:6","tags":["deno","oak","tdd","git","mvc","fetch"],"title":"基于 oak 的一次 TDD 实践","uri":"/2020/07/%E5%9F%BA%E4%BA%8Eoak%E7%9A%84%E4%B8%80%E6%AC%A1tdd%E5%AE%9E%E8%B7%B5/"},{"categories":["deno"],"content":"health 接口 health 接口可以作为系统的健康检查的一个出口，在运维平台中非常实用。对于此接口，我们只需要返回一个状态OK即可。其他情况可忽略。那么对应的Todo应该如下： 当访问到系统的时候，应该返回系统的状态，且为 OK。 所以，测试代码如下： import { assertEquals, Application, Router, } from \"../../deps.ts\"; import { getHealthInfo } from \"../../src/controllers/health.ts\"; import {TEST_PORT} from '../testFixtures.ts' const { test } = Deno; test(\"health check\", async () =\u003e { const expectResponse = { success: true, data: \"Ok\", }; const app = new Application(); const router = new Router(); const abortController = new AbortController(); const { signal } = abortController; router.get(\"/health\", async ({ response }) =\u003e { getHealthInfo({ response }); }); app.use(router.routes()); app.listen({ port: TEST_PORT, signal }); const response = await fetch(`http://127.0.0.1:${TEST_PORT}/health`); assertEquals(response.ok, true); const responseJSON = await response.json(); assertEquals(responseJSON, expectResponse); abortController.abort(); }); given 上面的代码中，首先声明了我们期望的数据结构，即expectResponse； 然后创建一个应用程序和一个路由， 再创建一个终止应用的控制器，且从中取到信号标识， 接着， 向路由中添加一个health路由及其 handler； 然后将路由挂在到应用程序上； 监听应用程序端口，且传入应用程序信号。 when 给启动的应用发一个 get 请求，请求路径为/health; then 根据 fetch 到的结果进行判定，看收到的response是不是和期望的一致， 且在最后终止上面的应用程序。 到此，如果运行测试肯定会发生错误，解决问题的也很简单，就是去实现getHealthInfo handler。 实现 getHealthInfo handler 在 src/controller 下新建health.ts，并以最简单的方案实现上面期望的结果，如下： // src/controllers/health.ts import { Response, Status } from \"../../deps.ts\"; import IResponse from \"./model/IResponse.ts\"; export const getHealthInfo = ({ response }: { response: Response }) =\u003e { response.status = Status.OK; const res: IResponse = { success: true, data: \"Ok\", }; response.body = res; }; 运行测试 运行测试命令，测试通过； ❯ make test deno test --allow-env --allow-net -L info Check file://xxx/deno-restful-api-with-postgresql-tdd/.deno.test.ts running 2 tests test should work ... ok (6ms) test health check ... ok (3ms) test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out (9ms) 至此，使用TDD完成第一个简单的health接口；但对外没有暴露接口，所以需要在src目录中实现一个对外暴露该接口的应用。 新建config.ts， 做应用程序的配置管理文件 // src/config.ts const env = Deno.env.toObject(); export const APP_HOST = env.APP_HOST || \"127.0.0.1\"; export const APP_PORT = parseInt(env.APP_PORT) || 8000; export const API_VERSION = env.API_VERSION || \"/api/v1\"; 配置文件中，记录了应用程序启动的默认 host, 端口，及数据库相关的信息，最后记录了应用程序 api 的前缀。 在开始之前，需要在deps.ts中引入所需要的库； export { Application, Router, Response, Status, Request, RouteParams, Context, RouterContext, helpers, send, } from \"https://deno.land/x/oak/mod.ts\"; 新建路由 router.ts, 引入Heath.ts并绑定路由 // src/router.ts import { Router } from \"../deps.ts\"; import { API_VERSION } from \"./config.ts\"; import { getHealthInfo } from \"./controllers/health.ts\"; const router = new Router(); router.prefix(API_VERSION); router .get(\"/health\", getHealthInfo) export default router; 新建index.ts, 建立应用程序 // src/index.ts import { Application, send } from \"../deps.ts\"; import { APP_HOST, APP_PORT } from \"./config.ts\"; import router from \"./router.ts\"; export const listenToServer = async (app: Application) =\u003e { console.info(`Application started, and listen to ${APP_HOST}:${APP_PORT}`); await app.listen({ hostname: APP_HOST, port: APP_PORT, secure: false, }); }; export function createApplication(): Promise\u003cApplication\u003e { const app = new Application(); app.use(router.routes()); return Promise.resolve(app); } if (import.meta.main) { const app = await createApplication(); await listenToServer(app); } 启动应用 如果是VSCode， 可以使用F5功能键，快速启动应用，在低版本的 VS Code(1.47.2 以下） 中可以启动调试。也可以以下命令启动； ❯ make dev deno run --allow-net --allow-env ./src/index.ts 数据库链接成功！ Application started, and listen to 127.0.0.1:8000 调用接口测试结果 这里使用VS Code 的 Rest Client 插件进行辅助测试。 请求体 // _resources/httpClient/healthCheck.http GET http://localhost:8000/api/v1/health HTTP/1.1 请求结果 HTTP/1.1 200 OK content-length: 28 x-response-time: 0ms content-type: application/json; charset=utf-8 { \"success\": true, \"data\": \"Ok\" } 至此，完成第一个接口，有 Oak 提供应用服务，经过了Unit test和 RestClient的测试。完成了开始的Todo。 ","date":"2020-07-24","objectID":"/2020/07/%E5%9F%BA%E4%BA%8Eoak%E7%9A%84%E4%B8%80%E6%AC%A1tdd%E5%AE%9E%E8%B7%B5/:7:7","tags":["deno","oak","tdd","git","mvc","fetch"],"title":"基于 oak 的一次 TDD 实践","uri":"/2020/07/%E5%9F%BA%E4%BA%8Eoak%E7%9A%84%E4%B8%80%E6%AC%A1tdd%E5%AE%9E%E8%B7%B5/"},{"categories":["deno"],"content":"添加用户接口 (addUser) 添加用户涉及到Controller, Service 和 Repository, 所以我们分三步来实现该接口。 Controller Controller 是控制层，对外提供服务；添加用户接口可以为系统添加用户，那么对应的Todo如下： 输入用户名和密码，返回特定数据结构的用户信息 参数必须输入，否则抛异常 如果输入错误参数，则抛异常 在此过程中，我们需要用到 mock 来 mock 第三方依赖。 导入所需依赖，并新建UserController.test.ts，在Coding 过程中需要实现UserService, 但不需要实现addUser方法； 测试如下： // tests/controllers/UserController.test.ts import { stub, Stub, assertEquals, v4, assertThrowsAsync, Application, Router, } from \"../../deps.ts\"; import UserController from \"../../src/controllers/UserController.ts\"; import IResponse from \"../../src/controllers/model/IResponse.ts\"; import UserService from \"../../src/services/UserService.ts\"; import IUser, { User } from \"../../src/entity/User.ts\"; import InvalidedParamsException from \"../../src/exception/InvalidedParamsException.ts\"; import {TEST_PORT} from '../testFixtures.ts' const { test } = Deno; const userId = v4.generate(); const registrationDate = (new Date()).toISOString(); const mockedUser: User = { id: userId, username: \"username\", registrationDate, deleted: false, }; test(\"#addUser should return added user when add user\", async () =\u003e { const userService = new UserService(); const queryAllStub: Stub\u003cUserService\u003e = stub(userService, \"addUser\"); const expectResponse = { success: true, data: mockedUser, }; queryAllStub.returns = [mockedUser]; const userController = new UserController(); userController.userService = userService; const app = new Application(); const router = new Router(); const abortController = new AbortController(); const { signal } = abortController; router.post(\"/users\", async (context) =\u003e { return await userController.addUser(context); }); app.use(router.routes()); app.listen({ port: TEST_PORT, signal }); const response = await fetch(`http://127.0.0.1:${TEST_PORT}/users`, { method: \"POST\", body: \"name=name\u0026password=123\", headers: { \"Content-Type\": \"application/x-www-form-urlencoded\", }, }); assertEquals(response.ok, true); const responseJSON = await response.json(); assertEquals(responseJSON, expectResponse); abortController.abort(); queryAllStub.restore(); }); test(\"#addUser should throw exception about no params given no params when add user\", async () =\u003e { const userService = new UserService(); const queryAllStub: Stub\u003cUserService\u003e = stub(userService, \"addUser\"); queryAllStub.returns = [mockedUser]; const userController = new UserController(); userController.userService = userService; const app = new Application(); const router = new Router(); const abortController = new AbortController(); const { signal } = abortController; router.post(\"/users\", async (context) =\u003e { await assertThrowsAsync( async () =\u003e { await userController.addUser(context); }, InvalidedParamsException, \"should given params: name ...\", ); abortController.abort(); queryAllStub.restore(); }); app.use(router.routes()); app.listen({ port: TEST_PORT, signal }); const response = await fetch(`http://127.0.0.1:${TEST_PORT}/users`, { method: \"POST\", body: \"\", headers: { \"Content-Type\": \"application/x-www-form-urlencoded\", }, }); await response.body!.cancel(); }); test(\"#addUser should throw exception about no correct params given wrong params when add user\", async () =\u003e { const userService = new UserService(); const queryAllStub: Stub\u003cUserService\u003e = stub(userService, \"addUser\"); queryAllStub.returns = [mockedUser]; const userController = new UserController(); userController.userService = userService; const app = new Application(); const router = new Router(); const abortController = new AbortController(); const { signal } = abortController; router.post(\"/users\", async (context) =\u003e { await assertThrowsAsync( async () =\u003e { await userController.addUser(context); }, InvalidedParamsException, \"should given param name and password\", ); abortController.abort(); queryAllStub.restore(); }); app.use(router.routes()); app.listen({ port: TEST_PORT, signal }); const response = await fetch(`http://127.0.0.1:${TEST_PORT}/users`, { method: \"POST\", body: \"wrong=params\", headers: { \"Content-Type\": \"application","date":"2020-07-24","objectID":"/2020/07/%E5%9F%BA%E4%BA%8Eoak%E7%9A%84%E4%B8%80%E6%AC%A1tdd%E5%AE%9E%E8%B7%B5/:7:8","tags":["deno","oak","tdd","git","mvc","fetch"],"title":"基于 oak 的一次 TDD 实践","uri":"/2020/07/%E5%9F%BA%E4%BA%8Eoak%E7%9A%84%E4%B8%80%E6%AC%A1tdd%E5%AE%9E%E8%B7%B5/"},{"categories":["deno"],"content":"打包 按照上面的步骤，我们可以完成查询单个用户 (GET:/users/:id), 查询所有用户 (GET:/users) 和删除 (DELETE:/users/:id) 等接口，快速且高效。当我们完成测试和接口后，使用deno的命令行工具，我们可以将整个工程打包为一个.js文件； ❯ make bundle mkdir dist deno bundle src/index.ts dist/platform.js Bundle file:///xxx/deno-restful-api-with-postgresql-tdd/src/index.ts Emit \"dist/platform.js\" (856.11 KB) 对于NodeJs开发的后端应用，可怕的node_modules依赖在打包时会是个问题，一般的Node后端应用都是直接将环境变量更新一下，然后将其部署在生产环境； 开发者写的工程文件并没有多大，而应用依赖的node_modules大多时候时工程文件的几十倍甚至几百倍。然后Deno很好的解决了这个问题。 ","date":"2020-07-24","objectID":"/2020/07/%E5%9F%BA%E4%BA%8Eoak%E7%9A%84%E4%B8%80%E6%AC%A1tdd%E5%AE%9E%E8%B7%B5/:8:0","tags":["deno","oak","tdd","git","mvc","fetch"],"title":"基于 oak 的一次 TDD 实践","uri":"/2020/07/%E5%9F%BA%E4%BA%8Eoak%E7%9A%84%E4%B8%80%E6%AC%A1tdd%E5%AE%9E%E8%B7%B5/"},{"categories":["deno"],"content":"启动应用 如有需要将打包好的.js拷贝到目标目录，只要有Deno环境，我们就可以直接启动应用； ❯ make start APP_PORT=1234 deno run --allow-net --allow-env ./dist/platform.js 数据库链接成功！ Application started, and listen to 127.0.0.1:1234 ","date":"2020-07-24","objectID":"/2020/07/%E5%9F%BA%E4%BA%8Eoak%E7%9A%84%E4%B8%80%E6%AC%A1tdd%E5%AE%9E%E8%B7%B5/:9:0","tags":["deno","oak","tdd","git","mvc","fetch"],"title":"基于 oak 的一次 TDD 实践","uri":"/2020/07/%E5%9F%BA%E4%BA%8Eoak%E7%9A%84%E4%B8%80%E6%AC%A1tdd%E5%AE%9E%E8%B7%B5/"},{"categories":["deno"],"content":"乱中取整 通过学习Deno, 有了一些心得体会； 兼容浏览器API,Deno工程可以使用Javascript和Typescript进行编程，大大降低了认知复杂度和学习难度； 如果使用Typescript开发，那么会避免动态一时爽，重构火葬场的尴尬局面，所以推荐使用Typescript来写应用； 去中心化仓库，以单文件的形式分发，在协作开发的时候，为了统一库版本，就需校验依赖的版本，Deno提供了生成lock.json的形式来保证不同协作者之间的版本依赖； … 最后感谢 海门 和 亦乐 的校对与指导；在他们的帮助下，我顺利完成了这篇博客。 ","date":"2020-07-24","objectID":"/2020/07/%E5%9F%BA%E4%BA%8Eoak%E7%9A%84%E4%B8%80%E6%AC%A1tdd%E5%AE%9E%E8%B7%B5/:10:0","tags":["deno","oak","tdd","git","mvc","fetch"],"title":"基于 oak 的一次 TDD 实践","uri":"/2020/07/%E5%9F%BA%E4%BA%8Eoak%E7%9A%84%E4%B8%80%E6%AC%A1tdd%E5%AE%9E%E8%B7%B5/"},{"categories":["deno"],"content":"Refs 源码：https://github.com/guzhongren/deno-restful-api-with-postgresql-tdd 博客：https://guzhongren.github.io/ Denoland: https://deno.land/ VS Code: https://code.visualstudio.com/ Docker: https://www.docker.com/ Typescript: https://www.typescriptlang.org/ Node: https://nodejs.org/ mock: https://github.com/udibo/mock ","date":"2020-07-24","objectID":"/2020/07/%E5%9F%BA%E4%BA%8Eoak%E7%9A%84%E4%B8%80%E6%AC%A1tdd%E5%AE%9E%E8%B7%B5/:11:0","tags":["deno","oak","tdd","git","mvc","fetch"],"title":"基于 oak 的一次 TDD 实践","uri":"/2020/07/%E5%9F%BA%E4%BA%8Eoak%E7%9A%84%E4%B8%80%E6%AC%A1tdd%E5%AE%9E%E8%B7%B5/"},{"categories":["deno"],"content":"Disclaimer 本文仅代表个人观点，与 Thoughtworks 公司无任何关系。 ","date":"2020-07-24","objectID":"/2020/07/%E5%9F%BA%E4%BA%8Eoak%E7%9A%84%E4%B8%80%E6%AC%A1tdd%E5%AE%9E%E8%B7%B5/:12:0","tags":["deno","oak","tdd","git","mvc","fetch"],"title":"基于 oak 的一次 TDD 实践","uri":"/2020/07/%E5%9F%BA%E4%BA%8Eoak%E7%9A%84%E4%B8%80%E6%AC%A1tdd%E5%AE%9E%E8%B7%B5/"},{"categories":["git"],"content":"使用 git-crypt 加密 git 敏感文件","date":"2020-07-12","objectID":"/2020/07/how-to-encrypt-git-files/","tags":["git-crypt","crypt","RSA","secret","gpg","gnuPG","gpg","加密🔐","transcrypt"],"title":"How to Encrypt Git Files","uri":"/2020/07/how-to-encrypt-git-files/"},{"categories":["git"],"content":"为什么需要 crypt 在开发过程中经常会遇到一个问题： 怎么将敏感数据让特定的人获取到？ 常用的解决方法如下： 使用如 AWS 的 KMS, ParameterStore 等服务，给不同的用户以访问该数据的角色； 有专人托管，在需要的时候联系他，由特定方式转发给你，如加密邮件等 ","date":"2020-07-12","objectID":"/2020/07/how-to-encrypt-git-files/:1:0","tags":["git-crypt","crypt","RSA","secret","gpg","gnuPG","gpg","加密🔐","transcrypt"],"title":"How to Encrypt Git Files","uri":"/2020/07/how-to-encrypt-git-files/"},{"categories":["git"],"content":"分析 对于第二种方式，相对简单粗暴，但是不利于管理。 第一种方案，你需要依托第三方服务，你得绝对信任他，相信他是不会出问题的；再者，你的数据管理也需要有特定的规范，不然你都不知道你存储了什么数据，更不知道有哪些数据。 针对第一种情况，当我们的数据越来多的时候，我们需要将其状态可控起来，其实就是 date as code, 每次对数据的增删改查，我们都可以有追踪和数据保存。 ","date":"2020-07-12","objectID":"/2020/07/how-to-encrypt-git-files/:1:1","tags":["git-crypt","crypt","RSA","secret","gpg","gnuPG","gpg","加密🔐","transcrypt"],"title":"How to Encrypt Git Files","uri":"/2020/07/how-to-encrypt-git-files/"},{"categories":["git"],"content":"有哪些方案呢？ git-crypt transcrypt 在这里，我推荐使用 git-crypt, 其特点如下： 加密后上传 git，在 git 上保存的是二进制文件； 分发密钥给可信开发人员，进行解密，维护配置文件； 解密后为明文内容，如需上传，不用再进行加密，工具自动（配合git hook) 会生成最新的二进制文件后上传； 由c++编写； Mac 可以通过brew 等方式下载； 利用了加密工具gpg进行加密处理。 ","date":"2020-07-12","objectID":"/2020/07/how-to-encrypt-git-files/:2:0","tags":["git-crypt","crypt","RSA","secret","gpg","gnuPG","gpg","加密🔐","transcrypt"],"title":"How to Encrypt Git Files","uri":"/2020/07/how-to-encrypt-git-files/"},{"categories":["git"],"content":"GPG 要了解什么是 GPG，就要先了解 PGP。 1991 年，程序员 Phil Zimmermann 为了避开政府监视，开发了加密软件 PGP。这个软件非常好用，迅速流传开来，成了许多程序员的必备工具。但是，它是商业软件，不能自由使用。所以，自由软件基金会决定，开发一个 PGP 的替代品，取名为 GnuPG。这就是 GPG 的由来。 gpg 可以对密钥的增删改查进行操作，也可以将公钥发送到 pgp 等服务器，让别人搜索到你，具体操作可以参考阮一峰的这片博文 《GPG 入门教程》 ","date":"2020-07-12","objectID":"/2020/07/how-to-encrypt-git-files/:2:1","tags":["git-crypt","crypt","RSA","secret","gpg","gnuPG","gpg","加密🔐","transcrypt"],"title":"How to Encrypt Git Files","uri":"/2020/07/how-to-encrypt-git-files/"},{"categories":["git"],"content":"git-crypt 操作 ","date":"2020-07-12","objectID":"/2020/07/how-to-encrypt-git-files/:3:0","tags":["git-crypt","crypt","RSA","secret","gpg","gnuPG","gpg","加密🔐","transcrypt"],"title":"How to Encrypt Git Files","uri":"/2020/07/how-to-encrypt-git-files/"},{"categories":["git"],"content":"安装 gpg 和 git-crypt brew install git-crypt brew install gpg ","date":"2020-07-12","objectID":"/2020/07/how-to-encrypt-git-files/:3:1","tags":["git-crypt","crypt","RSA","secret","gpg","gnuPG","gpg","加密🔐","transcrypt"],"title":"How to Encrypt Git Files","uri":"/2020/07/how-to-encrypt-git-files/"},{"categories":["git"],"content":"gpg version gpg --version gpg (GnuPG) 2.2.19 libgcrypt 1.8.5 Copyright (C) 2019 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later \u003chttps://gnu.org/licenses/gpl.html\u003e This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Home: /Users/c4/.gnupg 支持的算法： 公钥： RSA, ELG, DSA, ECDH, ECDSA, EDDSA 密文： IDEA, 3DES, CAST5, BLOWFISH, AES, AES192, AES256, TWOFISH, CAMELLIA128, CAMELLIA192, CAMELLIA256 散列： SHA1, RIPEMD160, SHA256, SHA384, SHA512, SHA224 压缩： 不压缩，ZIP, ZLIB, BZIP2 ","date":"2020-07-12","objectID":"/2020/07/how-to-encrypt-git-files/:3:2","tags":["git-crypt","crypt","RSA","secret","gpg","gnuPG","gpg","加密🔐","transcrypt"],"title":"How to Encrypt Git Files","uri":"/2020/07/how-to-encrypt-git-files/"},{"categories":["git"],"content":"生成 gpg userId gpg --full-generate-key gpg (GnuPG) 2.2.19; Copyright (C) 2019 Free Software Foundation, Inc. This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. 请选择您要使用的密钥类型： (1) RSA 和 RSA （默认） (2) DSA 和 Elgamal (3) DSA（仅用于签名） (4) RSA（仅用于签名） (14) Existing key from card 您的选择是？ RSA 密钥的长度应在 1024 位与 4096 位之间。 您想要使用的密钥长度？(2048) 4096 请求的密钥长度是 4096 位 请设定这个密钥的有效期限。 0 = 密钥永不过期 \u003cn\u003e = 密钥在 n 天后过期 \u003cn\u003ew = 密钥在 n 周后过期 \u003cn\u003em = 密钥在 n 月后过期 \u003cn\u003ey = 密钥在 n 年后过期 密钥的有效期限是？(0) 密钥永远不会过期 这些内容正确吗？ (y/N) y GnuPG 需要构建用户标识以辨认您的密钥。 真实姓名： guzhongren 电子邮件地址： guzhongren@live.cn 注释： guzhongren 您选定了此用户标识： “guzhongren (guzhongren) \u003cguzhongren@live.cn\u003e” 更改姓名（N）、注释（C）、电子邮件地址（E）或确定（O）/退出（Q）？ o 我们需要生成大量的随机字节。在质数生成期间做些其他操作（敲打键盘 、移动鼠标、读写硬盘之类的）将会是一个不错的主意；这会让随机数 发生器有更好的机会获得足够的熵。 我们需要生成大量的随机字节。在质数生成期间做些其他操作（敲打键盘 、移动鼠标、读写硬盘之类的）将会是一个不错的主意；这会让随机数 发生器有更好的机会获得足够的熵。 gpg: 密钥 25DD25A47AEF036A 被标记为绝对信任 gpg: 吊销证书已被存储为‘/Users/c4/.gnupg/openpgp-revocs.d/4FA612D2DB4244E7D64A1C1025DD25A47AEF036A.rev’ 公钥和私钥已经生成并被签名。 pub rsa4096 2020-07-11 [SC] 4FA612D2DB4244E7D64A1C1025DD25A47AEF036A uid guzhongren (guzhongren) \u003cguzhongren@live.cn\u003e sub rsa4096 2020-07-11 [E] ","date":"2020-07-12","objectID":"/2020/07/how-to-encrypt-git-files/:3:3","tags":["git-crypt","crypt","RSA","secret","gpg","gnuPG","gpg","加密🔐","transcrypt"],"title":"How to Encrypt Git Files","uri":"/2020/07/how-to-encrypt-git-files/"},{"categories":["git"],"content":"获取 UserID gpg --list-secret-keys --keyid-format LONG gpg: 正在检查信任度数据库 gpg: 绝对信任密钥 8823E362E95562B8 的公钥未找到 gpg: marginals needed: 3 completes needed: 1 trust model: pgp gpg: 深度：0 有效性： 4 已签名： 0 信任度：0-，0q，0n，0m，0f，4u gpg: 下次信任度数据库检查将于 2022-01-26 进行 /Users/c4/.gnupg/pubring.kbx ---------------------------- sec rsa4096/25DD25A47AEF036A 2020-07-11 [SC] 4FA612D2DB4244E7D64A1C1025DD25A47AEF036A uid [ 绝对 ] guzhongren (guzhongren) \u003cguzhongren@live.cn\u003e ssb rsa4096/DCC72940818AB355 2020-07-11 [E] sec rsa4096/25DD25A47AEF036A 2020-07-11 [SC] 中 25DD25A47AEF036A就是 gpg userId ","date":"2020-07-12","objectID":"/2020/07/how-to-encrypt-git-files/:3:4","tags":["git-crypt","crypt","RSA","secret","gpg","gnuPG","gpg","加密🔐","transcrypt"],"title":"How to Encrypt Git Files","uri":"/2020/07/how-to-encrypt-git-files/"},{"categories":["git"],"content":"git-crypt 操作 ","date":"2020-07-12","objectID":"/2020/07/how-to-encrypt-git-files/:4:0","tags":["git-crypt","crypt","RSA","secret","gpg","gnuPG","gpg","加密🔐","transcrypt"],"title":"How to Encrypt Git Files","uri":"/2020/07/how-to-encrypt-git-files/"},{"categories":["git"],"content":"初始化 进入需要做加密的 git repo 做 git-crypt 初始化操作，并将上面获取到的 gpg userId 添加进去 git-crypt init git-crypt add-gpg-user 25DD25A47AEF036A ","date":"2020-07-12","objectID":"/2020/07/how-to-encrypt-git-files/:4:1","tags":["git-crypt","crypt","RSA","secret","gpg","gnuPG","gpg","加密🔐","transcrypt"],"title":"How to Encrypt Git Files","uri":"/2020/07/how-to-encrypt-git-files/"},{"categories":["git"],"content":"加密文件过滤器.gitattributes 格式为： * filter=git-crypt diff=git-crypt ；如下，我需要加密secretfile, *.key和secretdir/**, 那么内容如下： secretfile filter=git-crypt diff=git-crypt *.key filter=git-crypt diff=git-crypt secretdir/** filter=git-crypt diff=git-crypt ","date":"2020-07-12","objectID":"/2020/07/how-to-encrypt-git-files/:4:2","tags":["git-crypt","crypt","RSA","secret","gpg","gnuPG","gpg","加密🔐","transcrypt"],"title":"How to Encrypt Git Files","uri":"/2020/07/how-to-encrypt-git-files/"},{"categories":["git"],"content":"清理 config 的 git 缓存 git rm -r –cached config ","date":"2020-07-12","objectID":"/2020/07/how-to-encrypt-git-files/:4:3","tags":["git-crypt","crypt","RSA","secret","gpg","gnuPG","gpg","加密🔐","transcrypt"],"title":"How to Encrypt Git Files","uri":"/2020/07/how-to-encrypt-git-files/"},{"categories":["git"],"content":"添加需要加密的文件和数据 在secretdir文件夹下添加 secret.yaml, 并添加如下内容： username:password ","date":"2020-07-12","objectID":"/2020/07/how-to-encrypt-git-files/:4:4","tags":["git-crypt","crypt","RSA","secret","gpg","gnuPG","gpg","加密🔐","transcrypt"],"title":"How to Encrypt Git Files","uri":"/2020/07/how-to-encrypt-git-files/"},{"categories":["git"],"content":"上传到 git 仓库 此步不用担心你的secret.yaml文件以明文的形式上传，git-crypt 会在 commit 之前将过滤后的数据加密成二进制，所以不用担心在仓库中存储敏感信息。 git add . git commit -m ‘git-crypt’ git push 如果你去 git 仓库中浏览 secret.yaml 文件，会是一个二进制文件，如图： ","date":"2020-07-12","objectID":"/2020/07/how-to-encrypt-git-files/:4:5","tags":["git-crypt","crypt","RSA","secret","gpg","gnuPG","gpg","加密🔐","transcrypt"],"title":"How to Encrypt Git Files","uri":"/2020/07/how-to-encrypt-git-files/"},{"categories":["git"],"content":"协作 与他人协作，别人需要知道对应解密的 key ","date":"2020-07-12","objectID":"/2020/07/how-to-encrypt-git-files/:5:0","tags":["git-crypt","crypt","RSA","secret","gpg","gnuPG","gpg","加密🔐","transcrypt"],"title":"How to Encrypt Git Files","uri":"/2020/07/how-to-encrypt-git-files/"},{"categories":["git"],"content":"导出密钥 git-crypt export-key ~/Desktop/git-crypt.key 得到 git-crypt.key 后，将该密钥分发给可信的团队成员，团队成员将仓库 clone 下来后，使用如下命令解密即可 git-crypt unlock /path/to/git-crypt.key 此时，在本地就可以看到加密后的文件内容了。 ","date":"2020-07-12","objectID":"/2020/07/how-to-encrypt-git-files/:5:1","tags":["git-crypt","crypt","RSA","secret","gpg","gnuPG","gpg","加密🔐","transcrypt"],"title":"How to Encrypt Git Files","uri":"/2020/07/how-to-encrypt-git-files/"},{"categories":["git"],"content":"更新密钥 因为 git-crypt 没有提供删除或者更新密钥的命令，所以参考了一个 issue: https://github.com/AGWA/git-crypt/issues/47#issuecomment-492939759; 步骤如下： Make a backup (with decrypted files): cp -r . /path/to/backup Save a list of files that are encrypted: git crypt status | grep -v ’not encrypted’ \u003e ../encrypted-files.txt Make git-crypt forget about itself: rm .git-crypt Delete the encrypted files: awk ‘{print $2}’ ../encrypted-files.txt | xargs rm Commit (at this point you get a repo without git-crypt stuff) Add git-crypt from scratch (init and add-gpg-user) Copy the decrypted files from the backup: awk ‘{print $2}’ ../encrypted-files.txt | while read l; do cp /path/to/backup/$l $l; done Commit (at this point you are done, but be sure to verify things are properly encrypted before publishing) 实践结果：在更新完成之后，协作者需要重新 clone 仓库，然后用新的密钥来解密，对密钥管理者来说操作比较麻烦 ","date":"2020-07-12","objectID":"/2020/07/how-to-encrypt-git-files/:5:2","tags":["git-crypt","crypt","RSA","secret","gpg","gnuPG","gpg","加密🔐","transcrypt"],"title":"How to Encrypt Git Files","uri":"/2020/07/how-to-encrypt-git-files/"},{"categories":["git"],"content":"总结 在敏感数据越来越多的时候，作为开发者，我们更应该将所有的数据都as code, 为以后维护提供方便。git-crypt确实是一个比较好的选择。 但是git-crypt有一个最大的缺点： 只能添加不能删除 gpg userId, 导致更新密钥会比较麻烦，如果要更新密钥，那么就需要做重置 ","date":"2020-07-12","objectID":"/2020/07/how-to-encrypt-git-files/:5:3","tags":["git-crypt","crypt","RSA","secret","gpg","gnuPG","gpg","加密🔐","transcrypt"],"title":"How to Encrypt Git Files","uri":"/2020/07/how-to-encrypt-git-files/"},{"categories":["git"],"content":"Refs Demo: git-crypt-test 博客：https://guzhongren.github.io/ https://gnupg.org/ AGWA/git-crypt git-crypt 使用 git 上的配置文件如何加密？ Easy Git Crypt User Identification Update git crypt key List gpg user Gnu 隐私卫士 (GnuPG) 袖珍 HOWTO （中文版） transcrypt 使用案例 ","date":"2020-07-12","objectID":"/2020/07/how-to-encrypt-git-files/:6:0","tags":["git-crypt","crypt","RSA","secret","gpg","gnuPG","gpg","加密🔐","transcrypt"],"title":"How to Encrypt Git Files","uri":"/2020/07/how-to-encrypt-git-files/"},{"categories":["git"],"content":"Disclaimer 本文仅代表个人观点，与 Thoughtworks 公司无任何关系。 ","date":"2020-07-12","objectID":"/2020/07/how-to-encrypt-git-files/:7:0","tags":["git-crypt","crypt","RSA","secret","gpg","gnuPG","gpg","加密🔐","transcrypt"],"title":"How to Encrypt Git Files","uri":"/2020/07/how-to-encrypt-git-files/"},{"categories":["Deno"],"content":"视频记录了我基于Deno Web 框架 oak 使用 TDD的方式写的一个简单的工程化的 demo。 ","date":"2020-07-05","objectID":"/2020/07/%E5%9F%BA%E4%BA%8Edeno%E7%9A%84%E4%B8%80%E6%AC%A1tdd%E5%AE%9E%E8%B7%B5/:0:0","tags":["deno","code","oak","api","TDD","typescript"],"title":"基于 Deno 的一次 TDD 实践","uri":"/2020/07/%E5%9F%BA%E4%BA%8Edeno%E7%9A%84%E4%B8%80%E6%AC%A1tdd%E5%AE%9E%E8%B7%B5/"},{"categories":["Deno"],"content":"Refs 1. 博客：https://guzhongren.github.io/ 2. 图床：https://sm.ms/ 3.Bilibili ","date":"2020-07-05","objectID":"/2020/07/%E5%9F%BA%E4%BA%8Edeno%E7%9A%84%E4%B8%80%E6%AC%A1tdd%E5%AE%9E%E8%B7%B5/:1:0","tags":["deno","code","oak","api","TDD","typescript"],"title":"基于 Deno 的一次 TDD 实践","uri":"/2020/07/%E5%9F%BA%E4%BA%8Edeno%E7%9A%84%E4%B8%80%E6%AC%A1tdd%E5%AE%9E%E8%B7%B5/"},{"categories":["Deno"],"content":"Disclaimer 本文仅代表个人观点，与 Thoughtworks 公司无任何关系。 ","date":"2020-07-05","objectID":"/2020/07/%E5%9F%BA%E4%BA%8Edeno%E7%9A%84%E4%B8%80%E6%AC%A1tdd%E5%AE%9E%E8%B7%B5/:2:0","tags":["deno","code","oak","api","TDD","typescript"],"title":"基于 Deno 的一次 TDD 实践","uri":"/2020/07/%E5%9F%BA%E4%BA%8Edeno%E7%9A%84%E4%B8%80%E6%AC%A1tdd%E5%AE%9E%E8%B7%B5/"},{"categories":["TDD"],"content":"Window 对象的各种测试方法总结","date":"2020-06-07","objectID":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/","tags":["TDD","window","window.location","spyOn","jest","Object.defineProperty","mock"],"title":"Window 对象的各种测试方法总结","uri":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["TDD"],"content":"前言 在平时前端项目开发中有很多需要对window对象进行进行操作，比如改变window.location.href的值，在前端页面中，这会使浏览器发生页面跳转，还有如window.location.replace(), 那么在测试中，虽然 jest 会有部分初始值，但有时候我们需要明确给定值，让测试更明确。 ","date":"2020-06-07","objectID":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/:1:0","tags":["TDD","window","window.location","spyOn","jest","Object.defineProperty","mock"],"title":"Window 对象的各种测试方法总结","uri":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["TDD"],"content":"Window 对象测试分析 window 对象有属性 (property) 和方法 (method), 在此我们以href, window.location.href + hash 和 postMessage几个特性来测试， 对每个类型 (property/method) 将使用至少三种方法来展示，测试方法可以分为如下四类： delete - 在原对象 window 上进行测试 Object.defineProperty - 重新定义属性 mockfile - mock 整个被测文件 spyOn - 对特定方法进行 mock ","date":"2020-06-07","objectID":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/:2:0","tags":["TDD","window","window.location","spyOn","jest","Object.defineProperty","mock"],"title":"Window 对象的各种测试方法总结","uri":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["TDD"],"content":"被测文件 在这可以不用遵循TDD的流程，直接给出被测文件内容，也可在 github export const changeHref = (value: string) =\u003e { window.location.href = value } export const addHash = (hash: string): string =\u003e { return window.location.href + `#${hash}` } export const sendMessage = (message) =\u003e { window.top.postMessage({ type: 'message', data: message, }, '*' ) } ","date":"2020-06-07","objectID":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/:3:0","tags":["TDD","window","window.location","spyOn","jest","Object.defineProperty","mock"],"title":"Window 对象的各种测试方法总结","uri":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["TDD"],"content":"测试 ","date":"2020-06-07","objectID":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/:4:0","tags":["TDD","window","window.location","spyOn","jest","Object.defineProperty","mock"],"title":"Window 对象的各种测试方法总结","uri":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["TDD"],"content":"property - changeHref delete import { changeHref } from '../src/attribute' describe('attribute', () =\u003e { const { location } = window beforeEach(() =\u003e { delete window.location }) afterEach(() =\u003e { window.location = location }) it('should change href to http://test.com when newURL is http://test.com', () =\u003e { const newURL = \"http://test.com\" window.location = { ...location, href: '' } changeHref(newURL) expect(window.location.href).toBe(newURL) }) }) Object.defineProperty import { changeHref } from '../src/attribute' describe('attribute', () =\u003e { let windowSpy; beforeEach(() =\u003e { windowSpy= jest.spyOn(window, 'location', 'get') }) afterEach(() =\u003e{ windowSpy.mockRestore() }) it('jest.spyOn', () =\u003e { expect(window.location.href).toBe('http://localhost/') const newURL = \"http://test.com\" windowSpy.mockImplementation(() =\u003e ({ href: '' })) changeHref(newURL) expect(windowSpy).toHaveBeenCalled() }) }) spyOn import { changeHref } from '../src/attribute' describe('attribute', () =\u003e { let windowSpy; beforeEach(() =\u003e { windowSpy= jest.spyOn(window, 'location', 'get') }) afterEach(() =\u003e{ windowSpy.mockRestore() }) it('jest.spyOn', () =\u003e { expect(window.location.href).toBe('http://localhost/') const newURL = \"http://test.com\" windowSpy.mockImplementation(() =\u003e ({ href: '' })) changeHref(newURL) expect(windowSpy).toHaveBeenCalled() }) }) ","date":"2020-06-07","objectID":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/:4:1","tags":["TDD","window","window.location","spyOn","jest","Object.defineProperty","mock"],"title":"Window 对象的各种测试方法总结","uri":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["TDD"],"content":"method - addHash delete import { addHash } from '../src/attribute' describe('method', () =\u003e { const { location } = window beforeEach(() =\u003e { delete window.location; window.location = { ...location, href: 'http://href.com' } }) afterEach(() =\u003e { window.location = location }) it(\"should return http://href.com#123 when give 123\", () =\u003e { expect(addHash('123')).toEqual('http://href.com#123') }) }) Object.defineProperty import { addHash } from '../src/attribute' describe('method', () =\u003e { const { location } = window beforeEach(() =\u003e { Object.defineProperty(window, 'location', { value: { ...location, href: 'http://href.com', }, }) }) afterEach(() =\u003e { Object.defineProperty(window, 'location', location) }) it(\"should return http://href.com#123 when give 123\", () =\u003e { expect(addHash('123')).toEqual('http://href.com#123') }) }) mockFile import * as attribute from '../src/attribute' jest.mock('../src/attribute', () =\u003e { return { __esModule: true, addHash: jest.fn(), }; }); beforeEach( () =\u003e { jest.resetModules(); }) describe('method', () =\u003e { it('mocks `addHash`', () =\u003e { expect(jest.isMockFunction(attribute.addHash)).toBe(true); }); it('verify method has been invoked', () =\u003e { expect(attribute.addHash).not.toHaveBeenCalled(); // will failed // expect(attribute.addHash('test')).toEqual('http://localhost/#test') attribute.addHash('234') expect(attribute.addHash).toHaveBeenCalled() expect(attribute.addHash).toBeCalledTimes(1) expect(attribute.addHash).toBeCalledWith('234') }) }) spyOn import { addHash } from '../src/attribute' describe('method', () =\u003e { let windowSpy beforeEach(() =\u003e { windowSpy = jest.spyOn(window, 'location', 'get') }) afterEach(() =\u003e { windowSpy.mockRestore() }) it('mocks `addHash`', () =\u003e { expect(jest.isMockFunction(windowSpy)).toBe(true) }); it('spyOn for addHash', () =\u003e { windowSpy.mockImplementation(() =\u003e ({ href: 'http://test.com', })) expect(windowSpy).not.toHaveBeenCalled() expect(addHash('123')).toEqual('http://test.com#123') expect(windowSpy).toHaveBeenCalled(); }) }) ","date":"2020-06-07","objectID":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/:4:2","tags":["TDD","window","window.location","spyOn","jest","Object.defineProperty","mock"],"title":"Window 对象的各种测试方法总结","uri":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["TDD"],"content":"method - postMessage import {sendMessage} from '../src/attribute' describe('multiple', () =\u003e { it('sendMessage test with multiple test method', () =\u003e { Object.defineProperty(window, 'top', { value: window, writable: true, enumerable: true, configurable: true, }) Object.defineProperty(window, 'postMessage', { writable: true, value: jest.fn(), }) sendMessage('message') expect(window.parent.postMessage).toHaveBeenCalled() expect(window.parent.postMessage).toBeCalledTimes(1) }) }) ","date":"2020-06-07","objectID":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/:4:3","tags":["TDD","window","window.location","spyOn","jest","Object.defineProperty","mock"],"title":"Window 对象的各种测试方法总结","uri":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["TDD"],"content":"总结 总结就是整理自己，方便自己，如若能方便他人，那就是意外了。 源代码：https://github.com/AndorLab/test-window-object ","date":"2020-06-07","objectID":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/:5:0","tags":["TDD","window","window.location","spyOn","jest","Object.defineProperty","mock"],"title":"Window 对象的各种测试方法总结","uri":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["TDD"],"content":"Refs 1. 博客：https://guzhongren.github.io/ 2. 图床：https://sm.ms/ 3.mock-window-location 4.jest-how-to-mock-window-location-href 5.Global Object defineProperty 6.test double ","date":"2020-06-07","objectID":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/:6:0","tags":["TDD","window","window.location","spyOn","jest","Object.defineProperty","mock"],"title":"Window 对象的各种测试方法总结","uri":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["TDD"],"content":"Disclaimer 本文仅代表个人观点，与 Thoughtworks 公司无任何关系。 ","date":"2020-06-07","objectID":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/:7:0","tags":["TDD","window","window.location","spyOn","jest","Object.defineProperty","mock"],"title":"Window 对象的各种测试方法总结","uri":"/2020/06/window%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["Rust"],"content":"问题 ❯ cargo run error: failed to run `rustc` to learn about target-specific information Caused by: process didn't exit successfully: `rustc - --crate-name ___ --print=file-names -Zprofile -Ccodegen-units=1 -Copt-level=0 -Clink-dead-code -Coverflow-checks=off -Zpanic_abort_tests -Cpanic=abort --crate-type bin --crate-type rlib --crate-type dylib --crate-type cdylib --crate-type staticlib --crate-type proc-macro --print=sysroot --print=cfg` (exit code: 1) --- stderr error: the option `Z` is only accepted on the nightly compiler` 最近更新了rust, 然后运行cargo run, 莫名其妙的出现了上面的问题。 ","date":"2020-06-06","objectID":"/2020/06/cargo%E8%BF%90%E8%A1%8C%E5%87%BA%E9%94%99%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/:1:0","tags":["rust","nightly","cargo","rustup","-Zprofile"],"title":"Cargo 运行出错及解决方案","uri":"/2020/06/cargo%E8%BF%90%E8%A1%8C%E5%87%BA%E9%94%99%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"categories":["Rust"],"content":"原因 在 rust 官网的 issue 里找解决方案，都是 open 状态的，没有实际意义。那么就得回到原始方式。 按照提示，说Z 这个参数仅适用于nightly版本的 rust 编译器，但是我用的是stable版本的 rust; ❯ rustup show Default host: x86_64-apple-darwin rustup home: /Users/c4/.rustup stable-x86_64-apple-darwin (default) rustc 1.44.0 (49cae5576 2020-06-01) 版本确定，那么只能将语音归结到命令行某个地方有注入参数。第一个想到的就是环境变量，打开我的~/.zshrc, 果然在最下面找到了这么一条记录，看到-Z, 应该就是他了。 export RUSTFLAGS=\"-Zprofile -Ccodegen-units=1 -Copt-level=0 -Clink-dead-code -Coverflow-checks=off -Zpanic_abort_tests -Cpanic=abort\" ","date":"2020-06-06","objectID":"/2020/06/cargo%E8%BF%90%E8%A1%8C%E5%87%BA%E9%94%99%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/:2:0","tags":["rust","nightly","cargo","rustup","-Zprofile"],"title":"Cargo 运行出错及解决方案","uri":"/2020/06/cargo%E8%BF%90%E8%A1%8C%E5%87%BA%E9%94%99%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"categories":["Rust"],"content":"解决方案 删除该行记录，运行程序，成功输出hello world。 ","date":"2020-06-06","objectID":"/2020/06/cargo%E8%BF%90%E8%A1%8C%E5%87%BA%E9%94%99%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/:3:0","tags":["rust","nightly","cargo","rustup","-Zprofile"],"title":"Cargo 运行出错及解决方案","uri":"/2020/06/cargo%E8%BF%90%E8%A1%8C%E5%87%BA%E9%94%99%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"categories":["Rust"],"content":"Refs 1. 博客：https://guzhongren.github.io/ 2. 图床：https://sm.ms/ 3. grcov ","date":"2020-06-06","objectID":"/2020/06/cargo%E8%BF%90%E8%A1%8C%E5%87%BA%E9%94%99%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/:4:0","tags":["rust","nightly","cargo","rustup","-Zprofile"],"title":"Cargo 运行出错及解决方案","uri":"/2020/06/cargo%E8%BF%90%E8%A1%8C%E5%87%BA%E9%94%99%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"categories":["Rust"],"content":"Disclaimer 本文仅代表个人观点，与 Thoughtworks 公司无任何关系。 ","date":"2020-06-06","objectID":"/2020/06/cargo%E8%BF%90%E8%A1%8C%E5%87%BA%E9%94%99%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/:5:0","tags":["rust","nightly","cargo","rustup","-Zprofile"],"title":"Cargo 运行出错及解决方案","uri":"/2020/06/cargo%E8%BF%90%E8%A1%8C%E5%87%BA%E9%94%99%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"categories":["Deno"],"content":"引子 有些时候，软件开发过程中没有将系统功能，且分开从而将系统拆分为多个子系统，或者在自身系统开发过程中有必须要依赖的外部服务，那么对外提供服务的时候就得让所有的子服务都得随时候命， 排列起来就像古代战场的对战状态一样了。 ","date":"2020-05-23","objectID":"/2020/05/%E6%95%B4%E5%90%88%E8%B5%84%E6%BA%90%E4%B8%BA%E5%85%B6%E4%BB%96%E7%AB%AF%E6%8F%90%E4%BE%9B%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90/:1:0","tags":["deno","URL","TypeScript","JavaScript","GET","oak","backend"],"title":"整合资源为其他端提供统一资源","uri":"/2020/05/%E6%95%B4%E5%90%88%E8%B5%84%E6%BA%90%E4%B8%BA%E5%85%B6%E4%BB%96%E7%AB%AF%E6%8F%90%E4%BE%9B%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90/"},{"categories":["Deno"],"content":"存在的问题 对于这种情况存在什么问题呢？ 想象一个场景，作为老板或者业务对接方，我要集成和之前一样的系统，我要对接这么多接口么？如果对接方看到这么多的系统接口要对接，他肯定就放弃治疗了。 总结一下存在的问题。 对接系统接口较多，还可能对接很多个域名 作为对接方，系统接口出了问题，我得看是哪个系统出问题了，还得去找对应的对接方 不同的接口，可能存在不同的甩锅行为 乱，新人很难很快上手 多则乱，乱则要花很多钱 ","date":"2020-05-23","objectID":"/2020/05/%E6%95%B4%E5%90%88%E8%B5%84%E6%BA%90%E4%B8%BA%E5%85%B6%E4%BB%96%E7%AB%AF%E6%8F%90%E4%BE%9B%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90/:2:0","tags":["deno","URL","TypeScript","JavaScript","GET","oak","backend"],"title":"整合资源为其他端提供统一资源","uri":"/2020/05/%E6%95%B4%E5%90%88%E8%B5%84%E6%BA%90%E4%B8%BA%E5%85%B6%E4%BB%96%E7%AB%AF%E6%8F%90%E4%BE%9B%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90/"},{"categories":["Deno"],"content":"解决方案 对于上面提到的各种问题，我们有什么解决方案呢？ 最近，微服务的概念比较流行， 我们想想一下前端微服务是怎么组合的？是不是将很多个子页面服务都集成在一个一面中，最终这个页面为用户服务。让这个页面作为对接点。结合上面的图，我们可以设计如下图的方案， 抽离一个中间层，我们暂时可以称之为 Platform， 让所有的资源都从Platform进和出，将要集成的各种服务屏蔽在Platform后面，对于对接方，他永远只知道一个Platform， 这样集成起来就好多了。 ","date":"2020-05-23","objectID":"/2020/05/%E6%95%B4%E5%90%88%E8%B5%84%E6%BA%90%E4%B8%BA%E5%85%B6%E4%BB%96%E7%AB%AF%E6%8F%90%E4%BE%9B%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90/:3:0","tags":["deno","URL","TypeScript","JavaScript","GET","oak","backend"],"title":"整合资源为其他端提供统一资源","uri":"/2020/05/%E6%95%B4%E5%90%88%E8%B5%84%E6%BA%90%E4%B8%BA%E5%85%B6%E4%BB%96%E7%AB%AF%E6%8F%90%E4%BE%9B%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90/"},{"categories":["Deno"],"content":"Coding 方案也有了，那么接下来就是撸起袖子加油干的时候了。 因为 Platform 会是一个后端的工程，其对外提供各种接口和资源；最近Deno比较🔥，为了尝试真香定律， 我们就拿它来实践一下。 ","date":"2020-05-23","objectID":"/2020/05/%E6%95%B4%E5%90%88%E8%B5%84%E6%BA%90%E4%B8%BA%E5%85%B6%E4%BB%96%E7%AB%AF%E6%8F%90%E4%BE%9B%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90/:4:0","tags":["deno","URL","TypeScript","JavaScript","GET","oak","backend"],"title":"整合资源为其他端提供统一资源","uri":"/2020/05/%E6%95%B4%E5%90%88%E8%B5%84%E6%BA%90%E4%B8%BA%E5%85%B6%E4%BB%96%E7%AB%AF%E6%8F%90%E4%BE%9B%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90/"},{"categories":["Deno"],"content":"业务 对于后端请求另一个后端接口，将请求的结果再返回给请求者，这个很容易实现， 我们就不实现了；那么我们来做一个不同的操作。 业务流程 某个后端提供前端资源， 这个资源是由这个后端服务团队维护，且这个服务需要在前端使用 在此， 我们将这个后端资源暂时抽象为jquery.js, 提供 jquery.js 服务的团队就是被我们 Platform 屏蔽起来的服务团队， 对我们本次实践来说就是某一个提供 Jquery 的 CDN 服务商。 具体的 Code 在此，如有需要可随时查看。在实现过程中也有两种方案， 资源请求的前端页面代码如下，重点就是 script标签中src的获取是一个 GET请求！ \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003cscript src=\"http://localhost:8000/custom/domain/jquery.js\"\u003e\u003c/script\u003e \u003c/head\u003e 方案 1 // handlers/fetchJquery.ts export const redirect = async ({ response }: { response: Response }) =\u003e { response.redirect(jqueryUrl) } 这种方案是将资源的请求转发到 jquery 的资源服务地址上，让浏览器自动 302 跳转到该地址，进行资源获取。 方案 2 // handlers/fetchJquery.ts export const getContent = async ({ response }: { response: Response }) =\u003e { response.body = await fetchResponse(jqueryUrl); }; // services/fetchResource.ts export default async (url: string) =\u003e { return fetch(url).then((res) =\u003e res.body); }; 这种方案是将资源请求到服务器，然后将资源再返回给前端。 ","date":"2020-05-23","objectID":"/2020/05/%E6%95%B4%E5%90%88%E8%B5%84%E6%BA%90%E4%B8%BA%E5%85%B6%E4%BB%96%E7%AB%AF%E6%8F%90%E4%BE%9B%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90/:4:1","tags":["deno","URL","TypeScript","JavaScript","GET","oak","backend"],"title":"整合资源为其他端提供统一资源","uri":"/2020/05/%E6%95%B4%E5%90%88%E8%B5%84%E6%BA%90%E4%B8%BA%E5%85%B6%E4%BB%96%E7%AB%AF%E6%8F%90%E4%BE%9B%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90/"},{"categories":["Deno"],"content":"总结 对于这两种方案，更加推荐第一种；第一种方案将资源的路径返回给前端然后由浏览器做跳转并将资源请求回来， 而第二种需要将资源请求回来，如果该资源的请求量比较大，那么就得做缓存，相比于第一种，第二种 Platform 在后期维护也不好，而且压力会在 Platform 和被屏蔽的服务那里，多了不必要的麻烦。 ","date":"2020-05-23","objectID":"/2020/05/%E6%95%B4%E5%90%88%E8%B5%84%E6%BA%90%E4%B8%BA%E5%85%B6%E4%BB%96%E7%AB%AF%E6%8F%90%E4%BE%9B%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90/:5:0","tags":["deno","URL","TypeScript","JavaScript","GET","oak","backend"],"title":"整合资源为其他端提供统一资源","uri":"/2020/05/%E6%95%B4%E5%90%88%E8%B5%84%E6%BA%90%E4%B8%BA%E5%85%B6%E4%BB%96%E7%AB%AF%E6%8F%90%E4%BE%9B%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90/"},{"categories":["Deno"],"content":"Refs 1. 博客：https://guzhongren.github.io/ 2. 图床：https://sm.ms/ 3.ForwardJS 4. 了不起的 Deno 实战教程 ","date":"2020-05-23","objectID":"/2020/05/%E6%95%B4%E5%90%88%E8%B5%84%E6%BA%90%E4%B8%BA%E5%85%B6%E4%BB%96%E7%AB%AF%E6%8F%90%E4%BE%9B%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90/:6:0","tags":["deno","URL","TypeScript","JavaScript","GET","oak","backend"],"title":"整合资源为其他端提供统一资源","uri":"/2020/05/%E6%95%B4%E5%90%88%E8%B5%84%E6%BA%90%E4%B8%BA%E5%85%B6%E4%BB%96%E7%AB%AF%E6%8F%90%E4%BE%9B%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90/"},{"categories":[""],"content":"go 的 import 其实是去 GOROOT 下去加载你写的模块，当然 Go 的 import 还支持如下两种方式来加载自己写的模块： 相对路径 import \"./model\" //当前文件同一目录的 model 目录，但是不建议这种方式 import 绝对路径 import \"shorturl/model\" //加载 GOPATH/src/shorturl/model 模块 上面展示了一些 import 常用的几种方式，但是还有一些特殊的 import，让很多新手很费解，下面是三种导入包的使用方法。 点操作 有时候会看到如下的方式导入包 import( . “fmt” ), 这个点操作的含义就是这个包导入之后在你调用这个包的函数时，你可以省略前缀的包名，也就是前面你调用的 fmt.Println(“hello world”) 可以省略的写成 Println(“hello world”) 别名操作 别名操作顾名思义可以把包命名成另一个用起来容易记忆的名字 import( f “fmt” ) 别名操作调用包函数时前缀变成了重命名的前缀，即 f.Println(“hello world”) _操作 这个操作经常是让很多人费解的一个操作符，请看下面这个 import import ( “database/sql” _ “github.com/ziutek/mymysql/godrv” _操作其实只是引入该包。当导入一个包时，它所有的 init() 函数就会被执行，但有些时候并非真的需要使用这些包，仅仅是希望它的 init() 函数被执行而已。这个时候就可以使用_操作引用该包了。即使用_操作引用包是无法通过包名来调用包中的导出函数，而是只是为了简单的调用其 init 函数 ()。 ","date":"2020-05-16","objectID":"/2020/05/go-import%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/:0:0","tags":[""],"title":"Go Import 相关操作","uri":"/2020/05/go-import%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/"},{"categories":[""],"content":"Refs 1. 博客：https://guzhongren.github.io/ 2. 图床：https://sm.ms/ ","date":"2020-05-16","objectID":"/2020/05/go-import%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/:1:0","tags":[""],"title":"Go Import 相关操作","uri":"/2020/05/go-import%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/"},{"categories":[""],"content":"Disclaimer 本文仅代表个人观点，与 Thoughtworks 公司无任何关系。 ","date":"2020-05-16","objectID":"/2020/05/go-import%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/:2:0","tags":[""],"title":"Go Import 相关操作","uri":"/2020/05/go-import%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/"},{"categories":[""],"content":"产品的特性 要像牙刷，高频切实用 对用户一定要有价值，如谷歌搜索，反面教材如百度 ","date":"2020-05-16","objectID":"/2020/05/%E9%9A%8F%E8%AE%B0-%E7%9F%A5%E8%AF%86%E7%82%B9/:1:0","tags":[""],"title":"随记-知识点","uri":"/2020/05/%E9%9A%8F%E8%AE%B0-%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":[""],"content":"协作 协作的基础是对知识点的认同 ","date":"2020-05-16","objectID":"/2020/05/%E9%9A%8F%E8%AE%B0-%E7%9F%A5%E8%AF%86%E7%82%B9/:2:0","tags":[""],"title":"随记-知识点","uri":"/2020/05/%E9%9A%8F%E8%AE%B0-%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":[""],"content":"个人品牌 个人魅力，个人品牌 ","date":"2020-05-16","objectID":"/2020/05/%E9%9A%8F%E8%AE%B0-%E7%9F%A5%E8%AF%86%E7%82%B9/:3:0","tags":[""],"title":"随记-知识点","uri":"/2020/05/%E9%9A%8F%E8%AE%B0-%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":[""],"content":"解决问题 阐述问题，探寻本质，给出解决方案 ","date":"2020-05-16","objectID":"/2020/05/%E9%9A%8F%E8%AE%B0-%E7%9F%A5%E8%AF%86%E7%82%B9/:4:0","tags":[""],"title":"随记-知识点","uri":"/2020/05/%E9%9A%8F%E8%AE%B0-%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":[""],"content":"知识点 ","date":"2020-05-16","objectID":"/2020/05/%E9%9A%8F%E8%AE%B0-%E7%9F%A5%E8%AF%86%E7%82%B9/:5:0","tags":[""],"title":"随记-知识点","uri":"/2020/05/%E9%9A%8F%E8%AE%B0-%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":[""],"content":"马尔萨斯陷阱 200 多年前，英国经济学家马尔萨斯提出，人口按几何级数增长，而粮食只能按算术级数增长。这样，人口增加到一定程度便出现粮食紧缺、人地矛盾，不可避免地反复出现饥馑、战争和疾病。（《人口原理》，马尔萨斯）， 举例：黑死病、西班牙大流感的传染病，伯罗奔尼撒战争、百年战争、一战二战的大规模战争，孟加拉大饥荒、印度大饥荒的大灾难 ","date":"2020-05-16","objectID":"/2020/05/%E9%9A%8F%E8%AE%B0-%E7%9F%A5%E8%AF%86%E7%82%B9/:5:1","tags":[""],"title":"随记-知识点","uri":"/2020/05/%E9%9A%8F%E8%AE%B0-%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":[""],"content":"Refs 1. 博客：https://guzhongren.github.io/ 2. 图床：https://sm.ms/ ","date":"2020-05-16","objectID":"/2020/05/%E9%9A%8F%E8%AE%B0-%E7%9F%A5%E8%AF%86%E7%82%B9/:6:0","tags":[""],"title":"随记-知识点","uri":"/2020/05/%E9%9A%8F%E8%AE%B0-%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":[""],"content":"Disclaimer 本文仅代表个人观点，与 Thoughtworks 公司无任何关系。 ","date":"2020-05-16","objectID":"/2020/05/%E9%9A%8F%E8%AE%B0-%E7%9F%A5%E8%AF%86%E7%82%B9/:7:0","tags":[""],"title":"随记-知识点","uri":"/2020/05/%E9%9A%8F%E8%AE%B0-%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["Rust"],"content":"前言 学习 Rust 肯定离不开查看其官方或者第三方开发者的文档，而在 Rust 的 crate 中，对于开发者或者使用者，文档是非常友好的。在这就不举例了。本文主要是记录一下写 rust doc 的一些小步骤。方便日后查阅。 ","date":"2020-04-16","objectID":"/2020/04/rust-doc%E5%B0%8F%E8%AE%B0.zh/:1:0","tags":["Rust","doc","comment","rust docs --open","lib","tips"],"title":"Rust Doc 小记","uri":"/2020/04/rust-doc%E5%B0%8F%E8%AE%B0.zh/"},{"categories":["Rust"],"content":"示例 ","date":"2020-04-16","objectID":"/2020/04/rust-doc%E5%B0%8F%E8%AE%B0.zh/:2:0","tags":["Rust","doc","comment","rust docs --open","lib","tips"],"title":"Rust Doc 小记","uri":"/2020/04/rust-doc%E5%B0%8F%E8%AE%B0.zh/"},{"categories":["Rust"],"content":"生成项目 $ cargo new mylib --lib ","date":"2020-04-16","objectID":"/2020/04/rust-doc%E5%B0%8F%E8%AE%B0.zh/:2:1","tags":["Rust","doc","comment","rust docs --open","lib","tips"],"title":"Rust Doc 小记","uri":"/2020/04/rust-doc%E5%B0%8F%E8%AE%B0.zh/"},{"categories":["Rust"],"content":"编写 lib.rs 中的实现 pubfn add_one(x: i32)-\u003e i32 {x+1} ","date":"2020-04-16","objectID":"/2020/04/rust-doc%E5%B0%8F%E8%AE%B0.zh/:2:2","tags":["Rust","doc","comment","rust docs --open","lib","tips"],"title":"Rust Doc 小记","uri":"/2020/04/rust-doc%E5%B0%8F%E8%AE%B0.zh/"},{"categories":["Rust"],"content":"为 add_one 添加注释 最终效果如下： //! My Crate name //! //! `my_crate_name` is test for studying /// Add one for the number given /// /// #Example /// /// ```rust ///let five = 5 ///assert_eq!(6, rust_study::add_one(five)); /// ``` /// pubfn add_one(x: i32)-\u003e i32 {x+1} ","date":"2020-04-16","objectID":"/2020/04/rust-doc%E5%B0%8F%E8%AE%B0.zh/:2:3","tags":["Rust","doc","comment","rust docs --open","lib","tips"],"title":"Rust Doc 小记","uri":"/2020/04/rust-doc%E5%B0%8F%E8%AE%B0.zh/"},{"categories":["Rust"],"content":"生成 rust 标准文档并查看 $ cargo doc --open 执行如上命令，cargo 会根据注释生成 web 网页文档，并且自动打开，如下是上面文档生成的结果。 ","date":"2020-04-16","objectID":"/2020/04/rust-doc%E5%B0%8F%E8%AE%B0.zh/:2:4","tags":["Rust","doc","comment","rust docs --open","lib","tips"],"title":"Rust Doc 小记","uri":"/2020/04/rust-doc%E5%B0%8F%E8%AE%B0.zh/"},{"categories":["Rust"],"content":"总结 Rust 中写的注释代码，可以用来做方法示例，或者当作测试，如果是测试，运行cargo test , cargo 不仅会测试 tests 文件夹下的测试案例，还会寻找注释中的测试。 什么时候写注释呢？优秀的程序员总是强调方法名即注释等。但有不确定的时候就得写注释啦。 在 rust 中，在程序会 panic 的时候需要写注释告诉调用者可能 panic 的方法 返回值是 Result 类型的时候，需要告诉调用者，Ok 和 Err 的数据会是什么 Rust 的编译器相当严谨，结合 TDD 写代码应该会很爽。 ","date":"2020-04-16","objectID":"/2020/04/rust-doc%E5%B0%8F%E8%AE%B0.zh/:3:0","tags":["Rust","doc","comment","rust docs --open","lib","tips"],"title":"Rust Doc 小记","uri":"/2020/04/rust-doc%E5%B0%8F%E8%AE%B0.zh/"},{"categories":["Rust"],"content":"Refs 1. 博客：https://guzhongren.github.io/ 2. 图床：https://sm.ms/ ","date":"2020-04-16","objectID":"/2020/04/rust-doc%E5%B0%8F%E8%AE%B0.zh/:4:0","tags":["Rust","doc","comment","rust docs --open","lib","tips"],"title":"Rust Doc 小记","uri":"/2020/04/rust-doc%E5%B0%8F%E8%AE%B0.zh/"},{"categories":["Rust"],"content":"Disclaimer 本文仅代表个人观点，与 Thoughtworks 公司无任何关系。 ","date":"2020-04-16","objectID":"/2020/04/rust-doc%E5%B0%8F%E8%AE%B0.zh/:5:0","tags":["Rust","doc","comment","rust docs --open","lib","tips"],"title":"Rust Doc 小记","uri":"/2020/04/rust-doc%E5%B0%8F%E8%AE%B0.zh/"},{"categories":["Summary"],"content":"插曲 去年与前 ThoughtWorks 咨询师 李小波的一次线下交流中，学习到了总结知识的一点技巧，非常受用，并且在交流后得到了小波老西自己整理的知识图谱，在自己不断积累下，有文字，也又图片。最近在整理知识，同时也在乱搞知识分享平台。自己虽然有这个博客，但是感觉有些东西不是博客所能呈现的，比如思维导图，我收集的各种模型图等。 之前为了给社区做宣传海报等内容，学会了 Adobe XD, 去年年中前，中国区是可以访问 Adobo XD 的云文档的，后半年就不行了，必须要重新注册或者更换绑定到国外的初始注册站点才可以使用云文档，这也导致了我有一部分资源永远的留在了遥不可及的 Adobe 服务器上。 对我这种穷人很不友好， 😂😂😂😂😂😂😂, 那么我就得需要找个地方薅羊毛了。 ","date":"2020-04-08","objectID":"/2020/04/%E6%88%91%E7%9A%84%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1.zh/:1:0","tags":["知识图谱","Tech","技术"],"title":"我的知识图谱","uri":"/2020/04/%E6%88%91%E7%9A%84%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1.zh/"},{"categories":["Summary"],"content":"Figma 某天记起听过的一篇anyway的 podcast 里提到过 Figma, 据说有免费的资源可以使用，上去一看，果然for up to 2 editors and 3 projects 这样的免费套餐对于我这样的小菜鸟完全足够用了，而且我还邀请了另一个小伙伴，人数刚刚好，😄 当然我也不怕资源丢失，我把我的设计文档同步到了 icloud 上，再也不用担心 Adobe XD 的悲剧了。 ","date":"2020-04-08","objectID":"/2020/04/%E6%88%91%E7%9A%84%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1.zh/:2:0","tags":["知识图谱","Tech","技术"],"title":"我的知识图谱","uri":"/2020/04/%E6%88%91%E7%9A%84%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1.zh/"},{"categories":["Summary"],"content":"附加值 选了 Figma，其实还有其他原因； 它完全支持桌面，网页和移动端，可以在各个端进行创作 将成果保存在云端，或者直接发布到avocode, zeplin和Dribble 支持插件，完美集成各种小工具 支持导出图片到原型网站如zeplin, 当然这点是相对与 Adobe XD 的，我还没发现 Adobe XD 的这个功能 很多大厂的选择 ","date":"2020-04-08","objectID":"/2020/04/%E6%88%91%E7%9A%84%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1.zh/:3:0","tags":["知识图谱","Tech","技术"],"title":"我的知识图谱","uri":"/2020/04/%E6%88%91%E7%9A%84%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1.zh/"},{"categories":["Summary"],"content":"成果 经过整理，我将我的知识模型总结放在了 Figma 上，地址如下，并将其分享到了zeplin上，可以在zeplin上在线查看，学习或者别人查看的时候也是很方便。 知识图谱 ","date":"2020-04-08","objectID":"/2020/04/%E6%88%91%E7%9A%84%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1.zh/:4:0","tags":["知识图谱","Tech","技术"],"title":"我的知识图谱","uri":"/2020/04/%E6%88%91%E7%9A%84%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1.zh/"},{"categories":["Summary"],"content":"Refs 1. 博客：https://guzhongren.github.io/ 2. 图床：https://sm.ms/ 3.Figma: https://www.figma.com/ 4.Zeplin: https://app.zeplin.io/ ","date":"2020-04-08","objectID":"/2020/04/%E6%88%91%E7%9A%84%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1.zh/:5:0","tags":["知识图谱","Tech","技术"],"title":"我的知识图谱","uri":"/2020/04/%E6%88%91%E7%9A%84%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1.zh/"},{"categories":["Summary"],"content":"Disclaimer 本文仅代表个人观点，与 Thoughtworks 公司无任何关系。 ","date":"2020-04-08","objectID":"/2020/04/%E6%88%91%E7%9A%84%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1.zh/:6:0","tags":["知识图谱","Tech","技术"],"title":"我的知识图谱","uri":"/2020/04/%E6%88%91%E7%9A%84%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1.zh/"},{"categories":["Language"],"content":"在鲁迅的文章《孔乙己》中说，茴香豆的茴字有好几种写法，记得没错的话应该是四种，具体哪四种请参考下文引用。 在 Rust 中，闭包也有好几种写法，今天就来总结一哈。 ","date":"2020-04-07","objectID":"/2020/04/rust%E4%B8%AD%E9%97%AD%E5%8C%85%E7%9A%84%E5%86%99%E6%B3%95.zh/:0:0","tags":["Rust","Closure","闭包"],"title":"Rust 中闭包的写法","uri":"/2020/04/rust%E4%B8%AD%E9%97%AD%E5%8C%85%E7%9A%84%E5%86%99%E6%B3%95.zh/"},{"categories":["Language"],"content":"闭包的写法 ","date":"2020-04-07","objectID":"/2020/04/rust%E4%B8%AD%E9%97%AD%E5%8C%85%E7%9A%84%E5%86%99%E6%B3%95.zh/:1:0","tags":["Rust","Closure","闭包"],"title":"Rust 中闭包的写法","uri":"/2020/04/rust%E4%B8%AD%E9%97%AD%E5%8C%85%E7%9A%84%E5%86%99%E6%B3%95.zh/"},{"categories":["Language"],"content":"闭包语法 fn add_one_v1(x: u32)-\u003e u32 {x+1}letadd_one_v2=|x: u32|-\u003e u32 {x+1};letadd_one_v3=|x|{x+1};letadd_one_v4=|x|x+1; ","date":"2020-04-07","objectID":"/2020/04/rust%E4%B8%AD%E9%97%AD%E5%8C%85%E7%9A%84%E5%86%99%E6%B3%95.zh/:1:1","tags":["Rust","Closure","闭包"],"title":"Rust 中闭包的写法","uri":"/2020/04/rust%E4%B8%AD%E9%97%AD%E5%8C%85%E7%9A%84%E5%86%99%E6%B3%95.zh/"},{"categories":["Language"],"content":"使用闭包 leta=add_one_v1(5);letb=add_one_v2(5);letc=add_one_v3(5);letd=add_one_v4(5);println!(\"a={}, b={}, c={}, d={}\",a,b,c,d); 执行cargo run会得到如下结果： a=6, b=6, c=6, d=6 ","date":"2020-04-07","objectID":"/2020/04/rust%E4%B8%AD%E9%97%AD%E5%8C%85%E7%9A%84%E5%86%99%E6%B3%95.zh/:1:2","tags":["Rust","Closure","闭包"],"title":"Rust 中闭包的写法","uri":"/2020/04/rust%E4%B8%AD%E9%97%AD%E5%8C%85%E7%9A%84%E5%86%99%E6%B3%95.zh/"},{"categories":["Language"],"content":"重点说明 闭包定义会为每个参数和返回值类型推导一个具体的类型，但是不能推导两次（不能让俩次或多次使用是不同类型的参数进行调用） 语言描述有点模糊，那么用代码说明问题 // 不能推导两次的示例 letexample_closure=|x|x;lets=example_closure(String::from(\"hello\"));println!(\"第一次{}\",s);// 如果参数为数字 5 ，则报错 // let n = example_closure(5); letn=example_closure(5.to_string());println!(\"第二次{}\",n); 在上面我们定义了一个参数为 x, 返回值为 x 的闭包，但是 x 的类型我们并没有指定。 经过第一次调用，传入参数类型为字符串， 得到的结果 s 也为字符串 hello, 第二次调用如果传入参数为数字 5， 那么程序就会报错，如下 error[E0308]: mismatched types --\u003e src/main.rs:22:29 | 22 | let n = example_closure(5); | ^ | | | expected struct `std::string::String`, found integer | help: try using a conversion method: `5.to_string()` 如果将数字 5 转换为字符串 5，那么程序就运行正常。 ","date":"2020-04-07","objectID":"/2020/04/rust%E4%B8%AD%E9%97%AD%E5%8C%85%E7%9A%84%E5%86%99%E6%B3%95.zh/:2:0","tags":["Rust","Closure","闭包"],"title":"Rust 中闭包的写法","uri":"/2020/04/rust%E4%B8%AD%E9%97%AD%E5%8C%85%E7%9A%84%E5%86%99%E6%B3%95.zh/"},{"categories":["Language"],"content":"总结 Rust 的闭包感觉和 js 的函数的写法很像，感觉到了 Rust 又借鉴了部分 js 的语法。 ","date":"2020-04-07","objectID":"/2020/04/rust%E4%B8%AD%E9%97%AD%E5%8C%85%E7%9A%84%E5%86%99%E6%B3%95.zh/:3:0","tags":["Rust","Closure","闭包"],"title":"Rust 中闭包的写法","uri":"/2020/04/rust%E4%B8%AD%E9%97%AD%E5%8C%85%E7%9A%84%E5%86%99%E6%B3%95.zh/"},{"categories":["Language"],"content":"Refs 1. 博客：https://guzhongren.github.io/ 2. 图床：https://sm.ms/ 3. 茴香豆的茴字的写法：https://zhidao.baidu.com/question/1448503662321920660.html 4.Rust 闭包：https://doc.rust-lang.org/rust-by-example/fn/closures.html ","date":"2020-04-07","objectID":"/2020/04/rust%E4%B8%AD%E9%97%AD%E5%8C%85%E7%9A%84%E5%86%99%E6%B3%95.zh/:4:0","tags":["Rust","Closure","闭包"],"title":"Rust 中闭包的写法","uri":"/2020/04/rust%E4%B8%AD%E9%97%AD%E5%8C%85%E7%9A%84%E5%86%99%E6%B3%95.zh/"},{"categories":["Language"],"content":"Disclaimer 本文仅代表个人观点，与 Thoughtworks 公司无任何关系。 ","date":"2020-04-07","objectID":"/2020/04/rust%E4%B8%AD%E9%97%AD%E5%8C%85%E7%9A%84%E5%86%99%E6%B3%95.zh/:5:0","tags":["Rust","Closure","闭包"],"title":"Rust 中闭包的写法","uri":"/2020/04/rust%E4%B8%AD%E9%97%AD%E5%8C%85%E7%9A%84%E5%86%99%E6%B3%95.zh/"},{"categories":["Shell"],"content":"最近在做 DevOps 的工作，主要是做一个蓝绿部署的方案，在这部分中涉及到了写 shell， Shell 作为一种程序语言，那么对于开发人员肯定是要在部署到正式或者生产环境前进行调试的，在 coding 过程中，发现 shell 的调试其实和平时写的 JS, Java, Rust 等的调试不同，Shell 只能看你每一步执行的语句，至于具体执行是否正确，得由 coding 的人来写正确；好吧，有点难理解，那么我来举个🌰； ","date":"2020-04-06","objectID":"/2020/04/%E8%B0%83%E8%AF%95bash.zh/:0:0","tags":["shell","sh","debug","调试","dry run","coding","sh"],"title":"调试 bash","uri":"/2020/04/%E8%B0%83%E8%AF%95bash.zh/"},{"categories":["Shell"],"content":"举例 有如下代码 #!/bin/bash set -eu readonly FIRST_VALUE=\"first value\" echo \"你会得到替换后的值：${FIRST_VALUE} 脚本很简单，简单一句话，定义了一个变量FIRST_VALUE， 然后用echo输出，在输出的时候应用了刚才定义的变量FIRST_VALUE，赋予执行权限后，如果执行./run.sh之后，只会在终端输出 你会得到替换后的值：first value 但是在简单的脚本中还可以直接运行，如果运行一个复杂的脚本，那么出问题了的几率击溃比较高了，那么调试脚本积极非常重要了。 ","date":"2020-04-06","objectID":"/2020/04/%E8%B0%83%E8%AF%95bash.zh/:1:0","tags":["shell","sh","debug","调试","dry run","coding","sh"],"title":"调试 bash","uri":"/2020/04/%E8%B0%83%E8%AF%95bash.zh/"},{"categories":["Shell"],"content":"debug shell 的调试说来也非常简单，直接运行sh -x ...就可以了，对于本脚本我们执行如下： sh -x run.sh 会得到输出，如下： + set -eu + readonly 'FIRST_VALUE=first value' + FIRST_VALUE='first value' + echo '你会得到替换后的值：first value' 你会得到替换后的值：first value 在这里面，你会看到每条 shell 脚本运行的具体命令，以及参数等内容，这条命令也是一种执行，会对命令涉及的内容产生实际效果，不要以为知识dry run。 ","date":"2020-04-06","objectID":"/2020/04/%E8%B0%83%E8%AF%95bash.zh/:2:0","tags":["shell","sh","debug","调试","dry run","coding","sh"],"title":"调试 bash","uri":"/2020/04/%E8%B0%83%E8%AF%95bash.zh/"},{"categories":["Shell"],"content":"总结 好习惯都是踩坑踩出来的 ","date":"2020-04-06","objectID":"/2020/04/%E8%B0%83%E8%AF%95bash.zh/:3:0","tags":["shell","sh","debug","调试","dry run","coding","sh"],"title":"调试 bash","uri":"/2020/04/%E8%B0%83%E8%AF%95bash.zh/"},{"categories":["Shell"],"content":"Refs 1. 博客：https://guzhongren.github.io/ 2. 图床：https://sm.ms/ 3. 编写可靠 bash 脚本的一些技巧：https://mp.weixin.qq.com/s/VmM_U4RefRBHwIw8NegC8Q ","date":"2020-04-06","objectID":"/2020/04/%E8%B0%83%E8%AF%95bash.zh/:4:0","tags":["shell","sh","debug","调试","dry run","coding","sh"],"title":"调试 bash","uri":"/2020/04/%E8%B0%83%E8%AF%95bash.zh/"},{"categories":["Shell"],"content":"Disclaimer 本文仅代表个人观点，与 Thoughtworks 公司无任何关系。 ","date":"2020-04-06","objectID":"/2020/04/%E8%B0%83%E8%AF%95bash.zh/:5:0","tags":["shell","sh","debug","调试","dry run","coding","sh"],"title":"调试 bash","uri":"/2020/04/%E8%B0%83%E8%AF%95bash.zh/"},{"categories":["Summary"],"content":" 一句话的分量是否重，是要看能不能击中听者的痛点。 设计评审过程中，需要各种文档或者其他资料来辅助，在此总结一番，以供后续查阅。 产品 PRD：当有疑问时可以拿出来给评审者查看 设计分析文档：用来沟通关于行业内对于同类型功能的设计优缺点的分析 数据分析文档：用来展示当前版本数据上的表现和问题，以及可以帮助进行下一步改善 功能逻辑图：复杂功能可以使用图形化表现功能逻辑，便于评审者理解 用户路径图：通过用户路径讲解全局性问题，结合交互设计稿进行具体说明 交互动效演示文档：用来解释一些比较复杂的交互过程 配色情绪版：用来解释如何选择当前配色的思路 制作的思维导图存放于石墨文档，地址如下 https://shimo.im/mindmaps/ne3VVNJy4Ju8FB3b ","date":"2020-04-04","objectID":"/2020/04/%E8%AE%BE%E8%AE%A1%E8%AF%84%E5%AE%A1%E6%96%87%E6%A1%A3%E6%8C%87%E5%8D%97.zh/:0:0","tags":["评审","文档","资料总结"],"title":"设计评审文档指南","uri":"/2020/04/%E8%AE%BE%E8%AE%A1%E8%AF%84%E5%AE%A1%E6%96%87%E6%A1%A3%E6%8C%87%E5%8D%97.zh/"},{"categories":["Summary"],"content":"Refs 1. 博客：https://guzhongren.github.io/ 2. 图床：https://sm.ms/ ","date":"2020-04-04","objectID":"/2020/04/%E8%AE%BE%E8%AE%A1%E8%AF%84%E5%AE%A1%E6%96%87%E6%A1%A3%E6%8C%87%E5%8D%97.zh/:1:0","tags":["评审","文档","资料总结"],"title":"设计评审文档指南","uri":"/2020/04/%E8%AE%BE%E8%AE%A1%E8%AF%84%E5%AE%A1%E6%96%87%E6%A1%A3%E6%8C%87%E5%8D%97.zh/"},{"categories":["Summary"],"content":"Disclaimer 本文仅代表个人观点，与 Thoughtworks 公司无任何关系。 ","date":"2020-04-04","objectID":"/2020/04/%E8%AE%BE%E8%AE%A1%E8%AF%84%E5%AE%A1%E6%96%87%E6%A1%A3%E6%8C%87%E5%8D%97.zh/:2:0","tags":["评审","文档","资料总结"],"title":"设计评审文档指南","uri":"/2020/04/%E8%AE%BE%E8%AE%A1%E8%AF%84%E5%AE%A1%E6%96%87%E6%A1%A3%E6%8C%87%E5%8D%97.zh/"},{"categories":["Agile"],"content":"本思维导图中大部分内容由 @haihaio 完成。 此思维导图中总结了 TDD 的概念，原则，套路，案例及策略等，不失为一份很好的学习资料。 项目地址：https://github.com/AndorLab/MindKnowledgeGraph 方法论很多，重要的是使用方法论的人～单元测试 – from @haihaio ","date":"2020-04-02","objectID":"/2020/04/%E5%BC%80%E5%8F%91%E7%9C%BC%E4%B8%AD%E7%9A%84tdd.zh/:0:0","tags":[" Agile","tdd","方法论","总结","原则","套路","单元测试"],"title":"开发眼中的 TDD","uri":"/2020/04/%E5%BC%80%E5%8F%91%E7%9C%BC%E4%B8%AD%E7%9A%84tdd.zh/"},{"categories":["Agile"],"content":"Refs 1. 博客：https://guzhongren.github.io/ 2.http://agiledata.org/essays/tdd.html 3.https://opensource.com/article/19/10/test-driven-development-best-practices 4.https://osherove.com/blog/2005/4/3/naming-standards-for-unit-tests.html 5.https://dzone.com/articles/7-popular-unit-test-naming ","date":"2020-04-02","objectID":"/2020/04/%E5%BC%80%E5%8F%91%E7%9C%BC%E4%B8%AD%E7%9A%84tdd.zh/:1:0","tags":[" Agile","tdd","方法论","总结","原则","套路","单元测试"],"title":"开发眼中的 TDD","uri":"/2020/04/%E5%BC%80%E5%8F%91%E7%9C%BC%E4%B8%AD%E7%9A%84tdd.zh/"},{"categories":["Agile"],"content":"Disclaimer 本文仅代表个人观点，与 Thoughtworks 公司无任何关系。 ","date":"2020-04-02","objectID":"/2020/04/%E5%BC%80%E5%8F%91%E7%9C%BC%E4%B8%AD%E7%9A%84tdd.zh/:2:0","tags":[" Agile","tdd","方法论","总结","原则","套路","单元测试"],"title":"开发眼中的 TDD","uri":"/2020/04/%E5%BC%80%E5%8F%91%E7%9C%BC%E4%B8%AD%E7%9A%84tdd.zh/"},{"categories":["Tool"],"content":" 软件常用常新，软件大多的目的都是效率，办公，沟通，和娱乐等。虽说 Mac 也有自己的时间机器，可以随时将新机器回复到旧机器上，但是作为分享和传播，那么写一篇文章那是最有效率的了，也可为自己后期使用做备份。 最近由同事的一个脚本启发，特制做了我自己 Mac 电脑上必备的一些软件的快速安装脚本；程序员的本质就是将一切事物简单化，代码化。.. 化； 地址如下，欢迎提 PR： awesome-setup: https://github.com/guzhongren/awesome-setup 接下来，我将按照生产力，效率，沟通和娱乐这几类将我 Mac 上的常用软件列个清单。 生产力 ","date":"2020-04-01","objectID":"/2020/04/%E6%88%91%E7%9A%84mac%E4%B8%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6.zh/:0:0","tags":["software","chat","效率","娱乐"],"title":"我的 Mac 上常用的软件","uri":"/2020/04/%E6%88%91%E7%9A%84mac%E4%B8%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6.zh/"},{"categories":["Tool"],"content":"Visual Studio Code 从严格意义上来说，VSCode 并不算 IDE，但是其设计与插件系统非常完美，作为前端起家的我，只要能写代码我就可以创造世界，估计以后还有一篇写插件的博客。 轻量 插件系统非常完善 绝大多数编程语言都支持 ","date":"2020-04-01","objectID":"/2020/04/%E6%88%91%E7%9A%84mac%E4%B8%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6.zh/:1:0","tags":["software","chat","效率","娱乐"],"title":"我的 Mac 上常用的软件","uri":"/2020/04/%E6%88%91%E7%9A%84mac%E4%B8%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6.zh/"},{"categories":["Tool"],"content":"Vim 作为程序员开发必备利器！ 装逼利器 学习 Linux 的必备工具 高效编码的工具 任何 Linux 版本都有的编辑器 定制化程度非常高 …… 在此推荐我的定制的 vimrc,地址在这, ","date":"2020-04-01","objectID":"/2020/04/%E6%88%91%E7%9A%84mac%E4%B8%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6.zh/:2:0","tags":["software","chat","效率","娱乐"],"title":"我的 Mac 上常用的软件","uri":"/2020/04/%E6%88%91%E7%9A%84mac%E4%B8%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6.zh/"},{"categories":["Tool"],"content":"iTerm2 Mac 上非常好用的终端，安装之后自带 zsh, 而 zsh 又自带各种好用的快捷方式，比如简化的 git 命令，zsh 的自动补全等插件 界面简洁 自定义配置程度比较高 可搭配不同的命令行主题，在此推荐 powerlevel10k 真的比 Mac 自带的终端好用啊 😄 ","date":"2020-04-01","objectID":"/2020/04/%E6%88%91%E7%9A%84mac%E4%B8%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6.zh/:3:0","tags":["software","chat","效率","娱乐"],"title":"我的 Mac 上常用的软件","uri":"/2020/04/%E6%88%91%E7%9A%84mac%E4%B8%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6.zh/"},{"categories":["Tool"],"content":"IDEA Java 开发必备 ","date":"2020-04-01","objectID":"/2020/04/%E6%88%91%E7%9A%84mac%E4%B8%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6.zh/:4:0","tags":["software","chat","效率","娱乐"],"title":"我的 Mac 上常用的软件","uri":"/2020/04/%E6%88%91%E7%9A%84mac%E4%B8%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6.zh/"},{"categories":["Tool"],"content":"备忘录 备忘录可以随时打开做笔记，记录重要的内容，当然和 iPhone 配合使用会更高效。主要就是使用自己制作的快捷指令，我的主要有两个，一个是Copy and Paste, 顾名思义，将复制的内容粘贴到备忘录中；第二个顺便记，这个快捷指令会将语音内容转化为文字并将其追加到备忘录中。 使用这两个快捷指令，将非常高效，比如平时记录零碎的知识点，重要的总结内容等。 ","date":"2020-04-01","objectID":"/2020/04/%E6%88%91%E7%9A%84mac%E4%B8%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6.zh/:5:0","tags":["software","chat","效率","娱乐"],"title":"我的 Mac 上常用的软件","uri":"/2020/04/%E6%88%91%E7%9A%84mac%E4%B8%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6.zh/"},{"categories":["Tool"],"content":"XMind 思维导图界的翘楚，当然需要付费。 界面简洁赶紧 功能简单但丰富 主题多样，市面上 99%的导图类型都实现了 主题真的很好看 可跨平台使用 ","date":"2020-04-01","objectID":"/2020/04/%E6%88%91%E7%9A%84mac%E4%B8%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6.zh/:6:0","tags":["software","chat","效率","娱乐"],"title":"我的 Mac 上常用的软件","uri":"/2020/04/%E6%88%91%E7%9A%84mac%E4%B8%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6.zh/"},{"categories":["Tool"],"content":"Adobe XD 传统图像大厂 Adobe 产品，结合 Adobe 全家桶使用应该很爽，需要注意的是在国内，XD 不可以使用在线存储服务，所以在注册时记得将地区选择为其他地区，推荐美国🇺🇸， 使用简单，免费，相比与 Sketchup, 这点还是很诱人的 中文文档做的也不错 插件系统也不错，可与 Trello 等工具结合 矢量图形编辑也非常不错 ","date":"2020-04-01","objectID":"/2020/04/%E6%88%91%E7%9A%84mac%E4%B8%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6.zh/:7:0","tags":["software","chat","效率","娱乐"],"title":"我的 Mac 上常用的软件","uri":"/2020/04/%E6%88%91%E7%9A%84mac%E4%B8%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6.zh/"},{"categories":["Tool"],"content":"jsonpp json_pp 我主要是用来格式化 curl 命令行的结果，例如测试某个 restful 接口，返回的 json，在命令行就会自动给你格式化好输出， ","date":"2020-04-01","objectID":"/2020/04/%E6%88%91%E7%9A%84mac%E4%B8%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6.zh/:8:0","tags":["software","chat","效率","娱乐"],"title":"我的 Mac 上常用的软件","uri":"/2020/04/%E6%88%91%E7%9A%84mac%E4%B8%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6.zh/"},{"categories":["Tool"],"content":"安装 brew install jsonpp 效率 ","date":"2020-04-01","objectID":"/2020/04/%E6%88%91%E7%9A%84mac%E4%B8%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6.zh/:8:1","tags":["software","chat","效率","娱乐"],"title":"我的 Mac 上常用的软件","uri":"/2020/04/%E6%88%91%E7%9A%84mac%E4%B8%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6.zh/"},{"categories":["Tool"],"content":"Bitwarden 用来存储和生成密码的工具 开源 免费 （有商业版） 支持两步验证 (2FA) 可按条件生成随机密码（我从来不记我的密码，而且我也记不住） 多端支持 可自定义数据存储方案 可自动填充账号密码 ","date":"2020-04-01","objectID":"/2020/04/%E6%88%91%E7%9A%84mac%E4%B8%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6.zh/:9:0","tags":["software","chat","效率","娱乐"],"title":"我的 Mac 上常用的软件","uri":"/2020/04/%E6%88%91%E7%9A%84mac%E4%B8%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6.zh/"},{"categories":["Tool"],"content":"Microsoft Todo 微软收购了 Wunderlist, 然后推出了桌面版，Web 版，Mobile(Apple, Android), Pad 版的 Todo 应用，我比较看好的功能 只需一个 Microsoft 账号就可以在各个终端进行数据同步 界面清新简洁 可自定义分组，分类 可自定义背景图片 可与其他人共享 Todo 最重要的是可以在每一个 Todo 里定义子 Todo ","date":"2020-04-01","objectID":"/2020/04/%E6%88%91%E7%9A%84mac%E4%B8%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6.zh/:10:0","tags":["software","chat","效率","娱乐"],"title":"我的 Mac 上常用的软件","uri":"/2020/04/%E6%88%91%E7%9A%84mac%E4%B8%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6.zh/"},{"categories":["Tool"],"content":"Itsycal Itsycal Mac 自带的顶部的日历其实有点不好用，如果你要看你的日程，那么你需要点开日历，而且他的时间格式其实也不是很友好（对于定制党）；Itsycal 很好的解决了这个问题。 ","date":"2020-04-01","objectID":"/2020/04/%E6%88%91%E7%9A%84mac%E4%B8%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6.zh/:11:0","tags":["software","chat","效率","娱乐"],"title":"我的 Mac 上常用的软件","uri":"/2020/04/%E6%88%91%E7%9A%84mac%E4%B8%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6.zh/"},{"categories":["Tool"],"content":"安装 brew cask install itsycal 沟通 ","date":"2020-04-01","objectID":"/2020/04/%E6%88%91%E7%9A%84mac%E4%B8%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6.zh/:11:1","tags":["software","chat","效率","娱乐"],"title":"我的 Mac 上常用的软件","uri":"/2020/04/%E6%88%91%E7%9A%84mac%E4%B8%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6.zh/"},{"categories":["Tool"],"content":"微信 不管是亲朋还是同事沟通，微信都是非常高效的工具，而且微信里面的小程序现在可以运行在桌面端了，使用场景也越来越多了；还有一个非常好用的功能：截屏！ 以前电脑上会安装 QQ， 现在 QQ 也不用了，快速分享内容并标注微信是不二之选。 娱乐 ##IINA The modern media player for macOS. 开源，免费 支持多种资源播放（在线，本地文件，Youtube 等） 界面简洁清爽 操作简单直观 字幕，视频大小可随意调节 工具 ","date":"2020-04-01","objectID":"/2020/04/%E6%88%91%E7%9A%84mac%E4%B8%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6.zh/:12:0","tags":["software","chat","效率","娱乐"],"title":"我的 Mac 上常用的软件","uri":"/2020/04/%E6%88%91%E7%9A%84mac%E4%B8%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6.zh/"},{"categories":["Tool"],"content":"清理工具 tencent-lemon ","date":"2020-04-01","objectID":"/2020/04/%E6%88%91%E7%9A%84mac%E4%B8%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6.zh/:13:0","tags":["software","chat","效率","娱乐"],"title":"我的 Mac 上常用的软件","uri":"/2020/04/%E6%88%91%E7%9A%84mac%E4%B8%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6.zh/"},{"categories":["Tool"],"content":"安装 brew cask install tencent-lemon ","date":"2020-04-01","objectID":"/2020/04/%E6%88%91%E7%9A%84mac%E4%B8%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6.zh/:13:1","tags":["software","chat","效率","娱乐"],"title":"我的 Mac 上常用的软件","uri":"/2020/04/%E6%88%91%E7%9A%84mac%E4%B8%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6.zh/"},{"categories":["Tool"],"content":"Refs 博客：https://guzhongren.github.io/ Todo: https://todo.microsoft.com/tasks/ Visual Studio Cod: https://code.visualstudio.com/ Vim: https://www.vim.org Vimrc: https://github.com/guzhongren/.vim Bitwarden:https://bitwarden.com/ IDEA: https://www.jetbrains.com/idea/ 微信：https://res.wx.qq.com/a/wx_fed/weixin_portal/res/static/img/3sPNXyP.gif IINA:https://iina.io/ Adobe XD: https://www.adobe.com/cn/products/xd.html Itsycal:https://www.mowglii.com/itsycal/ ","date":"2020-04-01","objectID":"/2020/04/%E6%88%91%E7%9A%84mac%E4%B8%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6.zh/:14:0","tags":["software","chat","效率","娱乐"],"title":"我的 Mac 上常用的软件","uri":"/2020/04/%E6%88%91%E7%9A%84mac%E4%B8%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6.zh/"},{"categories":["Tool"],"content":"Disclaimer 本文仅代表个人观点，与 Thoughtworks 公司无任何关系。 ","date":"2020-04-01","objectID":"/2020/04/%E6%88%91%E7%9A%84mac%E4%B8%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6.zh/:15:0","tags":["software","chat","效率","娱乐"],"title":"我的 Mac 上常用的软件","uri":"/2020/04/%E6%88%91%E7%9A%84mac%E4%B8%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6.zh/"},{"categories":["Agile"],"content":"场景 最近上了澳洲的项目，项目组 9 个人，我们的站会是每周有一个人来轮流主持，每天早上 10 点，在Teams上与澳洲的客户一起面对Jira看板进行工作同步； 上周正好轮值到我了，按照我司的习惯，哪能有搞不定的事啊，如果有，那就是多花点时间的问题了，当然这话是我说的。那么对于英语菜鸟的我是怎么 host standup meeting 的呢？接下来让我一一道来。 ","date":"2020-03-15","objectID":"/2020/03/how-to-host-an-english-standup-meeting.zh/:1:0","tags":["English","host meeting","standup meeting","主持站会","Tasking","Agile"],"title":"How to Host an English Standup Meeting","uri":"/2020/03/how-to-host-an-english-standup-meeting.zh/"},{"categories":["Agile"],"content":"方法论 做事最重要的是你要一个什么样的结果，只要知道你要的结果，那么将实现结果的步骤一步步拆解成一个个的 Task，这个过程产生的结果也被称为Tasking。 ","date":"2020-03-15","objectID":"/2020/03/how-to-host-an-english-standup-meeting.zh/:2:0","tags":["English","host meeting","standup meeting","主持站会","Tasking","Agile"],"title":"How to Host an English Standup Meeting","uri":"/2020/03/how-to-host-an-english-standup-meeting.zh/"},{"categories":["Agile"],"content":"Tasking 每天练英语听力和口语 (提升自己) 平时收集工作中遇到的各种单词和短语 (提升自己) 收集主持站会用到的各种短语 (提升自己) 对于自己要更新的内容，提前将主要关键词写下来 (提升自己) 学习并总结别人主持站会的流程 (学习总结) 与同事交流主持站会的心得 (鼓励自己，提升信心) 7.Recycle(量变达到质变) …… 在每个task的后面我都备注了每个 task 的作用，都很好理解。 对于第 1 条，我推荐6 分钟英语和China Daily;6 分钟英语里面有热点新闻的简短介绍和常用场景的对话，虽说是6 分钟英语，但真实情况是至少需要 15 分钟，但还是很值得推荐；China Daily 就不用说了。 ","date":"2020-03-15","objectID":"/2020/03/how-to-host-an-english-standup-meeting.zh/:2:1","tags":["English","host meeting","standup meeting","主持站会","Tasking","Agile"],"title":"How to Host an English Standup Meeting","uri":"/2020/03/how-to-host-an-english-standup-meeting.zh/"},{"categories":["Agile"],"content":"英文场景对话 有了方法论，那么是不是应该将这些内容应用到实战才能检验成果呢？下面我来模拟一场 Standup Meeting。 主持站会我们会提前 1～2 分钟进入会议，调试语音，看板和等待客户等； 客户上线了，问候客户 Hi, xxx, How’s the weather today [Customer]It’s a cloudy/sunny day. How are you? [Customer]I’m fine, thank you ! And you? I’m fine too. Thank you, team is ready, let’s start our standup meeting [Shall we Start?]. 打招呼并让同事确认别人可以看到我的屏幕 Can you hear me and see my screen? [AA]Yes/No 开始更新，默认情况下，先由我们西安团队更新，再由墨尔本团队更新，我们更新的顺序一般是由 Jira 的右边开始，也就是 Done 列 Let’s start update from right side? YY, is there any update from you? [YY] Let’s me update ……Ok, That’s it. YY 更新完成后，提示大家继续更新 Next [UU]From my side……Yay, that’s my update. Next 西安团队更新完成后，询问墨尔本团队更新。 Those above update is from xi’an side. Is there any update from Melbourne side? [Melbourne]…… 两个团队更新完成后，需要确认还有什么有更新 Any other update or questions? [silent] If there is no update and question, we will end today’s meeting? Ok, Thanks for joining standup meeting. ","date":"2020-03-15","objectID":"/2020/03/how-to-host-an-english-standup-meeting.zh/:3:0","tags":["English","host meeting","standup meeting","主持站会","Tasking","Agile"],"title":"How to Host an English Standup Meeting","uri":"/2020/03/how-to-host-an-english-standup-meeting.zh/"},{"categories":["Agile"],"content":"结语 作为主持人，我们可以做如下两点： 我们让会议顺利运行下去就可以，用到的英文短语其实也不多，但更重要的是参与者要理解项目运行的各种情况，听懂每个内容更新者说的内容，让主持人作为纽带，使这些内容和参与者联系起来，从而促进工作清晰而高效。 通过与内容更新者沟通，将卡或者项目的进度挖掘出来，这样 PM 就不用可以去问了，也可以提高效率。 做为内容更新者， 我们要一边遵循 standup meeting 更新的套路，即昨天干了什么，有什么结果，今天计划要干什么，有什么风险或者需要帮助；另一边我们还要关注其他同事干了什么，某个功能进行到什么程度了，或者某个问题追踪到了什么阶段。每件事都要可执行且结果导向。 ","date":"2020-03-15","objectID":"/2020/03/how-to-host-an-english-standup-meeting.zh/:4:0","tags":["English","host meeting","standup meeting","主持站会","Tasking","Agile"],"title":"How to Host an English Standup Meeting","uri":"/2020/03/how-to-host-an-english-standup-meeting.zh/"},{"categories":["Agile"],"content":"Refs 1. 博客：https://guzhongren.github.io/ 2. 翻译：https://translate.google.cn/ ","date":"2020-03-15","objectID":"/2020/03/how-to-host-an-english-standup-meeting.zh/:5:0","tags":["English","host meeting","standup meeting","主持站会","Tasking","Agile"],"title":"How to Host an English Standup Meeting","uri":"/2020/03/how-to-host-an-english-standup-meeting.zh/"},{"categories":["Agile"],"content":"Disclaimer 本文仅代表个人观点，与 Thoughtworks 公司无任何关系。 ","date":"2020-03-15","objectID":"/2020/03/how-to-host-an-english-standup-meeting.zh/:6:0","tags":["English","host meeting","standup meeting","主持站会","Tasking","Agile"],"title":"How to Host an English Standup Meeting","uri":"/2020/03/how-to-host-an-english-standup-meeting.zh/"},{"categories":["tool"],"content":"场景 在公网上我们获取 npm 包的时候直接就用下面的命令就可以了 $ npm install xxx $ # 或者 # yarn add xxx 但是有时候，公司内部开发的工具库只想放在公司内部的服务器上，那么我们就需要对 npm 源进行配置了。因为 yarn 可以利用缓存，其速度比较快，且 npm 包是公司内部网络，鉴于效率，我们采用 yarn 来提速。 ","date":"2020-03-05","objectID":"/2020/03/config-yarn-to-use-private-package.zh/:1:0","tags":["yarn","npm",".npmrc","private package"],"title":"Config Yarn to Use Private Package","uri":"/2020/03/config-yarn-to-use-private-package.zh/"},{"categories":["tool"],"content":"配置。npmrc 下面是 .npmrc 的通常配置， 这里的 https://npm.xxx.com/npm 就是私服的地址， 下面//开头的内容就是用来鉴权的 token。 # .npmrc registry=https://npm.xxx.com/npm //npm.xxx.com/npm/:_authToken=dbef52be-1a83-46e1-a3ce-e0c8727e3fa4 上面的配置，在用 npm 安装私有库或者公有库的时候都没问题，但是我们要使用 yarn，如果再不配置任何内容，在执行 yarn add xxx 的时候，控制台会报如下错误 yarn global v1.22.0 [1/4] 🔍 Resolving packages... error An unexpected error occurred: \"https://npm.xxx.com/npm/yyy: authentication required\". info If you think this is a bug, please open a bug report with the information provided in \"/Users/zhongren.gu/.config/yarn/global/yarn-error.log\". info Visit https://yarnpkg.com/en/docs/cli/global for documentation about this command. 这其实不是 yarn 的 bug, 我们需要在 .npmrc 中增加如下一行 always-auth=true, 最终结果如下 # .npmrc registry=https://npm.xxx.com/npm //npm.xxx.com/npm/:_authToken=dbef52be-1a83-46e1-a3ce-e0c8727e3fa4 always-auth=true ","date":"2020-03-05","objectID":"/2020/03/config-yarn-to-use-private-package.zh/:2:0","tags":["yarn","npm",".npmrc","private package"],"title":"Config Yarn to Use Private Package","uri":"/2020/03/config-yarn-to-use-private-package.zh/"},{"categories":["tool"],"content":"结果 再次执行 yarn add xxx 之后就会正常安装了，以后就可以愉快的安装私服或者公网上的 package 了。 ","date":"2020-03-05","objectID":"/2020/03/config-yarn-to-use-private-package.zh/:3:0","tags":["yarn","npm",".npmrc","private package"],"title":"Config Yarn to Use Private Package","uri":"/2020/03/config-yarn-to-use-private-package.zh/"},{"categories":["tool"],"content":"Refs 1.https://yarnpkg.com/ ","date":"2020-03-05","objectID":"/2020/03/config-yarn-to-use-private-package.zh/:4:0","tags":["yarn","npm",".npmrc","private package"],"title":"Config Yarn to Use Private Package","uri":"/2020/03/config-yarn-to-use-private-package.zh/"},{"categories":["tool"],"content":"使用 Hugo 构建个人博客","date":"2020-02-23","objectID":"/2020/02/build-my-blog-with-hugo.zh/","tags":["hugo","blog","git","Makefile"],"title":"Build My Blog With Hugo","uri":"/2020/02/build-my-blog-with-hugo.zh/"},{"categories":["tool"],"content":"Overview Hugo是一款基于 golang 实现的静态网站生成器。以其简单、易用、高效、易扩展、快速部署受到开发者的喜爱，比起 Hexo 感觉更轻便。下图是我初步实现的博客截图。 ","date":"2020-02-23","objectID":"/2020/02/build-my-blog-with-hugo.zh/:1:0","tags":["hugo","blog","git","Makefile"],"title":"Build My Blog With Hugo","uri":"/2020/02/build-my-blog-with-hugo.zh/"},{"categories":["tool"],"content":"安装 ","date":"2020-02-23","objectID":"/2020/02/build-my-blog-with-hugo.zh/:2:0","tags":["hugo","blog","git","Makefile"],"title":"Build My Blog With Hugo","uri":"/2020/02/build-my-blog-with-hugo.zh/"},{"categories":["tool"],"content":"Golang Hugo 是基于 Go 语言的，所以需要安装 go, 我的机器是 Mac, 所以直接用 homebrew 就搞定。 $ brew install go ","date":"2020-02-23","objectID":"/2020/02/build-my-blog-with-hugo.zh/:2:1","tags":["hugo","blog","git","Makefile"],"title":"Build My Blog With Hugo","uri":"/2020/02/build-my-blog-with-hugo.zh/"},{"categories":["tool"],"content":"Hugo $ brew install hugo ","date":"2020-02-23","objectID":"/2020/02/build-my-blog-with-hugo.zh/:2:2","tags":["hugo","blog","git","Makefile"],"title":"Build My Blog With Hugo","uri":"/2020/02/build-my-blog-with-hugo.zh/"},{"categories":["tool"],"content":"生成博客站点 $ hugo new site blog ","date":"2020-02-23","objectID":"/2020/02/build-my-blog-with-hugo.zh/:2:3","tags":["hugo","blog","git","Makefile"],"title":"Build My Blog With Hugo","uri":"/2020/02/build-my-blog-with-hugo.zh/"},{"categories":["tool"],"content":"安装 LoveIt 主题 $ cd blog $ git init $ git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt ","date":"2020-02-23","objectID":"/2020/02/build-my-blog-with-hugo.zh/:2:4","tags":["hugo","blog","git","Makefile"],"title":"Build My Blog With Hugo","uri":"/2020/02/build-my-blog-with-hugo.zh/"},{"categories":["tool"],"content":"配置 config.toml 将themes/LoveIt/exampleSite/config.toml copy 到 blog 根目录，并根据需要修改里面的配置。 注： 需要将 copy 过来的 config.toml 里的 themeDir 由../.. 改为 ./themes ","date":"2020-02-23","objectID":"/2020/02/build-my-blog-with-hugo.zh/:2:5","tags":["hugo","blog","git","Makefile"],"title":"Build My Blog With Hugo","uri":"/2020/02/build-my-blog-with-hugo.zh/"},{"categories":["tool"],"content":"优化模板 Hugo 生成的 markdown 文件都是由archetypes/default.md生成的， 所以我们可以在模板里加入一些我们通常使用的文案和图片。 比如： --- title: \"{{ replace .Name \"-\" \" \" | title }}\" date: {{ .Date }} draft: true author: \"谷中仁\" authorLink: \"https://guzhongren.github.io\" description: \"\" license: \u003ca rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc/4.0/\"\u003e\u003cimg alt=\"Creative Commons License\" style=\"border-width:0\" src=\"https://i.creativecommons.org/l/by-nc/4.0/80x15.png\" /\u003e\u003c/a\u003e tags: [\"\"] categories: [\"\"] hiddenFromHomePage: false featuredImage: \"\" featuredImagePreview: \"\" toc: true autoCollapseToc: true math: true comment: true --- ## Refs ---- ![谷哥说-微信公众号](https://cdn.staticaly.com/gh/guzhongren/data-hosting@master/20210819/wechat.ae9zxgscqcg.png) 生成文章后，直接更新需要更新的字段，如标签（tags）和分类（categories）等，然后在中间直接写文章就可以。 ","date":"2020-02-23","objectID":"/2020/02/build-my-blog-with-hugo.zh/:3:0","tags":["hugo","blog","git","Makefile"],"title":"Build My Blog With Hugo","uri":"/2020/02/build-my-blog-with-hugo.zh/"},{"categories":["tool"],"content":"上传到 Github $ git remote add origin git@github.com:guzhongren/guzhongren.github.io.git $ git add . $ git commit -m \"init\" $ git push -u origin master 创建 blog分支 在 Github 上个创建 blog 分支。我们的博客都会在 blog 分支 创建PERSONAL_TOKEN, 或者 Deploy Token 我们在 Developer settings 以 PERSONAL_TOKEN 为例。 然后在项目设置的 Secret 中用PERSONAL_TOKEN添加 ","date":"2020-02-23","objectID":"/2020/02/build-my-blog-with-hugo.zh/:3:1","tags":["hugo","blog","git","Makefile"],"title":"Build My Blog With Hugo","uri":"/2020/02/build-my-blog-with-hugo.zh/"},{"categories":["tool"],"content":"自动化部署配置 既然博客基于 github, 那么我们可以直接用 Github Actions, 在项目页点击Actions, 创建一个 Workflow, 其内容大致如下 name:github pageson:push:branches:- blogjobs:build-deploy:runs-on:ubuntu-lateststeps:- uses:actions/checkout@v1# 必须用 v1 ，v2 不支持 submodulewith:submodules:true- name:Setup Hugouses:peaceiris/actions-hugo@v2with:hugo-version:'0.64.0'- name:Buildrun:hugo --minify- name:add nojekyllrun:touch ./public/.nojekyll- name:Deployuses:peaceiris/actions-gh-pages@v3with:# deploy_key: ${{ secrets.ACTIONS_DEPLOY_KEY }}personal_token:${{ secrets.PERSONAL_TOKEN }}publish_dir:./publicpublish_branch:masteruser_name:guzhongrenuser_email:guzhongren@live.cn ","date":"2020-02-23","objectID":"/2020/02/build-my-blog-with-hugo.zh/:4:0","tags":["hugo","blog","git","Makefile"],"title":"Build My Blog With Hugo","uri":"/2020/02/build-my-blog-with-hugo.zh/"},{"categories":["tool"],"content":"写文章 为了更好的管理发布的文章，建议用 /year/mouth/article_name.zh.md 这种格式。也可用我写的 Makefile 命令 $ # hugo new posts/2020/02/first.zh.md $ make post=first.zh.md 然后打开content/posts/2020/02/first.zh.md 进行文章编辑。 ","date":"2020-02-23","objectID":"/2020/02/build-my-blog-with-hugo.zh/:5:0","tags":["hugo","blog","git","Makefile"],"title":"Build My Blog With Hugo","uri":"/2020/02/build-my-blog-with-hugo.zh/"},{"categories":["tool"],"content":"预览 在 blog 项目根目录运行如下命令进行预览 $ # hugo server -D $ make pre ","date":"2020-02-23","objectID":"/2020/02/build-my-blog-with-hugo.zh/:6:0","tags":["hugo","blog","git","Makefile"],"title":"Build My Blog With Hugo","uri":"/2020/02/build-my-blog-with-hugo.zh/"},{"categories":["tool"],"content":"提交 提交到 git 中，暂存起来 $ make commit message=feat(post): 发布新文章 或者用如下命令 $ git add -A $ git commit -m feat(post): 发布新文章 ","date":"2020-02-23","objectID":"/2020/02/build-my-blog-with-hugo.zh/:7:0","tags":["hugo","blog","git","Makefile"],"title":"Build My Blog With Hugo","uri":"/2020/02/build-my-blog-with-hugo.zh/"},{"categories":["tool"],"content":"发布 将本地更新提交到 github 上， 会自动触发 actions 然后进行构建，构建完成后自动将代码部署到 $ make pub 或者用 $ git commit -m \"first article\" $ git pull $ git push ","date":"2020-02-23","objectID":"/2020/02/build-my-blog-with-hugo.zh/:8:0","tags":["hugo","blog","git","Makefile"],"title":"Build My Blog With Hugo","uri":"/2020/02/build-my-blog-with-hugo.zh/"},{"categories":["tool"],"content":"优化 在敲 hugo 相关的命令的时候比较繁琐，有几个参数经常会敲， 所以使用 Makefile 优化一下，上面有些命令就是在此定义的。 post = default.zh.md message = git commit Year_month = $(shell date +\"%Y/%m\") new: hugo new posts/$(Year_month)/$(post) pre: hugo server -D commit: git add -A git commit -m \"$(message)\" pub: git pull git push new: 创建文章 pre: 写文章时预览 commit: 提交到本地暂存区 pub: 发布文章 尽情享用吧。..🎉🎉🎉🎉🎉 ","date":"2020-02-23","objectID":"/2020/02/build-my-blog-with-hugo.zh/:9:0","tags":["hugo","blog","git","Makefile"],"title":"Build My Blog With Hugo","uri":"/2020/02/build-my-blog-with-hugo.zh/"},{"categories":["tool"],"content":"Refs 1.https://gohugo.io/ 2.https://golang.google.cn/ 3.https://github.com/dillonzq/LoveIt 4.https://github.com/features/actions 5.https://github.com/settings/tokens 6.生成 icon: https://realfavicongenerator.net/ ","date":"2020-02-23","objectID":"/2020/02/build-my-blog-with-hugo.zh/:10:0","tags":["hugo","blog","git","Makefile"],"title":"Build My Blog With Hugo","uri":"/2020/02/build-my-blog-with-hugo.zh/"},{"categories":null,"content":"About me","date":"2020-02-23","objectID":"/about/","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"个人介绍 嗨， 我是谷中仁， 一位地理信息系统专业（2015 年毕业）的程序员、 高级咨询师、 开源爱好者、freeCodeCamp 西安社区 组织者；目前是 Thoughtworks 的一名高级咨询师; 2015.03 ~ 2016.10 ESRI （中国） 信息技术有限公司西安分公司 售前，售后，技术支持 2016.10 ~ 2017.07 图智信息技术有限公司 前端工程师 2017.10 ~ 2019.01 西安山脉科技股份有限公司 高级 GIS 开发工程师，前端架构师 2019.01 ～ Thoughtworks 思特沃克软件技术（西安）有限公司 高级咨询师 ","date":"2020-02-23","objectID":"/about/:1:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"作品 ","date":"2020-02-23","objectID":"/about/:2:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"Coding Powerboard 一款可拖拽、可配置的 Buildkite Dashboard 应用。 ChartOnMap based on ArcGIS API 基于 ArcGIS API 的地图上展示图标的库。 Markdown 编辑器 一款定制的 Markdown 编辑器，可用于发微信、邮件等。 ","date":"2020-02-23","objectID":"/about/:2:1","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"Articles 容器安全扫描工具推荐-Thoughtworks洞见 Continuously optimize your website with Lighthouse CI - Thoughtworks Insight Blog ","date":"2020-02-23","objectID":"/about/:2:2","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"开源项目贡献 maptalks: 开源 23 D GIS 框架 hlj: 开源 JS 测试框架，自举测试 ","date":"2020-02-23","objectID":"/about/:3:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"技术栈 ","date":"2020-02-23","objectID":"/about/:4:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"前端 ","date":"2020-02-23","objectID":"/about/:4:1","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"后端 ","date":"2020-02-23","objectID":"/about/:4:2","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"DevOps ","date":"2020-02-23","objectID":"/about/:4:3","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"敏捷 ","date":"2020-02-23","objectID":"/about/:4:4","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"工具 ","date":"2020-02-23","objectID":"/about/:4:5","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"工程实践 ","date":"2020-02-23","objectID":"/about/:4:6","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"领域 ## 关于社区 2018 年 8 月份与韩亦乐一起组织 FCC 西安社区的第一次前端大会，并在 12 月由我和另外几位小伙伴一起负责西安社区建设和运营。 社区运营实行轮流制。每年会举办一些前端，后端技术会议，当然也有一些线下 10 多人人的 Workshop。社区也提供招聘宣传，会议合作等服务，如有需求，可以通过 e-mail, 微信等方式联系我。 ","date":"2020-02-23","objectID":"/about/:4:7","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"关于…… 来日方长，慢慢道来。.. GPG KeyID: D18AEC180356622D ","date":"2020-02-23","objectID":"/about/:5:0","tags":null,"title":"About","uri":"/about/"},{"categories":["git"],"content":"版本控制策略","date":"2020-02-23","objectID":"/2020/02/version-management-strategy.zh/","tags":["git","git-flow","trunk-based development","TBD"],"title":"Version Management Strategy","uri":"/2020/02/version-management-strategy.zh/"},{"categories":["git"],"content":"为了开发高质量的软件，我们需要能够跟踪所有更改并在必要时将其撤消。 版本控制系统通过跟踪项目历史记录并帮助合并多人所做的更改来填补这一角色，极大地加快了工作速度，并使我们能够更轻松地发现错误。 此外，得益于这些工具，分布式团队可以畅通合作，使多个人可以同时处理项目的不同部分，然后将其结果合并为一个产品。 让我们仔细看看版本控制系统，git-flow 和 Trunk-based development（基于主干的开发）是如何形成的。 ","date":"2020-02-23","objectID":"/2020/02/version-management-strategy.zh/:0:0","tags":["git","git-flow","trunk-based development","TBD"],"title":"Version Management Strategy","uri":"/2020/02/version-management-strategy.zh/"},{"categories":["git"],"content":"版本控制系统是怎样改变世界的 在版本控制系统出现之前，开发人员依靠手动备份项目的先前版本。他们手工复制修改过的文件，以便将多个开发人员的工作合并到同一项目中。 这样的操作花费了大量时间、硬盘空间和 money。 软件的目的是为了更好、更高效的完成工作。工欲善其事必先利其器，那么作为开发者肯定会在产出软件之前对自己的代码进行更有效的管理。 当我们回顾历史时 [1]，我们可以大致区分出三代阶段的控制软件。 阶段 操作 并发 存储 工具 1 单文件 锁定文件 集中式 RCS 2 多文件 提交前 merge 集中式 Subversion, CVS 3 多文件 merge 前提交 分布式 Git, Mercurial 我们注意到随着版本控制系统的成熟，并行处理项目的能力成为了趋势。 最具突破性的更改之一是从锁定文件转变为合并更改。它使开发者能够更有效地工作。 另一个重大改进是引入了分布式系统。 Git 是采用这种理念的首批工具之一。 实际上，它使开源世界得以蓬勃发展。 Git 允许开发人员通过称为分叉的操作复制整个存储库，并引入所需的更改，而不必担心合并冲突。 随后，开发者可以创建一个 PR(Pull request)，以将其更改合并到原始项目中。 如果最初的开发人员对合并其他存储库中的更改不感兴趣，那么他们可以自己将其转换 (Fork) 为单独的项目。 由于没有中央存储的概念，因此一切皆有可能。 ","date":"2020-02-23","objectID":"/2020/02/version-management-strategy.zh/:1:0","tags":["git","git-flow","trunk-based development","TBD"],"title":"Version Management Strategy","uri":"/2020/02/version-management-strategy.zh/"},{"categories":["git"],"content":"Git-flow 在 Git-flow 开发模型中，你有一个主分支 (master branch)，从主分支创建开发分支 (develop branch)，所有开发工作提交都基于开发分支。主分支和开发分支在 git-flow 的整个生命周期中都是一直存在的。 开发人员从该开发分支创建功能分支 (Feature branch) 并对其进行 Coding。完成后，它们将创建 PR。在审查 (Review) PR 过程中，其他开发人员会对更改发表评论，并可能进行讨论，讨论时间也许会很长。 对 PR 评审完成后，PR 将被接受并 merge 到开发分支。 一旦确定开发分支已经成熟到可以发布，就会创建一个单独的分支 (release branch) 来准备最终版本。 该分支的应用程序已经过测试，并且在准备好将其发布给最终用户之前会应用错误修复 (bugfixs)。 完成此操作后，我们会将最终产品合并到主 (master branch) 分支，并打标签 (Tag)。 同时，可以在 develop 分支上继续开发新功能。 Git 流的优点之一是严格控制。仔细查看更改后，只有授权的开发人员才能批准更改。它可以确保代码质量，并有助于尽早消除错误。 但是，你需要记住，这也可能是一个巨大的劣势。它会形成一个瓶颈，从而减慢软件开发速度。如果速度是你的首要考虑，那么这应该是一个严重的问题。单独开发的功能可以创建长期存在的分支，这些分支可能很难与主项目结合。 此外，PR 仅将代码重点放在新代码上。他们只查看新引入的更改，而不是整体查看代码并进行改进。在某些情况下，它们可能会导致过早的优化，因为总有可能实现某些功能以使其更快地执行。 还有，PR 可能会导致权利泛滥，在这种情况下，牵头开发人员实际上会管理每行代码。如果你有经验丰富的开发人员可以信任，他们可以处理，但是你可能会浪费他们的时间和技能。它还可能严重削弱开发人员的动力。 在较大的组织中，PR 也可能会导致办公室政治或者以权谋私的事情发生。 ","date":"2020-02-23","objectID":"/2020/02/version-management-strategy.zh/:2:0","tags":["git","git-flow","trunk-based development","TBD"],"title":"Version Management Strategy","uri":"/2020/02/version-management-strategy.zh/"},{"categories":["git"],"content":"Git-flow 的适用情况分析 git-flow 在什么时候最有效 当你在运营一个开源项目时 这种场景是开源社区，在这里效果最好。 由于每个人都可以做出贡献，因此你希望能够非常严格地访问所有更改。 你希望能够检查每一行代码，坦率地说，你不能相信贡献者。 通常，这些不是商业项目，因此开发速度不是问题。 当你有很多初级开发人员的时候 如果你主要与初级开发人员一起工作，那么你希望有一种方法来仔细检查他们的工作。 你可以为他们提供更多有关如何更有效地 Coding, 并帮助他们更快地提高编程技能。 接受 PR 的人员对重复发生的更改具有严格的控制权，因此可以防止代码质量下降。 当你已经有现成的产品的时候 当你已经有成功的产品时，这种方式也可以很好地发挥作用。 在这种情况下，通常将重点放在应用程序性能和负载功能上。 这种优化需要非常精确的更改。 通常，时间不是限制，因此这种控制在这里效果很好，尤其大型企业非常适合这种风格（因为他们不想破坏自己数百万的投资，他们需要严密控制每个变更）。 git-flow 会在什么情况下会有问题 当你启动一个新项目时 你可能希望快速创建最小可行的产品 (MVP)，提 PR 会产生巨大的瓶颈，这会大大降低整个团队的速度而你负担不起。Git 流程的问题在于，PR 可能会花费很多时间。 当你需要快速迭代 达到产品的第一个版本后，你很可能需要几次调整以满足你客户的需求。 同样，多个分支和 PR 会极大地降低开发速度，因此不建议这样做。 当你与高级开发人员一起工作时 如果你的团队主要由相互合作了较长时间的高级开发人员组成，那么你实际上就不需要上述的 PR 。你应该信任你的开发人员，并且知道他们是专业人士，让他们做好自己的工作，不要让所有 Git-Flow 的流程拖慢开发进度。 ","date":"2020-02-23","objectID":"/2020/02/version-management-strategy.zh/:2:1","tags":["git","git-flow","trunk-based development","TBD"],"title":"Version Management Strategy","uri":"/2020/02/version-management-strategy.zh/"},{"categories":["git"],"content":"Github-flow Github-flow 是在 git-flow 的基础上衍生而来的。他简化了 git-flow 的复杂模型，并且与 Github 可以很好的结合，在此就不赘述了。 ","date":"2020-02-23","objectID":"/2020/02/version-management-strategy.zh/:3:0","tags":["git","git-flow","trunk-based development","TBD"],"title":"Version Management Strategy","uri":"/2020/02/version-management-strategy.zh/"},{"categories":["git"],"content":"Trunk-based Development(TBD) 在基于主干的开发模型中，所有开发人员都在一个具有开放访问权限的分支上工作。通常它只是 master 分支。他们将代码提交给它并运行它，非常简单。 在某些情况下，它们会创建短暂的功能分支。 分支上的代码编译并通过所有测试后，便将其直接合并到 master。 它可确保开发真正连续进行，并防止开发人员创建难以解决的合并冲突。 用这种方法检查代码的唯一方法是进行完整的源代码检查。 通常，冗长的讨论是有限的。 没有人能严格控制源代码库中正在修改的内容，这就是为什么拥有可强制执行的代码样式很重要的原因。 以这种风格工作的开发人员应具有丰富的经验，以便你知道他们不会降低源代码的质量。 当你与经验丰富的软件开发人员团队一起工作时，这种工作方式可能会很棒。 它使他们能够快速引入新的改进，而无需不必要的官僚作风。 它还显示了你对它们的信任，因为它们可以将代码直接引入 master 分支。 此工作流程中的开发人员非常自治-他们直接交付并检查工作产品中的最终结果。 这种方法绝对没有办公室管理的微观管理和可能性。 另一方面，如果你没有经验丰富的团队，或者由于某种原因不信任他们，则不应该采用这种方法，而应选择 Git flow。它将为你节省不必要的后顾之忧。 ","date":"2020-02-23","objectID":"/2020/02/version-management-strategy.zh/:4:0","tags":["git","git-flow","trunk-based development","TBD"],"title":"Version Management Strategy","uri":"/2020/02/version-management-strategy.zh/"},{"categories":["git"],"content":"TBD 的适用情况分析 TBD 的适用情况与 git-flow 的适用情况恰好相反，可自行脑补。 我有话说 在我上个项目中，我们的版本控制策略则更激进。 我们所有的开发没有特性分支，所有的 Code 都在 Master 分支上开发，原因有如下： 我们的每张卡都拆的非常细（因为有老 BA) 我们每个人各自负责前端、移动端和后端 最重要的是我们的 CICD 完全一条龙操作，环境有 local、DEV、UAT 和 Prod, 在前一个环境 QA 验证不通过，是进入不到下一个环境的 如果开发速度比较快，有些内容是要在下个版本才要上，那么团队就需要启用 FeatureToggle 了， 关于这部分可参考之前的 《FeatureToggle 引起的。… 总结》。 软件开发是一场人、语言和工具的故事，但愿你在合适的场景选择合适的工具。 ","date":"2020-02-23","objectID":"/2020/02/version-management-strategy.zh/:4:1","tags":["git","git-flow","trunk-based development","TBD"],"title":"Version Management Strategy","uri":"/2020/02/version-management-strategy.zh/"},{"categories":["git"],"content":"Refs 1.https://rc.sydney.edu.au/git-user-guide/history.html 2.https://nvie.com/files/Git-branching-model.pdf 3.https://trunkbaseddevelopment.com 4.https://guides.github.com/introduction/flow/ ","date":"2020-02-23","objectID":"/2020/02/version-management-strategy.zh/:5:0","tags":["git","git-flow","trunk-based development","TBD"],"title":"Version Management Strategy","uri":"/2020/02/version-management-strategy.zh/"},{"categories":["tool"],"content":"将生成的 ssh 私钥添加到 Mac 的 keychain 中， 如果是其他操作系统，可忽略此步骤 $ ssh-add -K .ssh/is_rsa ","date":"2020-01-22","objectID":"/2020/01/config-ssh-to-keychina.zh/:1:0","tags":["ssh","keychain","linux","ssh-add"],"title":"Config ssh to Keychina","uri":"/2020/01/config-ssh-to-keychina.zh/"},{"categories":["tool"],"content":"将登录信息配置到。ssh/config 中 $ touch ~/.ssh/config $ vim ~/.ssh/config # edit text Host myvm Hostname ip User user ","date":"2020-01-22","objectID":"/2020/01/config-ssh-to-keychina.zh/:2:0","tags":["ssh","keychain","linux","ssh-add"],"title":"Config ssh to Keychina","uri":"/2020/01/config-ssh-to-keychina.zh/"},{"categories":["tool"],"content":"保存之后就可以使用如下命令快捷登录服务器了 $ ssh myvm ","date":"2020-01-22","objectID":"/2020/01/config-ssh-to-keychina.zh/:3:0","tags":["ssh","keychain","linux","ssh-add"],"title":"Config ssh to Keychina","uri":"/2020/01/config-ssh-to-keychina.zh/"},{"categories":["tool"],"content":"参考地址 https://blog.infox.ren/2019/10/24/ssh-guide/ ","date":"2020-01-22","objectID":"/2020/01/config-ssh-to-keychina.zh/:4:0","tags":["ssh","keychain","linux","ssh-add"],"title":"Config ssh to Keychina","uri":"/2020/01/config-ssh-to-keychina.zh/"},{"categories":["Web"],"content":"Cargo.toml cargo.toml是 Rust 包管理器 cargo 的清单文件。这个文件包 name、 version 和包的依赖，在 Rust 中，我们一般称之为 crate。 在示例中给出了一系列信息，但是我们主要讨论如下三点： crate-type wasm-bindgen 依赖 [features] 和 wee_alloc、console_error_panic_hook 依赖 ","date":"2019-11-27","objectID":"/2019/11/%E7%BF%BB%E8%AF%91hellowasm-pack-cargo.toml.zh/:1:0","tags":["Web","wams","webAssembly","rust"],"title":"[翻译]Hello,wasm Pack Cargo.toml","uri":"/2019/11/%E7%BF%BB%E8%AF%91hellowasm-pack-cargo.toml.zh/"},{"categories":["Web"],"content":"1.crate-type [lib] crate-type = [\"cdylib\", \"rlib\"] Rust-wasm 包与通常的 crate 有一点不同，作为 WebAssembly 项目， 我们需要在 cargo.toml 中加入该说明。 如果你熟悉其他的 Rust crate，那么你肯定知道，大多的 crate 的类型是 rlib（默认）， 或者是二进制形式的 bin（这种形式不需要 crate-type 注解）, 并且 [lib] 注解在普通的 Cargo 项目中并不需要指定。 crate-type = [“cdylib”] 指示你的工程将会被编译为动态系统库 [dynamic system library], 但是对于 WebAssembly，他将会编译为一个没有启动函数的 .wasm 文件，在 Linux 平台上，他将会创建*.so 文件，在 macOS 上将会创建*.dylib 文件，在 windows 平台上将会创建 *.dylib 文件。 我们通常指定 crate-type = [\"rlib\"] 来确保我们的库可以用 wasm-pack 来做单元测试（稍后会看到）。如果没有这个配置，我们将不能测试我们的库，因为 cdylib 包类型和 wasm-pack 的单元测试类型相冲突。 你可以使用此 链接 获取更多关于包类型的知识。 ","date":"2019-11-27","objectID":"/2019/11/%E7%BF%BB%E8%AF%91hellowasm-pack-cargo.toml.zh/:1:1","tags":["Web","wams","webAssembly","rust"],"title":"[翻译]Hello,wasm Pack Cargo.toml","uri":"/2019/11/%E7%BF%BB%E8%AF%91hellowasm-pack-cargo.toml.zh/"},{"categories":["Web"],"content":"2. wasm-bindgen 依赖 wasm-bindgen 在 WebAssembly 中是一个重要的依赖。 这个包允许我们使用 [wasm-bindgen] 为在 JavaScript 和 Rust 生成的 wasm 之间的代码打标签。以使我们使用它的属性可以导入 JS 并且导出 Rust。 wasm-bindgen = \"0.2\" 当我们讨论 lib.rs 生成什么内容的时候，将会看到更多关于怎么使用这个库。 如果你从 JavaScript 技术栈过来，你可能注意到了当我们添加依赖的时候并没有加 ^ 或者 ~ , 看起来像是我们只要 0.2 这个版本。然而，事实并非如此！在 Rust 里， ^ 是默认的，你可使用这个 链接 查看更多信息 ","date":"2019-11-27","objectID":"/2019/11/%E7%BF%BB%E8%AF%91hellowasm-pack-cargo.toml.zh/:1:2","tags":["Web","wams","webAssembly","rust"],"title":"[翻译]Hello,wasm Pack Cargo.toml","uri":"/2019/11/%E7%BF%BB%E8%AF%91hellowasm-pack-cargo.toml.zh/"},{"categories":["Web"],"content":"3. [features] 和 wee_alloc, console_error_panic_hook dependencies 作为我们设计模板的工作的一部分，该模板可帮助人们发现针对特定用例的有用包，该模板包括两个依赖项，这对于开发 Rust-wasm 包的人们可能非常有用：console_error_panic_hook 和 wee_alloc。 因为这些依赖关系主要在 Rust-wasm 包开发工作流程的特定部分中有用，所以我们还设置了一些粘合代码，使我们既可以将它们都包含为依赖关系，又可以选择将它们包含在内。 [features] default = [\"console_error_panic_hook\"] [dependencies] wasm-bindgen = \"0.2\" # The `console_error_panic_hook` crate provides better debugging of panics by # logging them with `console.error`. This is great for development, but requires # all the `std::fmt` and `std::panicking` infrastructure, so isn't great for # code size when deploying. console_error_panic_hook = { version = \"0.1.1\", optional = true } # `wee_alloc` is a tiny allocator for wasm that is only ~1K in code size # compared to the default allocator's ~10K. It is slower than the default # allocator, however. # # Unfortunately, `wee_alloc` requires nightly Rust when targeting wasm for now. wee_alloc = { version = \"0.4.2\", optional = true } 在我们的代码中，只有在启用某些 [features] 的情况下，我们才会将代码的某些部分标记为正在运行，特别是 console_error_panic_hook 和 wee_alloc。默认情况下，仅启用 console_error_panic_hook。要禁用或启用任一功能，默认情况下，我们可以在 [features] 下编辑 default 数组。 要了解有关这些功能的更多信息，我们将在 src/lib.rs 和 src/utils.rs 部分中深入讨论它们。 简要地，它们包括： console_error_panic_hook ，用于将奔溃消息记录到开发人员控制台的功能。 wee_alloc，一个使代码量更小而优化的分配器。 ","date":"2019-11-27","objectID":"/2019/11/%E7%BF%BB%E8%AF%91hellowasm-pack-cargo.toml.zh/:1:3","tags":["Web","wams","webAssembly","rust"],"title":"[翻译]Hello,wasm Pack Cargo.toml","uri":"/2019/11/%E7%BF%BB%E8%AF%91hellowasm-pack-cargo.toml.zh/"},{"categories":["Web"],"content":"Refs 1.https://guzhongren.github.io/ ","date":"2019-11-27","objectID":"/2019/11/%E7%BF%BB%E8%AF%91hellowasm-pack-cargo.toml.zh/:2:0","tags":["Web","wams","webAssembly","rust"],"title":"[翻译]Hello,wasm Pack Cargo.toml","uri":"/2019/11/%E7%BF%BB%E8%AF%91hellowasm-pack-cargo.toml.zh/"},{"categories":["Web"],"content":"基于 Rust 的 WebAssembly 工程开发过程小记","date":"2019-11-23","objectID":"/2019/11/%E5%9F%BA%E4%BA%8Erust%E7%9A%84webassembly%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E5%B0%8F%E8%AE%B0/","tags":["Web","wams","webAssembly","rust","wasm-bridge"],"title":"基于 Rust 的 WebAssembly 工程开发过程小记","uri":"/2019/11/%E5%9F%BA%E4%BA%8Erust%E7%9A%84webassembly%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E5%B0%8F%E8%AE%B0/"},{"categories":["Web"],"content":"初始化工程 $ npm init rust-webpack web_assembly_demo npx: 18 安装成功，用时 3.989 秒 Rust + WebAssembly + Webpack = ️ Installed dependencies ","date":"2019-11-23","objectID":"/2019/11/%E5%9F%BA%E4%BA%8Erust%E7%9A%84webassembly%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E5%B0%8F%E8%AE%B0/:1:0","tags":["Web","wams","webAssembly","rust","wasm-bridge"],"title":"基于 Rust 的 WebAssembly 工程开发过程小记","uri":"/2019/11/%E5%9F%BA%E4%BA%8Erust%E7%9A%84webassembly%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E5%B0%8F%E8%AE%B0/"},{"categories":["Web"],"content":"安装 Web 依赖 $ yarn yarn install v1.19.1 warning package.json: No license field info No lockfile found. warning package-lock.json found. Your project contains lock files generated by tools other than Yarn. It is advised not to mix package managers in order to avoid resolution inconsistencies caused by unsynchronized lock files. To clear this warning, remove package-lock.json. warning rust-webpack-template@0.1.0: No license field [1/4] Resolving packages... warning @wasm-tool/wasm-pack-plugin \u003e watchpack \u003e chokidar \u003e fsevents@1.2.9: One of your dependencies needs to upgrade to fsevents v2: 1) Proper nodejs v10+ support 2) No more fetching binaries from AWS, smaller package size [2/4] Fetching packages... [3/4] Linking dependencies... [4/4] Building fresh packages... success Saved lockfile. Done in 17.87s. ","date":"2019-11-23","objectID":"/2019/11/%E5%9F%BA%E4%BA%8Erust%E7%9A%84webassembly%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E5%B0%8F%E8%AE%B0/:2:0","tags":["Web","wams","webAssembly","rust","wasm-bridge"],"title":"基于 Rust 的 WebAssembly 工程开发过程小记","uri":"/2019/11/%E5%9F%BA%E4%BA%8Erust%E7%9A%84webassembly%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E5%B0%8F%E8%AE%B0/"},{"categories":["Web"],"content":"修改 Cargo.toml 为 # You must change these to your own details. [package] name = \"web_assembly_demo\" description = \"My super awesome Rust, WebAssembly, and Webpack project!\" version = \"0.1.0\" authors = [\"guzhongren \u003cguzhoongren@live.cn\u003e\"] categories = [\"wasm\"] readme = \"README.md\" edition = \"2018\" [lib] crate-type = [\"cdylib\"] [profile.release] # This makes the compiled code faster and smaller, but it makes compiling slower, # so it's only enabled in release mode. lto = true [features] # If you uncomment this line, it will enable `wee_alloc`: #default = [\"wee_alloc\"] [dependencies] # The `wasm-bindgen` crate provides the bare minimum functionality needed # to interact with JavaScript. wasm-bindgen = \"0.2.45\" # `wee_alloc` is a tiny allocator for wasm that is only ~1K in code size # compared to the default allocator's ~10K. However, it is slower than the default # allocator, so it's not enabled by default. wee_alloc = { version = \"0.4.2\", optional = true } # The `web-sys` crate allows you to interact with the various browser APIs, # like the DOM. [dependencies.web-sys] version = \"0.3.22\" features = [\"console\"] # The `console_error_panic_hook` crate provides better debugging of panics by # logging them with `console.error`. This is great for development, but requires # all the `std::fmt` and `std::panicking` infrastructure, so it's only enabled # in debug mode. [target.\"cfg(debug_assertions)\".dependencies] console_error_panic_hook = \"0.1.5\" # These crates are used for running unit tests. [dev-dependencies] wasm-bindgen-test = \"0.2.45\" futures = \"0.1.27\" js-sys = \"0.3.22\" wasm-bindgen-futures = \"0.3.22\" Rust 的依赖会在启动 Web 程序的时候自动安装。 ","date":"2019-11-23","objectID":"/2019/11/%E5%9F%BA%E4%BA%8Erust%E7%9A%84webassembly%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E5%B0%8F%E8%AE%B0/:3:0","tags":["Web","wams","webAssembly","rust","wasm-bridge"],"title":"基于 Rust 的 WebAssembly 工程开发过程小记","uri":"/2019/11/%E5%9F%BA%E4%BA%8Erust%E7%9A%84webassembly%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E5%B0%8F%E8%AE%B0/"},{"categories":["Web"],"content":"启动程序 $ yarn start yarn run v1.19.1 warning package.json: No license field $ rimraf dist pkg \u0026\u0026 webpack-dev-server --open -d 🧐 Checking for wasm-pack... wasm-pack is installed. ℹ️ Compiling your crate in development mode... ℹ ｢wds｣: Project is running at http://localhost:8080/ ℹ ｢wds｣: webpack output is served from / ℹ ｢wds｣: Content not from webpack is served from /Users/c4/Desktop/Personal/01.Project/web_assembly/web_assembly_demo/dist [INFO]: Checking for the Wasm target... [INFO]: Compiling to Wasm... ℹ ｢wdm｣: wait until bundle finished: / Compiling proc-macro2 v1.0.6 Compiling unicode-xid v0.2.0 ... 3 assets Entrypoint index = index.js [./pkg/index.js] 4.41 KiB {0} [built] [./pkg/index_bg.wasm] 145 KiB {0} [built] + 33 hidden modules ℹ ｢wdm｣: Compiled successfully. ℹ️ Compiling your crate in development mode... [INFO]: Checking for the Wasm target... [INFO]: Compiling to Wasm... Compiling rust-webpack-template v0.1.0 (/Users/c4/Desktop/Personal/01.Project/web_assembly/web_assembly_demo) Finished dev [unoptimized + debuginfo] target(s) in 0.62s [INFO]: ⬇️ Installing wasm-bindgen... [INFO]: Optional fields missing from Cargo.toml: 'repository', 'license'. These are not necessary, but recommended [INFO]: Done in 0.77s [INFO]: Your wasm pkg is ready to publish at ./pkg. Your crate has been correctly compiled ℹ ｢wdm｣: Compiling... ℹ ｢wdm｣: Hash: d4e8a3c57ad23f847707 Version: webpack 4.41.2 Time: 411ms Built at: 2019-11-23 20:16:55 Asset Size Chunks Chunk Names 0.js 17 KiB 0 [emitted] beee557fb69dcfa0df60.module.wasm 161 KiB 0 [emitted] [immutable] index.js 897 KiB index [emitted] index Entrypoint index = index.js [./pkg/index.js] 4.93 KiB {0} [built] [./pkg/index_bg.wasm] 161 KiB {0} [built] + 33 hidden modules ℹ ｢wdm｣: Compiled successfully. ℹ ｢wdm｣: Compiling... ℹ ｢wdm｣: Hash: 3e1681b9b4c4c940722e Version: webpack 4.41.2 Time: 16ms Built at: 2019-11-23 20:17:14 Asset Size Chunks Chunk Names index.js 897 KiB index [emitted] index + 2 hidden assets ","date":"2019-11-23","objectID":"/2019/11/%E5%9F%BA%E4%BA%8Erust%E7%9A%84webassembly%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E5%B0%8F%E8%AE%B0/:4:0","tags":["Web","wams","webAssembly","rust","wasm-bridge"],"title":"基于 Rust 的 WebAssembly 工程开发过程小记","uri":"/2019/11/%E5%9F%BA%E4%BA%8Erust%E7%9A%84webassembly%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E5%B0%8F%E8%AE%B0/"},{"categories":["Web"],"content":"在 src 中新建 parse.rs 并编写处理 markdown 的 rust 代码 struct Parser{pos: usize,input: String,}pubfn parse(source: String)-\u003e String {Parser{pos: 0,input: source,}.parse_lines()}implParser{fn parse_lines(\u0026mutself)-\u003e String {letmutresult=String::new();loop{self.consume_whitespace();ifself.end_of_line(){break;}result.push_str(\u0026self.parse_line());}result}fn parse_line(\u0026mutself)-\u003e String {matchself.next_char(){'#'=\u003eself.parse_title(),'-'=\u003e{ifchar::is_whitespace(self.input[self.pos+1..].chars().next().unwrap()){self.parse_list()}else{self.parse_text()}}_=\u003eself.parse_text(),}}fn parse_list(\u0026mutself)-\u003e String {self.consume_char();self.consume_whitespace();lettext=self.parse_text();create_html_element(\"li\".to_string(),text)}fn parse_title(\u0026mutself)-\u003e String {letpound=self.consume_while(|c|c=='#');self.consume_whitespace();lettext=self.parse_text();create_html_element(format!(\"h{}\",pound.len()),text)}fn parse_text(\u0026mutself)-\u003e String {self.consume_while(|c|!is_new_line(c))}fn end_of_line(\u0026self)-\u003e bool {self.pos\u003e=self.input.len()}// fn starts_with(\u0026self, s: \u0026str) -\u003e bool { // self.input[self.pos..].starts_with(s) // } fn next_char(\u0026self)-\u003e char {self.input[self.pos..].chars().next().unwrap()}fn consume_char(\u0026mutself)-\u003e char {letmutiter=self.input[self.pos..].char_indices();let(_,cur_char)=iter.next().unwrap();let(next_pos,_)=iter.next().unwrap_or((1,' '));self.pos+=next_pos;cur_char}fn consume_while\u003cF\u003e(\u0026mutself,cond: F)-\u003e String whereF: Fn(char)-\u003e bool,{letmutresult=String::new();while!self.end_of_line()\u0026\u0026cond(self.next_char()){result.push(self.consume_char());}result}fn consume_whitespace(\u0026mutself){self.consume_while(char::is_whitespace);}}fn create_html_element(tag_name: String,text: String)-\u003e String {format!(\"\u003c{}\u003e{}\u003c/{}\u003e\",tag_name,text,tag_name)}fn is_new_line(c: char)-\u003e bool {c=='\\n'} ","date":"2019-11-23","objectID":"/2019/11/%E5%9F%BA%E4%BA%8Erust%E7%9A%84webassembly%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E5%B0%8F%E8%AE%B0/:5:0","tags":["Web","wams","webAssembly","rust","wasm-bridge"],"title":"基于 Rust 的 WebAssembly 工程开发过程小记","uri":"/2019/11/%E5%9F%BA%E4%BA%8Erust%E7%9A%84webassembly%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E5%B0%8F%E8%AE%B0/"},{"categories":["Web"],"content":"在 src/lib.rs 中引入 parse mod， 并编写向外暴露的函数 mod parser;externcratewasm_bindgen;usewasm_bindgen::prelude::*;#[wasm_bindgen]pubfn parse(input: \u0026str)-\u003e String {letresult=parser::parse(input.to_string());result} ","date":"2019-11-23","objectID":"/2019/11/%E5%9F%BA%E4%BA%8Erust%E7%9A%84webassembly%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E5%B0%8F%E8%AE%B0/:6:0","tags":["Web","wams","webAssembly","rust","wasm-bridge"],"title":"基于 Rust 的 WebAssembly 工程开发过程小记","uri":"/2019/11/%E5%9F%BA%E4%BA%8Erust%E7%9A%84webassembly%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E5%B0%8F%E8%AE%B0/"},{"categories":["Web"],"content":"在 js/index.js 中使用 Web Assembly ，修改结果如下 document.body.onload=addElement;functionaddElement(){constmarkdown=document.createElement('textarea')markdown.id='markdown'markdown.style=\"height: 300px; width: 400px ;\"document.body.appendChild(markdown)constparseBtn=document.createElement('button')parseBtn.id='parse'parseBtn.innerHTML='解析markdown'document.body.appendChild(parseBtn)constpreviewArea=document.createElement('div')previewArea.id='preview'document.body.appendChild(previewArea)construst=import('../pkg/index.js')rust.then(module=\u003e{constbtn=document.getElementById('parse')constpreviewArea=document.getElementById('preview')btn.addEventListener('click',()=\u003e{constinput=document.getElementById('markdown').valuepreviewArea.innerHTML=module.parse(input)})})}// import(\"../pkg/index.js\").then(module =\u003e { // const input = '1233' // previewArea.innerHTML = module.parse(input) // }).catch(console.error); ","date":"2019-11-23","objectID":"/2019/11/%E5%9F%BA%E4%BA%8Erust%E7%9A%84webassembly%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E5%B0%8F%E8%AE%B0/:7:0","tags":["Web","wams","webAssembly","rust","wasm-bridge"],"title":"基于 Rust 的 WebAssembly 工程开发过程小记","uri":"/2019/11/%E5%9F%BA%E4%BA%8Erust%E7%9A%84webassembly%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E5%B0%8F%E8%AE%B0/"},{"categories":["Web"],"content":"效果图 ","date":"2019-11-23","objectID":"/2019/11/%E5%9F%BA%E4%BA%8Erust%E7%9A%84webassembly%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E5%B0%8F%E8%AE%B0/:8:0","tags":["Web","wams","webAssembly","rust","wasm-bridge"],"title":"基于 Rust 的 WebAssembly 工程开发过程小记","uri":"/2019/11/%E5%9F%BA%E4%BA%8Erust%E7%9A%84webassembly%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E5%B0%8F%E8%AE%B0/"},{"categories":["Web"],"content":"在线体验 Markdown editor: https://andorlab.github.io/WebAssembly/ ","date":"2019-11-23","objectID":"/2019/11/%E5%9F%BA%E4%BA%8Erust%E7%9A%84webassembly%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E5%B0%8F%E8%AE%B0/:9:0","tags":["Web","wams","webAssembly","rust","wasm-bridge"],"title":"基于 Rust 的 WebAssembly 工程开发过程小记","uri":"/2019/11/%E5%9F%BA%E4%BA%8Erust%E7%9A%84webassembly%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E5%B0%8F%E8%AE%B0/"},{"categories":["Web"],"content":"后续 后面会在这个基础上继续开发，并将 WASM 中的一些概念配置也写成文档共享在博客中。 ","date":"2019-11-23","objectID":"/2019/11/%E5%9F%BA%E4%BA%8Erust%E7%9A%84webassembly%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E5%B0%8F%E8%AE%B0/:10:0","tags":["Web","wams","webAssembly","rust","wasm-bridge"],"title":"基于 Rust 的 WebAssembly 工程开发过程小记","uri":"/2019/11/%E5%9F%BA%E4%BA%8Erust%E7%9A%84webassembly%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E5%B0%8F%E8%AE%B0/"},{"categories":["Web"],"content":"仓库地址：https://github.com/AndorLab/web_assembly/tree/based_rust ","date":"2019-11-23","objectID":"/2019/11/%E5%9F%BA%E4%BA%8Erust%E7%9A%84webassembly%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E5%B0%8F%E8%AE%B0/:11:0","tags":["Web","wams","webAssembly","rust","wasm-bridge"],"title":"基于 Rust 的 WebAssembly 工程开发过程小记","uri":"/2019/11/%E5%9F%BA%E4%BA%8Erust%E7%9A%84webassembly%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E5%B0%8F%E8%AE%B0/"},{"categories":["Web"],"content":"Refs 1. 博客：https://guzhongren.github.io/ 2. 图床：https://sm.ms/ ","date":"2019-11-23","objectID":"/2019/11/%E5%9F%BA%E4%BA%8Erust%E7%9A%84webassembly%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E5%B0%8F%E8%AE%B0/:12:0","tags":["Web","wams","webAssembly","rust","wasm-bridge"],"title":"基于 Rust 的 WebAssembly 工程开发过程小记","uri":"/2019/11/%E5%9F%BA%E4%BA%8Erust%E7%9A%84webassembly%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E5%B0%8F%E8%AE%B0/"},{"categories":["Web"],"content":"Disclaimer 本文仅代表个人观点，与 Thoughtworks 公司无任何关系。 ","date":"2019-11-23","objectID":"/2019/11/%E5%9F%BA%E4%BA%8Erust%E7%9A%84webassembly%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E5%B0%8F%E8%AE%B0/:13:0","tags":["Web","wams","webAssembly","rust","wasm-bridge"],"title":"基于 Rust 的 WebAssembly 工程开发过程小记","uri":"/2019/11/%E5%9F%BA%E4%BA%8Erust%E7%9A%84webassembly%E5%B7%A5%E7%A8%8B%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E5%B0%8F%E8%AE%B0/"},{"categories":["tool"],"content":"插件 在 VS Code 上进行 Rust 的开发，需要使用一下两个库 RLS(vscode 搜索插件 rls) lldb(vscode 搜索插件 codelldb) 安装很简单，不用说 ","date":"2019-10-17","objectID":"/2019/10/%E5%9C%A8-vscode-%E4%B8%8A%E9%85%8D%E7%BD%AErust%E7%9A%84%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83.zh/:1:0","tags":["Rust","Debug","VS","Code"],"title":"在 VSCode 上配置 Rust 的调试环境","uri":"/2019/10/%E5%9C%A8-vscode-%E4%B8%8A%E9%85%8D%E7%BD%AErust%E7%9A%84%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83.zh/"},{"categories":["tool"],"content":"配置 { // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问：https://go.microsoft.com/fwlink/?linkid=830387 \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"Debug executable 'show_posts'\", // 配置名称，将会在调试配置下拉列表中显示 \"type\": \"lldb\", // 调试器类型：Windows 表示器使用 cppvsdbg；GDB 和 LLDB 使用 cppdbg。该值自动生成 \"request\": \"launch\", // 调试方式 \"cargo\": { // 运行的参数 \"args\": [ \"build\", \"--bin=show_posts\", \"--package=diesel_demo\" ], \"filter\": { \"name\": \"show_posts\", \"kind\": \"bin\" } }, \"args\": [], // 传递给程序的参数，没有参数留空即可 \"cwd\": \"${workspaceFolder}\" // 调试程序时的工作目录 }, } ","date":"2019-10-17","objectID":"/2019/10/%E5%9C%A8-vscode-%E4%B8%8A%E9%85%8D%E7%BD%AErust%E7%9A%84%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83.zh/:2:0","tags":["Rust","Debug","VS","Code"],"title":"在 VSCode 上配置 Rust 的调试环境","uri":"/2019/10/%E5%9C%A8-vscode-%E4%B8%8A%E9%85%8D%E7%BD%AErust%E7%9A%84%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83.zh/"},{"categories":["tool"],"content":"调试 ","date":"2019-10-17","objectID":"/2019/10/%E5%9C%A8-vscode-%E4%B8%8A%E9%85%8D%E7%BD%AErust%E7%9A%84%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83.zh/:3:0","tags":["Rust","Debug","VS","Code"],"title":"在 VSCode 上配置 Rust 的调试环境","uri":"/2019/10/%E5%9C%A8-vscode-%E4%B8%8A%E9%85%8D%E7%BD%AErust%E7%9A%84%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83.zh/"},{"categories":["tool"],"content":"Refs 1.https://guzhongren.github.io/ ","date":"2019-10-17","objectID":"/2019/10/%E5%9C%A8-vscode-%E4%B8%8A%E9%85%8D%E7%BD%AErust%E7%9A%84%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83.zh/:4:0","tags":["Rust","Debug","VS","Code"],"title":"在 VSCode 上配置 Rust 的调试环境","uri":"/2019/10/%E5%9C%A8-vscode-%E4%B8%8A%E9%85%8D%E7%BD%AErust%E7%9A%84%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83.zh/"},{"categories":["Code"],"content":"情景 在我们开发中，我们通常需要对某一系列的组件 Coding, 但我们是程序员啊，我们怎么能容忍代码重复出现的坏味道呢。所以，对于一些列相同的操作我们就要用到循环处理了。 ","date":"2019-10-14","objectID":"/2019/10/%E5%B0%86%E5%87%BD%E6%95%B0%E6%94%BE%E5%9C%A8%E5%AF%B9%E8%B1%A1%E7%9A%84value%E4%B8%8A%E7%84%B6%E5%90%8E%E4%BC%A0%E7%BB%99%E7%BB%84%E4%BB%B6%E6%89%A7%E8%A1%8C%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6%E6%8A%BD%E8%B1%A1.zh/:1:0","tags":["code","refactor","react","reactNative","技术债务"],"title":"将函数放在对象的 Value 上，然后传给组件执行，实现组件抽象","uri":"/2019/10/%E5%B0%86%E5%87%BD%E6%95%B0%E6%94%BE%E5%9C%A8%E5%AF%B9%E8%B1%A1%E7%9A%84value%E4%B8%8A%E7%84%B6%E5%90%8E%E4%BC%A0%E7%BB%99%E7%BB%84%E4%BB%B6%E6%89%A7%E8%A1%8C%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6%E6%8A%BD%E8%B1%A1.zh/"},{"categories":["Code"],"content":"目标 我们需要将底部两个按钮 新建询价和 采购助手展示出来，并且点击他们的操作后有不同的交互。 ","date":"2019-10-14","objectID":"/2019/10/%E5%B0%86%E5%87%BD%E6%95%B0%E6%94%BE%E5%9C%A8%E5%AF%B9%E8%B1%A1%E7%9A%84value%E4%B8%8A%E7%84%B6%E5%90%8E%E4%BC%A0%E7%BB%99%E7%BB%84%E4%BB%B6%E6%89%A7%E8%A1%8C%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6%E6%8A%BD%E8%B1%A1.zh/:2:0","tags":["code","refactor","react","reactNative","技术债务"],"title":"将函数放在对象的 Value 上，然后传给组件执行，实现组件抽象","uri":"/2019/10/%E5%B0%86%E5%87%BD%E6%95%B0%E6%94%BE%E5%9C%A8%E5%AF%B9%E8%B1%A1%E7%9A%84value%E4%B8%8A%E7%84%B6%E5%90%8E%E4%BC%A0%E7%BB%99%E7%BB%84%E4%BB%B6%E6%89%A7%E8%A1%8C%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6%E6%8A%BD%E8%B1%A1.zh/"},{"categories":["Code"],"content":"coding 对于此情况，我们需要将对两个按钮做抽象，抽象为数组，在 render 函数里循环执行即可，这里有个地方需要说明一下，我们把事件处理函数也放在了抽象好的对象上，如下 const tools = [ { index: 1, image: images.tabs.newEnquiryTool, title: '新建询价', onPress: () =\u003e { this.props.controlToolVisible(false) Actions.newEnquiry() }, }, { index: 2, image: images.tabs.purchaseAsstant, title: '采购助手', onPress: () =\u003e { Chatlogin().then(data =\u003e { if (data) { this.props.getAccountInfo(_.get(global.USER_INFO, 'imInfo.mpcAccId')) .then(chatInfo =\u003e { this.props.controlToolVisible(false) Actions.chat({ session: { contactId: 123, name: '31231', sessionType: '0' } }) }) .catch(console.error) } }) }, }, ] 在 render 函数里我们循环即可实现代码的抽象 { tools.map((tool) =\u003e ( \u003cTouchableOpacity style={styles.toolWrapper} key={tool.index} onPress={tool.onPress} \u003e \u003cImage source={tool.image} /\u003e \u003cText style={styles.text}\u003e{tool.title}\u003c/Text\u003e \u003c/TouchableOpacity\u003e)) } ","date":"2019-10-14","objectID":"/2019/10/%E5%B0%86%E5%87%BD%E6%95%B0%E6%94%BE%E5%9C%A8%E5%AF%B9%E8%B1%A1%E7%9A%84value%E4%B8%8A%E7%84%B6%E5%90%8E%E4%BC%A0%E7%BB%99%E7%BB%84%E4%BB%B6%E6%89%A7%E8%A1%8C%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6%E6%8A%BD%E8%B1%A1.zh/:3:0","tags":["code","refactor","react","reactNative","技术债务"],"title":"将函数放在对象的 Value 上，然后传给组件执行，实现组件抽象","uri":"/2019/10/%E5%B0%86%E5%87%BD%E6%95%B0%E6%94%BE%E5%9C%A8%E5%AF%B9%E8%B1%A1%E7%9A%84value%E4%B8%8A%E7%84%B6%E5%90%8E%E4%BC%A0%E7%BB%99%E7%BB%84%E4%BB%B6%E6%89%A7%E8%A1%8C%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6%E6%8A%BD%E8%B1%A1.zh/"},{"categories":["Code"],"content":"总结 代码总是可以解决很多问题，在 Coding 时，应该及时重构，将代码中的坏味道及时剔除，为以后业务功能开发解决技术债。 ","date":"2019-10-14","objectID":"/2019/10/%E5%B0%86%E5%87%BD%E6%95%B0%E6%94%BE%E5%9C%A8%E5%AF%B9%E8%B1%A1%E7%9A%84value%E4%B8%8A%E7%84%B6%E5%90%8E%E4%BC%A0%E7%BB%99%E7%BB%84%E4%BB%B6%E6%89%A7%E8%A1%8C%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6%E6%8A%BD%E8%B1%A1.zh/:4:0","tags":["code","refactor","react","reactNative","技术债务"],"title":"将函数放在对象的 Value 上，然后传给组件执行，实现组件抽象","uri":"/2019/10/%E5%B0%86%E5%87%BD%E6%95%B0%E6%94%BE%E5%9C%A8%E5%AF%B9%E8%B1%A1%E7%9A%84value%E4%B8%8A%E7%84%B6%E5%90%8E%E4%BC%A0%E7%BB%99%E7%BB%84%E4%BB%B6%E6%89%A7%E8%A1%8C%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6%E6%8A%BD%E8%B1%A1.zh/"},{"categories":["Code"],"content":"Refs 1.https://guzhongren.github.io/ ","date":"2019-10-14","objectID":"/2019/10/%E5%B0%86%E5%87%BD%E6%95%B0%E6%94%BE%E5%9C%A8%E5%AF%B9%E8%B1%A1%E7%9A%84value%E4%B8%8A%E7%84%B6%E5%90%8E%E4%BC%A0%E7%BB%99%E7%BB%84%E4%BB%B6%E6%89%A7%E8%A1%8C%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6%E6%8A%BD%E8%B1%A1.zh/:5:0","tags":["code","refactor","react","reactNative","技术债务"],"title":"将函数放在对象的 Value 上，然后传给组件执行，实现组件抽象","uri":"/2019/10/%E5%B0%86%E5%87%BD%E6%95%B0%E6%94%BE%E5%9C%A8%E5%AF%B9%E8%B1%A1%E7%9A%84value%E4%B8%8A%E7%84%B6%E5%90%8E%E4%BC%A0%E7%BB%99%E7%BB%84%E4%BB%B6%E6%89%A7%E8%A1%8C%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6%E6%8A%BD%E8%B1%A1.zh/"},{"categories":["git","revert","multRevert"],"content":"我需要撤销最后的四个提交 如果用* git revert * 一个一个 revert 挺费劲，可以用* git revert OLDER_COMMIT^..NEWER_COMMIT* 这种格式，对应我的工程就是 $ git revert 54b23c2251acde.....09123463e99436fba83f9^..a19a10b24b648b80401234686aac65... 这样会在 log 上多留下四条 revert 相关的记录，我不想生成 revert 相关的记录呢？可以的 $ git revert -n 54b23c2251acde.....09123463e99436fba83f9^..a19a10b24b648b80401234686aac65... 就是多加个 -n 参数，然后再通过 git add 和 git commit 等步骤就可以了。 最后的效果如下 ","date":"2019-09-30","objectID":"/2019/09/git-revert-%E5%A4%9A%E6%9D%A1%E5%B7%B2%E6%8F%90%E4%BA%A4%E7%9A%84%E8%AE%B0%E5%BD%95.zh/:0:0","tags":["git"],"title":"Git Revert 多条已提交的记录","uri":"/2019/09/git-revert-%E5%A4%9A%E6%9D%A1%E5%B7%B2%E6%8F%90%E4%BA%A4%E7%9A%84%E8%AE%B0%E5%BD%95.zh/"},{"categories":["git","revert","multRevert"],"content":"Refs 1.https://guzhongren.github.io/ ","date":"2019-09-30","objectID":"/2019/09/git-revert-%E5%A4%9A%E6%9D%A1%E5%B7%B2%E6%8F%90%E4%BA%A4%E7%9A%84%E8%AE%B0%E5%BD%95.zh/:1:0","tags":["git"],"title":"Git Revert 多条已提交的记录","uri":"/2019/09/git-revert-%E5%A4%9A%E6%9D%A1%E5%B7%B2%E6%8F%90%E4%BA%A4%E7%9A%84%E8%AE%B0%E5%BD%95.zh/"},{"categories":["Tool"],"content":"场景 在平时开发中我们有自己的 git 仓库，组内提交都是在这个库。突然有一天，领导说要把这个库整合到另一个更大的工程中（华为云的看板），那里面有前后端的代码；为了方便大家查找，我们需要将各个组的代码迁移到同一个大工程下。 ","date":"2019-09-30","objectID":"/2019/09/%E4%BD%BF%E7%94%A8git%E8%BF%81%E7%A7%BBgit%E9%A1%B9%E7%9B%AE%E5%B9%B6%E4%BF%9D%E7%95%99%E6%8F%90%E4%BA%A4%E8%AE%B0%E5%BD%95.zh/:1:0","tags":["git","git mirror","git bare","git commit","origin"],"title":"使用 git 迁移 git 项目并保留提交记录","uri":"/2019/09/%E4%BD%BF%E7%94%A8git%E8%BF%81%E7%A7%BBgit%E9%A1%B9%E7%9B%AE%E5%B9%B6%E4%BF%9D%E7%95%99%E6%8F%90%E4%BA%A4%E8%AE%B0%E5%BD%95.zh/"},{"categories":["Tool"],"content":"问题 提交要保留提交记录 changelog 要保留 组内成员要保留 ","date":"2019-09-30","objectID":"/2019/09/%E4%BD%BF%E7%94%A8git%E8%BF%81%E7%A7%BBgit%E9%A1%B9%E7%9B%AE%E5%B9%B6%E4%BF%9D%E7%95%99%E6%8F%90%E4%BA%A4%E8%AE%B0%E5%BD%95.zh/:2:0","tags":["git","git mirror","git bare","git commit","origin"],"title":"使用 git 迁移 git 项目并保留提交记录","uri":"/2019/09/%E4%BD%BF%E7%94%A8git%E8%BF%81%E7%A7%BBgit%E9%A1%B9%E7%9B%AE%E5%B9%B6%E4%BF%9D%E7%95%99%E6%8F%90%E4%BA%A4%E8%AE%B0%E5%BD%95.zh/"},{"categories":["Tool"],"content":"解决方案 git push --mirror ...... ","date":"2019-09-30","objectID":"/2019/09/%E4%BD%BF%E7%94%A8git%E8%BF%81%E7%A7%BBgit%E9%A1%B9%E7%9B%AE%E5%B9%B6%E4%BF%9D%E7%95%99%E6%8F%90%E4%BA%A4%E8%AE%B0%E5%BD%95.zh/:3:0","tags":["git","git mirror","git bare","git commit","origin"],"title":"使用 git 迁移 git 项目并保留提交记录","uri":"/2019/09/%E4%BD%BF%E7%94%A8git%E8%BF%81%E7%A7%BBgit%E9%A1%B9%E7%9B%AE%E5%B9%B6%E4%BF%9D%E7%95%99%E6%8F%90%E4%BA%A4%E8%AE%B0%E5%BD%95.zh/"},{"categories":["Tool"],"content":"操作 假如我们原有的仓库为git@codehub.devcloud.huaweicloud.com:project.git 1. 从原地址克隆一份裸版本库 $ git clone --bare git@codehub.devcloud.huaweicloud.com:project.git ...... 2. 在新目录创建 git 空项目 这一步是为了让旧项目有镜像 假如新仓库地址为git@codehub.devcloud.huaweicloud.com:leaderProject.git 3. 镜像推送代码到新仓库 进入旧 git 目录，推送即可 $ cd project $ git push --mirror git@codehub.devcloud.huaweicloud.com:leaderProject.git ","date":"2019-09-30","objectID":"/2019/09/%E4%BD%BF%E7%94%A8git%E8%BF%81%E7%A7%BBgit%E9%A1%B9%E7%9B%AE%E5%B9%B6%E4%BF%9D%E7%95%99%E6%8F%90%E4%BA%A4%E8%AE%B0%E5%BD%95.zh/:4:0","tags":["git","git mirror","git bare","git commit","origin"],"title":"使用 git 迁移 git 项目并保留提交记录","uri":"/2019/09/%E4%BD%BF%E7%94%A8git%E8%BF%81%E7%A7%BBgit%E9%A1%B9%E7%9B%AE%E5%B9%B6%E4%BF%9D%E7%95%99%E6%8F%90%E4%BA%A4%E8%AE%B0%E5%BD%95.zh/"},{"categories":["Tool"],"content":"晒个图 ","date":"2019-09-30","objectID":"/2019/09/%E4%BD%BF%E7%94%A8git%E8%BF%81%E7%A7%BBgit%E9%A1%B9%E7%9B%AE%E5%B9%B6%E4%BF%9D%E7%95%99%E6%8F%90%E4%BA%A4%E8%AE%B0%E5%BD%95.zh/:5:0","tags":["git","git mirror","git bare","git commit","origin"],"title":"使用 git 迁移 git 项目并保留提交记录","uri":"/2019/09/%E4%BD%BF%E7%94%A8git%E8%BF%81%E7%A7%BBgit%E9%A1%B9%E7%9B%AE%E5%B9%B6%E4%BF%9D%E7%95%99%E6%8F%90%E4%BA%A4%E8%AE%B0%E5%BD%95.zh/"},{"categories":["Tool"],"content":"Refs 1. 博客：https://guzhongren.github.io/ 2. 原文：https://yq.aliyun.com/articles/675073?spm=a2c4e.11155435.0.0.27543312iFnJbY ","date":"2019-09-30","objectID":"/2019/09/%E4%BD%BF%E7%94%A8git%E8%BF%81%E7%A7%BBgit%E9%A1%B9%E7%9B%AE%E5%B9%B6%E4%BF%9D%E7%95%99%E6%8F%90%E4%BA%A4%E8%AE%B0%E5%BD%95.zh/:6:0","tags":["git","git mirror","git bare","git commit","origin"],"title":"使用 git 迁移 git 项目并保留提交记录","uri":"/2019/09/%E4%BD%BF%E7%94%A8git%E8%BF%81%E7%A7%BBgit%E9%A1%B9%E7%9B%AE%E5%B9%B6%E4%BF%9D%E7%95%99%E6%8F%90%E4%BA%A4%E8%AE%B0%E5%BD%95.zh/"},{"categories":["Tool"],"content":"Disclaimer 本文仅代表个人观点，与 Thoughtworks 公司无任何关系。 ","date":"2019-09-30","objectID":"/2019/09/%E4%BD%BF%E7%94%A8git%E8%BF%81%E7%A7%BBgit%E9%A1%B9%E7%9B%AE%E5%B9%B6%E4%BF%9D%E7%95%99%E6%8F%90%E4%BA%A4%E8%AE%B0%E5%BD%95.zh/:7:0","tags":["git","git mirror","git bare","git commit","origin"],"title":"使用 git 迁移 git 项目并保留提交记录","uri":"/2019/09/%E4%BD%BF%E7%94%A8git%E8%BF%81%E7%A7%BBgit%E9%A1%B9%E7%9B%AE%E5%B9%B6%E4%BF%9D%E7%95%99%E6%8F%90%E4%BA%A4%E8%AE%B0%E5%BD%95.zh/"},{"categories":["Golang"],"content":"Dependency Injection 🧪 依赖注入是目前很多优秀框架都在使用的一个设计模式。 Dependency Injection 常常简称为：DI。它是实现控制反转（Inversion of Control – IoC）的一个模式。 在各种大工程中少不了各种测试，其中 TDD 就是非常流行的一种，在前端开发中用的比较多的 Jest 就是一种，在 Golang 开发命令行工具的时候也是需要 DI 这种模式来实现命令行测试的。因为传统的测试室获取不到命令行的输入输出的。 ","date":"2019-09-10","objectID":"/2019/09/golang-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5dependency-injection.zh/:0:0","tags":["golang","Dependency Injection","DI","test","TDD","Fprintf","io.Writer"],"title":"Golang 依赖注入 (Dependency Injection)","uri":"/2019/09/golang-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5dependency-injection.zh/"},{"categories":["Golang"],"content":"工程意图 仓库：https://github.com/guzhongren/TDD/tree/master/10.dependency-injection 编写一个命令行工具库，打包并运行程序，根据工具名称后面的名称来显示 'Hello, + 名称'。 ","date":"2019-09-10","objectID":"/2019/09/golang-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5dependency-injection.zh/:1:0","tags":["golang","Dependency Injection","DI","test","TDD","Fprintf","io.Writer"],"title":"Golang 依赖注入 (Dependency Injection)","uri":"/2019/09/golang-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5dependency-injection.zh/"},{"categories":["Golang"],"content":"简化程序 我们知道 golang 打包后就是一个可执行程序，程序名称根据你指定的名称显示，那么要实现这个工具就是需要接收到程序名后面的参数并显示出来。但本次的重点是实现 DI, 所以我们将重点放在命令行的测试与实现上。 我们只实现 Greet 函数的 DI 就可以了。 ","date":"2019-09-10","objectID":"/2019/09/golang-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5dependency-injection.zh/:2:0","tags":["golang","Dependency Injection","DI","test","TDD","Fprintf","io.Writer"],"title":"Golang 依赖注入 (Dependency Injection)","uri":"/2019/09/golang-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5dependency-injection.zh/"},{"categories":["Golang"],"content":"初始化工程 go mod init dependency-injection 按照惯例，测试的函数需要以 Test 开头，参数为 *testing.T 类型 ","date":"2019-09-10","objectID":"/2019/09/golang-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5dependency-injection.zh/:3:0","tags":["golang","Dependency Injection","DI","test","TDD","Fprintf","io.Writer"],"title":"Golang 依赖注入 (Dependency Injection)","uri":"/2019/09/golang-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5dependency-injection.zh/"},{"categories":["Golang"],"content":"Test 测试先行 func TestGreet(t *testing.T) { // 申明 buffer，准备接受数据， 因为 bytes.Buffer， 重点：bytes.Buffer 实现了 io.Writer buffer := bytes.Buffer{} // 将 buffer 传入，此时就是依赖注入的入口， Greet(\u0026buffer, \"chris\") // 获取程序运行的结果 got := buffer.String() // 期望值 want := \"Hello, chris\" // 测试判断 if got != want { t.Errorf(`got %s, want %s`, got, want) } } 运行 go test, 程序会报错，因为没有实现 Greet 函数。 最小化的实现 Repeat // Greet 打印问候 func Greet(w io.Writer, name string) { fmt.Fprintf(w, \"Hello, \"+name) } 重点说明，命令行的测试需要将结果打印在命令行窗口中，如果没有测试，我们可以用 fmt.Printf 等打印函数将结果打印出来，但是， 测试需要拿到打印的内容，就需要将内容用标准输出；当然可以变相的先用其他打印函数将结果打印出来，然后再将结果 return 出去， 在测试中，接受返回值，再比较；这样做不标准而已，学了今天内容其实就可以用 DI 来解决了。 ","date":"2019-09-10","objectID":"/2019/09/golang-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5dependency-injection.zh/:4:0","tags":["golang","Dependency Injection","DI","test","TDD","Fprintf","io.Writer"],"title":"Golang 依赖注入 (Dependency Injection)","uri":"/2019/09/golang-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5dependency-injection.zh/"},{"categories":["Golang"],"content":"运行测试 基本测试 $ go test PASS ok dependency-injection 0.006s ","date":"2019-09-10","objectID":"/2019/09/golang-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5dependency-injection.zh/:5:0","tags":["golang","Dependency Injection","DI","test","TDD","Fprintf","io.Writer"],"title":"Golang 依赖注入 (Dependency Injection)","uri":"/2019/09/golang-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5dependency-injection.zh/"},{"categories":["Golang"],"content":"总结 基本测试很简单，不用解读了。作为开发者，我们应该用最直接的工具来保证我们程序的健壮性，而不一定要绕个弯来解决问题，如上面的打印结果的测试。 ","date":"2019-09-10","objectID":"/2019/09/golang-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5dependency-injection.zh/:6:0","tags":["golang","Dependency Injection","DI","test","TDD","Fprintf","io.Writer"],"title":"Golang 依赖注入 (Dependency Injection)","uri":"/2019/09/golang-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5dependency-injection.zh/"},{"categories":["Golang"],"content":"Refs 1.https://golang.google.cn/ ","date":"2019-09-10","objectID":"/2019/09/golang-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5dependency-injection.zh/:7:0","tags":["golang","Dependency Injection","DI","test","TDD","Fprintf","io.Writer"],"title":"Golang 依赖注入 (Dependency Injection)","uri":"/2019/09/golang-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5dependency-injection.zh/"},{"categories":["Golang"],"content":"Benchmark 🧪 基准测试是对计算机系统的性能的测试。 在程序中，基准测试，是一种测试代码性能的方法；比如有一个问题你有多种不同的方案，你想选择一种性能最好的方案，那么你就需要基准测试。 基准测试主要是通过测试 CPU 和内存的效率问题，来评估被测试代码的性能，进而找到更好的解决方案。比如链接池的数量不是越多越好，那么哪个值才是最优值呢，这就需要配合基准测试不断调优了。 ","date":"2019-09-10","objectID":"/2019/09/golang-%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95benchmark.zh/:0:0","tags":["go","Benchmark","golang","test","testing","单元测试","基准测试","TDD"],"title":"Golang 基准测试 (Benchmark)","uri":"/2019/09/golang-%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95benchmark.zh/"},{"categories":["Golang"],"content":"工程意图 仓库： https://github.com/guzhongren/TDD/tree/master/09.benchmar 根据输入的字符串和重复次数，输出重复次数后的字符串。 ","date":"2019-09-10","objectID":"/2019/09/golang-%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95benchmark.zh/:1:0","tags":["go","Benchmark","golang","test","testing","单元测试","基准测试","TDD"],"title":"Golang 基准测试 (Benchmark)","uri":"/2019/09/golang-%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95benchmark.zh/"},{"categories":["Golang"],"content":"初始化工程 go mod init benchmark 测试的函数需要以 Test 开头，参数为 *testing.T 类型 ","date":"2019-09-10","objectID":"/2019/09/golang-%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95benchmark.zh/:2:0","tags":["go","Benchmark","golang","test","testing","单元测试","基准测试","TDD"],"title":"Golang 基准测试 (Benchmark)","uri":"/2019/09/golang-%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95benchmark.zh/"},{"categories":["Golang"],"content":"Test 测试先行 # 测试 Repeat 函数 func TestRepeat(t *testing.T) { actual := Repeat(`a`, 6) expect := `aaaaaa` if actual != expect { t.Errorf(`expect %s, but got %s`, expect, actual) } } 运行 go test, 程序会报错，因为没有实现 Repeat 函数。 最小化的实现 Repeat // Repeat return a string with same char func Repeat(char string, count int) (result string) { for i := 0; i \u003c count; i++ { result += char } return } 上面的函数中 return 并没有返回值，是因为，在 Repeat 函数的返回值部分有一个 result， 当返回值是函数体里面的值的时候，可以不用写返回值，go 程序自动将该值返回。但 return 依旧不能省略。 ","date":"2019-09-10","objectID":"/2019/09/golang-%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95benchmark.zh/:3:0","tags":["go","Benchmark","golang","test","testing","单元测试","基准测试","TDD"],"title":"Golang 基准测试 (Benchmark)","uri":"/2019/09/golang-%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95benchmark.zh/"},{"categories":["Golang"],"content":"Benchmark 基准测试的函数名须以 Benchmark 开头， 参数须为 *testing.B；循环中的 b.N， go 会根据系统情况生成，不用用户设定。 func BenchmarkRepeat(b *testing.B) { for i := 0; i \u003c b.N; i++ { Repeat(`b`, 5) } } ","date":"2019-09-10","objectID":"/2019/09/golang-%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95benchmark.zh/:4:0","tags":["go","Benchmark","golang","test","testing","单元测试","基准测试","TDD"],"title":"Golang 基准测试 (Benchmark)","uri":"/2019/09/golang-%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95benchmark.zh/"},{"categories":["Golang"],"content":"运行测试 基本测试 $ go test PASS ok benchmark 0.006s 基本测试很简单，不用解读了。 基准测试 $ go test -bench=. -run=none goos: darwin goarch: amd64 pkg: benchmark BenchmarkRepeat-12 10000000 116 ns/op PASS ok benchmark 1.297s 运行基准测试也要使用 go test 命令，不过我们要加上-bench=标记，它接受一个表达式作为参数，匹配基准测试的函数，. 表示运行所有基准测试。 因为默认情况下 go test 会运行单元测试，为了防止单元测试的输出影响我们查看基准测试的结果，可以使用-run=匹配一个从来没有的单元测试方法，过滤掉单元测试的输出，我们这里使用 none，因为我们基本上不会创建这个名字的单元测试方法。 下面着重解释下说出的结果，看到函数后面的-12 了吗？这个表示运行时对应的 GOMAXPROCS 的值。接着的 10000000 表示运行 for 循环的次数，也就是调用被测试代码的次数，最后的 116 ns/op 表示每次需要话费 116 纳秒。 以上是测试时间默认是 1 秒，也就是 1 秒的时间，调用 10000000 次，每次调用花费 116 纳秒。如果想让测试运行的时间更长，可以通过 -lunchtime 指定，比如 5 秒。 ","date":"2019-09-10","objectID":"/2019/09/golang-%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95benchmark.zh/:5:0","tags":["go","Benchmark","golang","test","testing","单元测试","基准测试","TDD"],"title":"Golang 基准测试 (Benchmark)","uri":"/2019/09/golang-%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95benchmark.zh/"},{"categories":["Golang"],"content":"Refs ","date":"2019-09-10","objectID":"/2019/09/golang-%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95benchmark.zh/:6:0","tags":["go","Benchmark","golang","test","testing","单元测试","基准测试","TDD"],"title":"Golang 基准测试 (Benchmark)","uri":"/2019/09/golang-%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95benchmark.zh/"},{"categories":["Golang"],"content":"1.https://golang.google.cn/ 2.Golang 依赖注入 (Dependency Injection) ","date":"2019-09-10","objectID":"/2019/09/golang-%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95benchmark.zh/:7:0","tags":["go","Benchmark","golang","test","testing","单元测试","基准测试","TDD"],"title":"Golang 基准测试 (Benchmark)","uri":"/2019/09/golang-%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95benchmark.zh/"},{"categories":["Golang"],"content":" 简介 目标 目的 Coding 目录结构 封装 error 函数 安装 SQLLite 库及其他库 申明 DB 全局变量 初始化数据库 用户模型构建及原子操作 用户模型 新增 删除 修改 查询 在应用中启动并调用用户模型的方法 运行结果展示 总结 Reference Disclaimer ","date":"2019-09-01","objectID":"/2019/09/golang-with-sqllite-practice.zh/:0:0","tags":["Golang","go","SQLLite"],"title":"Golang With SQLLite Practice","uri":"/2019/09/golang-with-sqllite-practice.zh/"},{"categories":["Golang"],"content":"简介 SQLite 是一个进程内的库，实现了自给自足的、无服务器的、零配置的、事务性的 SQL 数据库引擎。它是一个零配置的数据库，这意味着与其他数据库一样，你不需要在系统中配置。在 Golang 中使用 SQLLite 也相当简单，只需要安装 SQLLite 的 Golang 包即可使用； Golang 就不多介绍了，能看到这个肯定对 Golang 有一定的了解。 仓库地址：https://github.com/AndorLab/golang-sqllite ","date":"2019-09-01","objectID":"/2019/09/golang-with-sqllite-practice.zh/:1:0","tags":["Golang","go","SQLLite"],"title":"Golang With SQLLite Practice","uri":"/2019/09/golang-with-sqllite-practice.zh/"},{"categories":["Golang"],"content":"目标 使用 SQLLite 通过构建一个社区用户表，包含如下字段；通过 SQLLite 的 API 实现对社区用户表进行增删改查。 序号 字段 类型 说明 1 uid int64 id 2 username string 用户名 3 city string 城市 4 skills string 技能 5 created int64 创建时间 ","date":"2019-09-01","objectID":"/2019/09/golang-with-sqllite-practice.zh/:2:0","tags":["Golang","go","SQLLite"],"title":"Golang With SQLLite Practice","uri":"/2019/09/golang-with-sqllite-practice.zh/"},{"categories":["Golang"],"content":"目的 了解 SQLLite ，学习 Golang 操作 SQLLite, 巩固 Golang 基础知识。 ","date":"2019-09-01","objectID":"/2019/09/golang-with-sqllite-practice.zh/:3:0","tags":["Golang","go","SQLLite"],"title":"Golang With SQLLite Practice","uri":"/2019/09/golang-with-sqllite-practice.zh/"},{"categories":["Golang"],"content":"Coding ","date":"2019-09-01","objectID":"/2019/09/golang-with-sqllite-practice.zh/:4:0","tags":["Golang","go","SQLLite"],"title":"Golang With SQLLite Practice","uri":"/2019/09/golang-with-sqllite-practice.zh/"},{"categories":["Golang"],"content":"目录结构 项目采用 Golang 传统的平铺式目录 . ├── LICENSE ├── Makefile # 构建工具 ├── README.md # README ├── db.go # 数据库操作 ├── error.go # 错误处理工具方法 ├── fcc.db # sqllite 数据库 ├── go.mod # go modules ├── go.sum # go modules ├── main.go # 项目入口 ├── server.go # 应用程序入口 └── userModel.go # 用户模型 ","date":"2019-09-01","objectID":"/2019/09/golang-with-sqllite-practice.zh/:4:1","tags":["Golang","go","SQLLite"],"title":"Golang With SQLLite Practice","uri":"/2019/09/golang-with-sqllite-practice.zh/"},{"categories":["Golang"],"content":"封装 error 函数 因为在 go 中会有很多的 error 的判断，为了代码精简，我们特封装一下 error; 下面的 interface{} 代表任何类型，类似 TypeScript 中的 any。 # error.go func checkErr(data interface{}, err error) (interface{}, error) { if err != nil { log.Error(err) return nil, err } return data, err } ","date":"2019-09-01","objectID":"/2019/09/golang-with-sqllite-practice.zh/:4:2","tags":["Golang","go","SQLLite"],"title":"Golang With SQLLite Practice","uri":"/2019/09/golang-with-sqllite-practice.zh/"},{"categories":["Golang"],"content":"安装 SQLLite 库及其他库 使用 go modules 之后，将所需的包放在 import 中，使用 go mod tidy 命令后，go 会自动安装程序使用到的包。 日志相关的库，主要用于在控制台打印结果 # server.go import ( \"github.com/labstack/gommon/log\" ) SQLLite 包 # db.go _ \"github.com/mattn/go-sqlite3\" ","date":"2019-09-01","objectID":"/2019/09/golang-with-sqllite-practice.zh/:4:3","tags":["Golang","go","SQLLite"],"title":"Golang With SQLLite Practice","uri":"/2019/09/golang-with-sqllite-practice.zh/"},{"categories":["Golang"],"content":"申明 DB 全局变量 因为在程序中，我们要通过数据库来获取数据，那么存在一个全局的数据库指针是很有必要的。 # main.go var db = new(sql.DB) ","date":"2019-09-01","objectID":"/2019/09/golang-with-sqllite-practice.zh/:4:4","tags":["Golang","go","SQLLite"],"title":"Golang With SQLLite Practice","uri":"/2019/09/golang-with-sqllite-practice.zh/"},{"categories":["Golang"],"content":"初始化数据库 SQLLite 初始化数据库非常简单，只要指定数据库驱动和数据库文件就可以。为了在程序的整个生命周期中操作数据库，我们将 db 返回。 // openDB 打开数据库 func openDB() *sql.DB { //打开数据库，如果不存在，则创建 db, err := sql.Open(\"sqlite3\", \"./fcc.db\") checkErr(db, err) return db } 创建好 db 后，需要创建表结构，执行如下数据库操作命令即可完成用户表的创建。 // initDB 初始化数据库 func initDB() { //创建表 sqlTable := ` CREATE TABLE IF NOT EXISTS userinfo( uid INTEGER PRIMARY KEY AUTOINCREMENT, username VARCHAR(64) NULL, city VARCHAR(64) NULL, skills VARCHAR(128) NULL, created BIGINT NULL ); ` db.Exec(sqlTable) } ","date":"2019-09-01","objectID":"/2019/09/golang-with-sqllite-practice.zh/:4:5","tags":["Golang","go","SQLLite"],"title":"Golang With SQLLite Practice","uri":"/2019/09/golang-with-sqllite-practice.zh/"},{"categories":["Golang"],"content":"用户模型构建及原子操作 构建现代程序，强调程序的健壮性，封装就是比较重要的；用 MVC、 MVVM 的观点，我们需要有一个 Model 来提供对象的原子操作。在这，我们将用户抽象为 UserModel，对用户的增删改查封装到 insert、dleete、update 和 query。 用户模型 // UserModel 用户模型 type UserModel struct { uid int64 username string city string skills string created int64 } 对用户的原子操作 新增 // insert 新增 func (u UserModel) insert() (sql.Result, error) { stmt, err := db.Prepare(\"insert into userinfo(username, city, skills, created) values(?,?,?,?)\") checkErr(stmt, err) res, err := stmt.Exec(u.username, u.city, u.skills, time.Now().Unix()) checkErr(res, err) return res, nil } 删除 // delete 删除 func (u UserModel) delete(id int64) int64 { stmt, err := db.Prepare(\"delete from userinfo where uid=?\") checkErr(stmt, err) res, err := stmt.Exec(id) checkErr(res, err) affect, err := res.RowsAffected() checkErr(affect, err) return affect } 修改 // update 更新用户技能 func (u UserModel) update(id int) int64 { stmt, err := db.Prepare(\"update userinfo set skills=? where uid=?\") checkErr(stmt, err) res, err := stmt.Exec(u.skills, id) checkErr(res, err) affect, err := res.RowsAffected() checkErr(affect, err) return affect } 查询 // query 查询 func (u UserModel) query() ([]UserModel, error) { rows, err := db.Query(\"select * from userinfo\") checkErr(rows, err) var userList = []UserModel{} for rows.Next() { var user = UserModel{} err = rows.Scan(\u0026user.uid, \u0026user.username, \u0026user.city, \u0026user.skills, \u0026user.created) checkErr(nil, err) userList = append(userList, user) } rows.Close() return userList, nil } ","date":"2019-09-01","objectID":"/2019/09/golang-with-sqllite-practice.zh/:4:6","tags":["Golang","go","SQLLite"],"title":"Golang With SQLLite Practice","uri":"/2019/09/golang-with-sqllite-practice.zh/"},{"categories":["Golang"],"content":"在应用中启动并调用用户模型的方法 在上面我们完成了对用户模型及原子操作的封装，那么接下来就是通过应用程序将分装的内容调用，传入正确的参数进行调用。 我们在此封装一个 startAPP 方法，在这个里面我们调用封装好的用户操作的接口，实现功能。 因为数据库要在整个生命周期存在，当程序结束的时候，我们应该将数据库链接释放，所以我们用到了 go 的 defer 关键字 # server.go db = openDB() defer db.Close() initDB() 调用用户操作的增删改查并打印结果，对于不同的操作，我们应该有不同的数据，所以在程序中会有 user、和 updateUser 两个对象 # server.go user := UserModel{ username: \"谷中仁\", city: `西安`, skills: `TypeScript`, } // insert result, err := user.insert() id, err := result.LastInsertId() checkErr(id, err) log.Info(\"增：操作数据的 id:\", id) // update updateUser := UserModel{ skills: `golang`, } affectedRow := updateUser.updateSkills(1) log.Info(\"改：影响的行数：\", affectedRow) // query queryUser := UserModel{} list, _ := queryUser.query() log.Info(\"查：\", list) // delete affect := queryUser.delete(1) log.Info(\"删：\", affect) // query list, _ = queryUser.query() log.Info(\"查：\", list) ","date":"2019-09-01","objectID":"/2019/09/golang-with-sqllite-practice.zh/:4:7","tags":["Golang","go","SQLLite"],"title":"Golang With SQLLite Practice","uri":"/2019/09/golang-with-sqllite-practice.zh/"},{"categories":["Golang"],"content":"运行结果展示 $ make run go run *.go {\"time\":\"2019-08-31T14:21:48.941164+08:00\",\"level\":\"INFO\",\"prefix\":\"-\",\"file\":\"server.go\",\"line\":\"21\",\"message\":\"增：操作数据的 id:1\"} {\"time\":\"2019-08-31T14:21:48.941842+08:00\",\"level\":\"INFO\",\"prefix\":\"-\",\"file\":\"server.go\",\"line\":\"27\",\"message\":\"改：影响的行数：1\"} {\"time\":\"2019-08-31T14:21:48.942034+08:00\",\"level\":\"INFO\",\"prefix\":\"-\",\"file\":\"server.go\",\"line\":\"31\",\"message\":\"查：[{1 谷中仁 西安 golang 1567232508}]\"} {\"time\":\"2019-08-31T14:21:48.942599+08:00\",\"level\":\"INFO\",\"prefix\":\"-\",\"file\":\"server.go\",\"line\":\"34\",\"message\":\"删：1\"} {\"time\":\"2019-08-31T14:21:48.942696+08:00\",\"level\":\"INFO\",\"prefix\":\"-\",\"file\":\"server.go\",\"line\":\"38\",\"message\":\"查：[]\"} ","date":"2019-09-01","objectID":"/2019/09/golang-with-sqllite-practice.zh/:4:8","tags":["Golang","go","SQLLite"],"title":"Golang With SQLLite Practice","uri":"/2019/09/golang-with-sqllite-practice.zh/"},{"categories":["Golang"],"content":"总结 SQLLite 对开发者非常友好，不用安装在机器上，只要指定 SQLLite 的驱动和数据库存储文件即可对 SQLLite 数据库进行操作；Golang 作为比较流行的语言，对数据库也非常友好，提供了基本的数据库接口， 至于用户需要什么样的数据库，自己开发对应的数据库驱动即可。当然在 GitHub 已经有很多开源爱好者开发了比较流行的数据库的驱动可以直接拿来用。 SQLLite 使用的也是标准的 SQL 语法，可以让不同的开发者快速入手。 为什么没有用到 Golang 的 Web 框架？ 因为我们的侧重点在 Golang 与 SQLLite，不在 API 实现上，最小化的实现目标，才是我们学习知识最快速的途径。 原文链接：https://chinese.freecodecamp.org/news/golang-with-sqllite-practice/ ","date":"2019-09-01","objectID":"/2019/09/golang-with-sqllite-practice.zh/:5:0","tags":["Golang","go","SQLLite"],"title":"Golang With SQLLite Practice","uri":"/2019/09/golang-with-sqllite-practice.zh/"},{"categories":["Golang"],"content":"Refs 1. 博客：https://guzhongren.github.io/* 2. 原文：https://yq.aliyun.com/articles/716696?spm=a2c4e.11155435.0.0.5d7c3312dFgns3 ","date":"2019-09-01","objectID":"/2019/09/golang-with-sqllite-practice.zh/:6:0","tags":["Golang","go","SQLLite"],"title":"Golang With SQLLite Practice","uri":"/2019/09/golang-with-sqllite-practice.zh/"},{"categories":["Golang"],"content":"Disclaimer 本文仅代表个人观点，与 Thoughtworks 公司无任何关系。 ","date":"2019-09-01","objectID":"/2019/09/golang-with-sqllite-practice.zh/:7:0","tags":["Golang","go","SQLLite"],"title":"Golang With SQLLite Practice","uri":"/2019/09/golang-with-sqllite-practice.zh/"},{"categories":["基础知识"],"content":"这是一篇用于预览 Markdown 基本语法的文章。","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"这是一篇用于预览  Markdown 基本语法的文章。 文章内容基于 GitHub Flavored Markdown Spec。 不包含复杂的规则说明，仅仅展示 GFM 所约定的 Markdown 基本语法。 ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:0:0","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"1 引言  Markdown 是一种用于编写结构化文档的纯文本格式。它基于电子邮件和论坛文章的格式所约定。 它由 John Gruber （在 Aaron Swartz 的帮助下）开发，于 2004 年以语法描述和用于将 Markdown 转换为 HTML 的 Perl 脚本 (Markdown.pl) 的形式发布。 在接下来的十年中，许多实现被开发出来。一些用脚注、表和其他文档元素的约定扩展了原始 Markdown 语法。 有些允许 Markdown 文档以 HTML 以外的格式呈现。 像 reddit，StackOverflow 和 GitHub 这样的网站有上百万的用户在使用 Markdown。 Markdown 开始被应用于网络以外的领域，包括作者书籍、文章、幻灯片、信件和课堂笔记。 ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:1:0","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"2 块和内联元素 我们可以把一个文档看成一系列的块，如段落、引用、列表、标题和代码块。 有些块（如引号和列表）可以包含其它的块，即 容器块； 其他的块（如标题和段落）则包含内联元素（如文本、链接、强调、图像、内联代码等），即 叶子块。 块的符号总是优先于内联元素的符号。例如： - `one - two` `one two` ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:2:0","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"3 叶子块 本节描述用于组成 Markdown 文档的不同类型的叶子块。 ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:3:0","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"3.1 换行符 *** ------ ____ ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:3:1","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"3.2 标题 关于 ATX 风格标题和 Setext 风格标题 本文只展示 ATX 风格标题，关于 Setext 风格标题的介绍请参考 GFM Setext headings 说明。 笔者不推荐在 Hugo 的 Markdown 文档中使用 Setext 风格标题。 ## H2 二级标题 ### H3 三级标题 #### H4 四级标题 ##### H5 五级标题 ###### H6 六级标题 ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:3:2","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"H2 二级标题 ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:4:0","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"H3 三级标题 H4 四级标题 H5 五级标题 H6 六级标题 ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:4:1","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"3.3 代码块 关于缩进式代码块和围栏式代码块 本文只展示围栏式代码块，关于缩进式代码块的介绍请参考 GFM Indented code blocks 说明。 笔者不推荐在 Hugo 的 Markdown 文档中使用缩进式代码块。 ``` foo() ``` ~~~ foo() ~~~ ```` foo() ```` ```ruby def foo(x) return 3 end ``` foo() foo() foo() def foo(x) return 3 end package main import \"fmt\" func main() { fmt.Println(\"Hello, 世界\") } ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:4:2","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"3.4 段落 这是一个段落。 这还是之前段落的一部分。 这是新的段落。 这是一个段落。 这还是之前段落的一部分。 这是新的段落。 ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:4:3","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"3.5 引用链接的定义 [foo]: / \"title\" [foo] [bar]: / [bar] foo bar ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:4:4","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"3.6 空白行 块之间的空白行将被忽略，除了它们在确定列表是紧还是松时所起的作用。 文档开头和结尾的空行也会被忽略。 ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:4:5","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"4 容器块 ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:5:0","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"4.1 引用 \u003e Foo \u003e \u003e - **bar** \u003e - baz Foo bar baz ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:5:1","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"4.2 无序列表 - 项目 1 * 项目 A - 项目 B 一些说明 + 项目 a * 项目 b - 项目 c + 项目 C + 项目 2 * 项目 3 项目 1 项目 A 项目 B 一些说明 项目 a 项目 b 项目 c 项目 C 项目 2 项目 3 ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:5:2","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"4.3 有序列表 1. 项目 1 1. 项目 A 2. 项目 B 一些说明 1. 项目 a 2. 项目 b 3. 项目 c 3. 项目 C 2. 项目 2 3. 项目 3 项目 1 项目 A 项目 B 一些说明 项目 a 项目 b 项目 c 项目 C 项目 2 项目 3 ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:5:3","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"4.4 任务列表 - [ ] 任务 1 * [X] 任务 A - 任务 B + [ ] 任务 a * [ ] 任务 b - [X] 任务 c + [X] 任务 C + [ ] 任务 2 * [X] 任务 3 任务 1 任务 A 任务 B 任务 a 任务 b 任务 c 任务 C 任务 2 任务 3 ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:5:4","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"4.5 表格 | _颜色_ | 水果 | 蔬菜 | | ---------- |:---------------:| -----------:| | 红色 | *苹果* | 辣椒 | | ~~橙色~~ | 橘子 | **胡萝卜** | | 绿色 | ~~***梨子***~~ | 菠菜 | 颜色 水果 蔬菜 红色 苹果 辣椒 橙色 橘子 胡萝卜 绿色 梨子 菠菜 ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:5:5","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"3. 页内锚 [脚注](#footnote) ## 4. 脚注 {#footnote} 脚注 ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:6:0","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"4. 脚注 这是一个基本的数字脚注 [^1] 带有 \"label\" 标签的脚注 [^label] 下定义的脚注 [^!DEF] 带有链接的脚注 [^pa] [^1]: 这是一个基本的数字脚注 [^label]: 带有 \"label\" 标签的脚注 [^pa]: [LoveIt 主题](https://github.com/dillonzq/LoveIt) [^!DEF]: 下定义的脚注 这是一个基本的数字脚注 1 带有 “label” 标签的脚注 2 下定义的脚注 3 带有链接的脚注 4 ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:7:0","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"5. 内联格式 `内联代码块` \u003ckbd\u003ectrl\u003c/kbd\u003e+\u003ckbd\u003ealt\u003c/kbd\u003e+\u003ckbd\u003edel\u003c/kbd\u003e **加粗 1** 和 __加粗 2__ *倾斜 1* 和 _倾斜 2_ ~~删除线~~ ***加粗 1 和 倾斜 1*** ___加粗 2 和 倾斜 2___ __*加粗 2 和 倾斜 1*__ **_加粗 1 和 倾斜 2_** ~~*删除线 倾斜 1*~~ 和 *~~删除线 倾斜 2~~* ~~_删除线 倾斜 2_~~ 和 _~~删除线 倾斜 2~~_ ~~**删除线 加粗 1**~~ 和 **~~删除线 加粗 1~~** ~~__删除线 加粗 2__~~ 和 __~~删除线 加粗 2~~__ ~~***删除线 倾斜 1 加粗 1***~~ 和 ***~~删除线 倾斜 1 加粗 1~~*** ~~___删除线 倾斜 2 加粗 2___~~ 和 ___~~删除线 倾斜 2 加粗 2~~___ **~~*删除线 倾斜 1 加粗 1*~~** 和 *~~**删除线 倾斜 1 加粗 1**~~* __~~_删除线 倾斜 2 加粗 2_~~__ 和 _~~__删除线 倾斜 2 加粗 2__~~_ **~~_删除线 倾斜 2 加粗 1_~~** 和 _~~**删除线 倾斜 2 加粗 1**~~_ __~~*删除线 倾斜 1 加粗 2*~~__ 和 *~~__删除线 倾斜 1 加粗 2__~~* 内联代码块 ctrl+alt+del 加粗 1 和 加粗 2 倾斜 1 和 倾斜 2 删除线 加粗 1 和 倾斜 1 加粗 2 和 倾斜 2 加粗 2 和 倾斜 1 加粗 1 和 倾斜 2 删除线 倾斜 1 和 删除线 倾斜 2 删除线 倾斜 2 和 删除线 倾斜 2 删除线 加粗 1 和 删除线 加粗 1 删除线 加粗 2 和 删除线 加粗 2 删除线 倾斜 1 加粗 1 和 删除线 倾斜 1 加粗 1 删除线 倾斜 2 加粗 2 和 删除线 倾斜 2 加粗 2 删除线 倾斜 1 加粗 1 和 删除线 倾斜 1 加粗 1 删除线 倾斜 2 加粗 2 和 删除线 倾斜 2 加粗 2 删除线 倾斜 2 加粗 1 和 删除线 倾斜 2 加粗 1 删除线 倾斜 1 加粗 2 和 删除线 倾斜 1 加粗 2 ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:8:0","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"6. 图片 Web image ![Web Picture](https://static.dillonzq.com/images/20190817130904-U6cPUk.jpg \"Web Picture\") Local image ![Local Picture](/images/Apple-Devices-Preview.png) contact@revolunet.com @revolunet Issue #1 https://github.com/revolunet/sublimetext-markdown-preview/ This is a link https://github.com/revolunet/sublimetext-markdown-preview/. This is a link \"https://github.com/revolunet/sublimetext-markdown-preview/\". With this link (https://github.com/revolunet/sublimetext-markdown-preview/), it still works. Web image Web PictureWeb Picture \" Web Picture Local image https://www.google.com contact@revolunet.com @revolunet Issue #1 https://github.com/revolunet/sublimetext-markdown-preview/ This is a link https://github.com/revolunet/sublimetext-markdown-preview/. This is a link “https://github.com/revolunet/sublimetext-markdown-preview/\". With this link (https://github.com/revolunet/sublimetext-markdown-preview/), it still works. ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:9:0","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"Abbreviation Abbreviations source are found in a separate markdown file specified in frontmatter. The HTML specification is maintained by the W3C. *[HTML]: Hyper Text Markup Language *[W3C]: World Wide Web Consortium The HTML specification is maintained by the W3C. ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:10:0","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"Unordered List Unordered List - item 1 * item A * item B more text + item a + item b + item c * item C - item 2 - item 3 Unordered List item 1 item A item B more text item a item b item c item C item 2 item 3 ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:11:0","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"Ordered List Ordered List 1. item 1 1. item A 2. item B more text 1. item a 2. item b 3. item c 3. item C 2. item 2 3. item 3 Ordered List item 1 item A item B more text item a item b item c item C item 2 item 3 ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:12:0","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"Mixed Lists Really Mixed Lists should break with sane_lists on. Mixed Lists - item 1 * [X] item A * [ ] item B more text 1. item a 2. itemb 3. item c * [X] item C - item 2 - item 3 Really Mixed Lists - item 1 * [X] item A - item B more text 1. item a + itemb + [ ] item c 3. item C 2. item 2 - [X] item 3 Mixed Lists item 1 item A item B more text item a itemb item c item C item 2 item 3 Really Mixed Lists item 1 item A item B more text item a itemb item c item C item 2 item 3 ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:13:0","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"Blocks This is a block. This is more of a block. This is a block. This is more of a block. ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:14:0","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"Block Quotes \u003e This is a block quote \u003e\u003e How does it look? This is a block quote. How does it look? I think it looks good. ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:15:0","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"Fenced Block Assuming guessing is not enabled. ``` // Fenced **without** highlighting function doIt() { for (var i = 1; i \u003c= slen ; i^^) { setTimeout(\"document.z.textdisplay.value = newMake()\", i*300); setTimeout(\"window.status = newMake()\", i*300); } } ``` ```javascript // Fenced **with** highlighting function doIt() { for (var i = 1; i \u003c= slen ; i^^) { setTimeout(\"document.z.textdisplay.value = newMake()\", i*300); setTimeout(\"window.status = newMake()\", i*300); } } ``` // Fenced **without** highlighting function doIt() { for (var i = 1; i \u003c= slen ; i^^) { setTimeout(\"document.z.textdisplay.value = newMake()\", i*300); setTimeout(\"window.status = newMake()\", i*300); } } // Fenced **with** highlighting function doIt() { for (var i = 1; i \u003c= slen ; i^^) { setTimeout(\"document.z.textdisplay.value = newMake()\", i*300); setTimeout(\"window.status = newMake()\", i*300); } } ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:16:0","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"Tables | _颜色_ | 水果 | 蔬菜 | | ------------- |:---------------:| -----------------:| | red | *苹果* | [辣椒](#) | | ~~橙色~~ | 橘子 | **胡萝卜** | | 绿色 | ~~***梨子***~~ | 菠菜 | 颜色 水果 蔬菜 red 苹果 辣椒 橙色 橘子 胡萝卜 绿色 梨子 菠菜 Class or Enum Year Month Day Hours Minutes Seconds* Zone Offset Zone ID toString Output Where Discussed Instant 2013-08-20T15:16:26.355Z Instant Class LocalDate 2013-08-20 Date Classes LocalDateTime 2013-08-20T08:16:26.937 Date and Time Classes ZonedDateTime 2013-08-21T00:16:26.941+09:00[Asia/Tokyo] Time Zone and Offset Classes LocalTime 08:16:26.943 Date and Time Classes MonthDay --08-20 Date Classes Year 2013 Date Classes YearMonth 2013-08 Date Classes Month AUGUST DayOfWeek and Month Enums OffsetDateTime 2013-08-20T08:16:26.954-07:00 Time Zone and Offset Classes OffsetTime 08:16:26.957-07:00 Time Zone and Offset Classes Duration ** ** ** PT20H (20 hours) Period and Duration Period *** *** P10D (10 days) Period and Duration ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:17:0","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"Smart Strong Text with double__underscore__words. __Strong__ still works. __this__works__too__ Text with double__underscore__words. Strong still works. this__works__too ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:18:0","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"Smarty \"double quotes\" 'single quotes' da--sh elipsis... “double quotes” ‘single quotes’ da–sh elipsis… ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:19:0","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"Neseted Fences ``` This will still be parsed as a normal indented code block. ``` ``` This will still be parsed as a fenced code block. ``` - This is a list that contains multiple code blocks. - Here is an indented block ``` This will still be parsed as a normal indented code block. ``` - Here is a fenced code block: ``` This will still be parsed as a fenced code block. ``` \u003e ``` \u003e Blockquotes? \u003e Not a problem! \u003e ``` ``` This will still be parsed as a normal indented code block. ``` This will still be parsed as a fenced code block. This is a list that contains multiple code blocks. Here is an indented block ``` This will still be parsed as a normal indented code block. ``` Here is a fenced code block: This will still be parsed as a fenced code block. Blockquotes? Not a problem! ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:20:0","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"Github Emoji This is a test for emoji 😄. The emojis are images linked to github assets :octocat:. This is a test for emoji 😄. The emojis are images linked to github assets :octocat:. ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:21:0","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"People 👍👎👽👼💢😠😧😲👶💙😊💥🙇‍♂️:bowtie:👦👰💔👤👥👏😰💥😖😕👷‍♂️👮‍♂️👫💑💏😢😿💘💃👯‍♀️💨😞😥💫😵💧👂❗😑👀👊👨‍👩‍👦😨:feelsgood:🐾:finnadie:🔥✊😳😦🖕👧:goberserk::godmode:💚❕❔😬😁😀💂‍♂️💇‍♀️✋💩🙉❤️😍😻💓💗:hurtrealbad:😯👿💁‍♀️😇👺👹😂😹💋😗😽😚😘😙😆👄💌👨👲👳‍♂️😷💆‍♀️🤘💪🎵💅:neckbeard:😐🙅‍♀️😶👃🎶👌🙆‍♀️👴👵👐😮😔😣🙍‍♀️👱‍♂️🙎‍♀️👇👈👉☝️👆💩😾🙏👸👊💜❓😡:rage1::rage2::rage3::rage4:✋🙌🙋‍♀️☺️😌💞🏃‍♂️🏃😆😱🙀🙈💩💀😴😪😄😸😃😺😈😏😼😭✨💖🙊💬⭐🌟😛😝😜😎:suspect:😓💦😅💭👎👍😫👅😤:trollface:💕👬👭😒✌️🚶‍♂️👋😩😉👩😟💛😋💤 ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:21:1","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"Nature 🐜🐤🐻🐝🪲🐦🌼🐡🐗💐🐛🌵🐫🐱🐈🌸🌰🐔☁️🐮🐄🌙🐊🌀🌳🐶🐕🐬🐉🐲🐪🌾🌍🌎🌏🐘🌲🍂🌓🌛🐟🌁🍀🐸🌕🌝🌐🐐🐹🐥🐣🌿🌺🐝🐴🐨🌗🌜🍃🐆🍁🌌🐒🐵🌔🐭🐁🍄🌑🌚🌃🌊:octocat:🐙🐂🌴🐼⛅🐾🐧🐷🐖🐽🐩🐰🐇🐎🐏🐀🐓🌹🌱🐑🐚🐌🐍❄️☃️:squirrel:🌞🌻☀️🐯🐅🐠🌷🐢☂️🌋🌘🌖🐃🌒🌔🐳🐋🐺⚡ ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:21:2","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"Objects 🎱⏰🍎🎨👟🍼🎈🎍🍌📊⚾🏀🛀🛁🔋🍺🍻🔔🍱🚴‍♂️👙🎂🃏✒️📘💣📖🔖📑📚👢🎳🍞💼💡🍰📆📲📷🍬📇💿📉📈🍒🍫🎄🎬📋📕🔐🌂♣️🍸☕💻🎊🍪🌽💳👑🔮🍛🍮🍡🎯📅♦️💵🎎🚪🍩👗📀📧🥚🍆🔌✉️✉📩💶👓📠📁🎆🍥🎣🎏🔦🐬💾🎴🏈👣🍴🍤🍟🎲💎👻🎁💝⛳🍇🍏📗🎸🔫🍔🔨👜🎧♥️🔆👠🔪🍯🏇⌛⏳🍨🍦📥📨📱🎃👖🔑👘🏮📒🍋💄🔒🔏🍭➿🔊📢🔅🔍🔎🀄📫📪📬📭👞🍖📣🍈📝🎤🔬💽💸💰🎓🚵‍♂️🎥🎹🎼🔇📛👔📰🔕📓📔🔩🍢📖📂📙📤📦📄📃📟📎🍑🍐✏✏️☎️💊🍍🍕📯📮👝🍗💷👛📌📻🍜🎀🍚🍙🍘🎑💍🏉🎽🍶👡🎅🛰️🎷🎒✂️📜💺🍧👕👞🚿🎿🚬🏂⚽🔉👾♠️🍝❇️🎇🔈🍲📏🍓🏄‍♂️🍣🍠🏊‍♂️💉🎉🎋🍊🍵☎📞🔭🎾🚽🍅🎩📐🏆🍹🎺👕📺🔓📼📹🎮🎻⌚🍉🎐🍷👚👒🔧💴 ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:21:3","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"Places 🚡✈️🚑⚓🚛🏧🏦💈🔰🚲🚙⛵🌉🚅🚄🚌🚏🚗🎠🏁⛪🎪🌇🌆🇨🇳🚧🏪🎌🇩🇪🏬🇪🇸🏰🏤🏭🎡🚒⛲🇫🇷⛽🇬🇧🚁🏥🏨♨️🏠🏡🇮🇹🏮🗾🏯🇯🇵🇰🇷🚈🏩🚐🚝🗻🚠🚞🗿🏢🚘🚍🚔🚖🎭🚓🏣🚃🌈🚗🚀🎢🚨📍🚣‍♂️🇷🇺⛵🏫🚢🎰🚤🌠🚉🗽🚂🌅🌄🚟🚕⛺🎫🗼🚜🚥🚋🚆🚊🚩🚎🚚🇬🇧🇺🇸🚦⚠️💒 ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:21:4","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"Symbols 💯🔢🅰️🆎🔤🔡🉑♒♈◀️⏬⏫⬇️🔽▶️⤵️⤴️⬅️↙️↘️➡️↪️⬆️↕️🔼↖️↗️🔃🔄🅱️🚼🔙🛄☑️‼️⚫⬛◾◼️▪️🔲♋🔠♑💹🚸🎦🆑🕐🕙🕥🕚🕦🕛🕧🕜🕑🕝🕒🕞🕓🕟🕔🕠🕕🕡🕖🕢🕗🕣🕘🕤㊗️🆒©️➰💱🛃💠🚯8️⃣✴️✳️🔚⏩5️⃣4️⃣🆓♊#️⃣💟✔️➗💲❗➖✖️➕🆔🉐ℹ️⁉️🔟🈁🔵🔷🔶🛅↔️↩️♌♎🔗ⓜ️🚹🚇📴❎🆕🆖9️⃣🚳⛔🚫📵🚷🚭🚱⭕🅾️🆗🔛1️⃣⛎🅿️〽️🛂♓🚰🚮🔘♻️🔴®️🔁🔂🚻⏪🈂️♐♏㊙️7️⃣:shipit:📶6️⃣🔯🔹🔸🔺🔻🔜🆘🔣♉3️⃣™️🔝🔱🔀2️⃣🈹🈴🈺🈯🈷️🈶🈵🈚🈸🈲🈳🔞🆙📳♍🆚〰️🚾♿✅⚪💮⬜◽◻️▫️🔳🚺❌0️⃣ ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:21:5","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"Insert ^^insert^^ ^^*insert 倾斜*^^ *^^insert 倾斜 2^^* ^^_insert 倾斜_^^ _^^insert 倾斜 2^^_ ^^**insert 加粗**^^ **^^insert 加粗 2^^** ^^__insert 加粗__^^ __^^insert 加粗 2^^__ ^^***insert 倾斜 加粗***^^ ***^^insert 倾斜 加粗 2^^*** ^^___insert 倾斜 加粗___^^ ___^^insert 倾斜 加粗 2^^___ **^^*insert 倾斜 加粗*^^** *^^**insert 倾斜 加粗 2**^^* __^^_insert 倾斜 加粗_^^__ _^^__insert 倾斜 加粗 2__^^_ **^^_insert 倾斜 加粗_^^** _^^**insert 倾斜 加粗 2**^^_ __^^*insert 倾斜 加粗*^^__ *^^__insert 倾斜 加粗 2__^^* ^^insert^^ ^^insert 倾斜^^ ^^insert 倾斜 2^^ ^^insert 倾斜^^ ^^insert 倾斜 2^^ ^^insert 加粗^^ ^^insert 加粗 2^^ ^^insert 加粗^^ ^^insert 加粗 2^^ ^^insert 倾斜 加粗^^ ^^insert 倾斜 加粗 2^^ ^^insert 倾斜 加粗^^ ^^insert 倾斜 加粗 2^^ ^^insert 倾斜 加粗^^ ^^insert 倾斜 加粗 2^^ ^^insert 倾斜 加粗^^ ^^insert 倾斜 加粗 2^^ ^^insert 倾斜 加粗^^ ^^insert 倾斜 加粗 2^^ ^^insert 倾斜 加粗^^ ^^insert 倾斜 加粗 2^^ ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:22:0","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["基础知识"],"content":"Admonition Admonition note This is the content of the admonition. Admonition abstract This is the content of the admonition. Admonition info This is the content of the admonition. Admonition tip This is the content of the admonition. Admonition success This is the content of the admonition. Admonition question This is the content of the admonition. Admonition warning This is the content of the admonition. Admonition failure This is the content of the admonition. Admonition danger This is the content of the admonition. Admonition bug This is the content of the admonition. Admonition example This is the content of the admonition. Admonition quote This is the content of the admonition. Admonition This is the content of the admonition. 这是一个基本的数字脚注 ↩︎ 带有 “label” 标签的脚注 ↩︎ 下定义的脚注 ↩︎ LoveIt 主题 ↩︎ ","date":"2019-08-25","objectID":"/2019/08/basic-markdown-preview.zh/:23:0","tags":["Markdown","syntax"],"title":"Markdown 基本语法预览","uri":"/2019/08/basic-markdown-preview.zh/"},{"categories":["Kubernetes"],"content":"环境 hostname ip system master 192.168.33.10 CentOS7 node1 192.168.33.11 CentOS7 node2 192.168.33.12 CentOS7 node3 192.168.33.13 CentOS7 node4 192.168.33.14 CentOS7 node5 192.168.33.15 CentOS7 ","date":"2019-06-30","objectID":"/2019/06/k8s-1.15.0-%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95.zh/:1:0","tags":["kubernetes","install","cluster","nginx","service"],"title":"K8s 1.15.0 安装记录","uri":"/2019/06/k8s-1.15.0-%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95.zh/"},{"categories":["Kubernetes"],"content":"所有节点上操作 [root@master install]# cat preENV.sh #!/bin/bash # 关闭防火墙 systemctl stop firewalld \u0026\u0026 systemctl disable firewalld # 关闭 SELINUX setenforce 0 \u0026\u0026 sed -i \"s/SELINUX=enforcing/SELINUX=disabled/g\" /etc/selinux/config # 关闭 Swap swapoff -a \u0026\u0026 sed -i \"s/\\/dev\\/mapper\\/centos-swap/\\#\\/dev\\/mapper\\/centos-swap/g\" /etc/fstab [root@master ~]# vim /etc/sysctl.d/k8s.conf [root@master ~]# cat /etc/sysctl.d/k8s.conf net.bridge.bridge-nf-call-ip6tables = 1 net.bridge.bridge-nf-call-iptables = 1 net.ipv4.ip_forward = 1 [root@master ~]# modprobe br_netfilter \u0026\u0026 sysctl -p /etc/sysctl.d/k8s.conf net.bridge.bridge-nf-call-ip6tables = 1 net.bridge.bridge-nf-call-iptables = 1 net.ipv4.ip_forward = 1 [root@master ~]# wget -O /etc/yum.repos.d/CentOS7-Aliyun.repo http://mirrors.aliyun.com/repo/Centos-7.repo --2019-06-30 04:26:32-- http://mirrors.aliyun.com/repo/Centos-7.repo Resolving mirrors.aliyun.com (mirrors.aliyun.com)... 116.177.250.229, 116.177.250.233, 60.28.226.4, ... Connecting to mirrors.aliyun.com (mirrors.aliyun.com)|116.177.250.229|:80... connected. HTTP request sent, awaiting response... 200 OK Length: 2523 (2.5K) [application/octet-stream] Saving to: ‘/etc/yum.repos.d/CentOS7-Aliyun.repo’ 100%[============================================================================\u003e] 2,523 --.-K/s in 0s 2019-06-30 04:26:32 (296 MB/s) - ‘/etc/yum.repos.d/CentOS7-Aliyun.repo’ saved [2523/2523] root@master ~]# sudo yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2 [root@master ~]# sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo [root@master ~]# yum install docker-ce -y [root@master ~]# systemctl enable docker \u0026\u0026 systemctl start docker Created symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service. [root@master ~]# mkdir -p /etc/docker [root@master ~]# sudo tee /etc/docker/daemon.json \u003c\u003c-'EOF' { \"registry-mirrors\": [\"https://gmjjwogo.mirror.aliyuncs.com\"], \"exec-opts\": [\"native.cgroupdriver=systemd\"] } EOF { \"registry-mirrors\": [\"https://gmjjwogo.mirror.aliyuncs.com\"], \"exec-opts\": [\"native.cgroupdriver=systemd\"] } [root@master ~]# sudo systemctl daemon-reload \u0026\u0026 sudo systemctl restart docker [root@master ~]# docker info |grep Cgroup Cgroup Driver: systemd [root@master ~]# # kube-proxy 开启 ipvs 的前置条件 [root@master ~]# cat \u003e /etc/sysconfig/modules/ipvs.modules \u003c\u003cEOF #!/bin/bash modprobe -- ip_vs modprobe -- ip_vs_rr modprobe -- ip_vs_wrr modprobe -- ip_vs_sh modprobe -- nf_conntrack_ipv4 EOF [root@master ~]# chmod 755 /etc/sysconfig/modules/ipvs.modules \u0026\u0026 bash /etc/sysconfig/modules/ipvs.modules \u0026\u0026 lsmod | grep -e ip_vs -e nf_conntrack_ipv4 ip_vs_sh 12688 0 ip_vs_wrr 12697 0 ip_vs_rr 12600 0 ip_vs 145497 6 ip_vs_rr,ip_vs_sh,ip_vs_wrr nf_conntrack_ipv4 15053 2 nf_defrag_ipv4 12729 1 nf_conntrack_ipv4 nf_conntrack 133095 7 ip_vs,nf_nat,nf_nat_ipv4,xt_conntrack,nf_nat_masquerade_ipv4,nf_conntrack_netlink,nf_conntrack_ipv4 libcrc32c 12644 4 xfs,ip_vs,nf_nat,nf_conntrack [root@master ~]# # 安装 kubernetes 初始化工具 [root@master ~]# # 使用阿里云的 kubernetes 源 [root@master ~]# cat \u003c\u003cEOF \u003e /etc/yum.repos.d/kubernetes.repo [kubernetes] name=Kubernetes baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/ enabled=1 gpgcheck=1 repo_gpgcheck=1 gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg EOF [root@master ~]# # 安装 k8s 工具 1.15 版本 [root@master ~]# yum install -y kubelet kubeadm kubectl Installed: kubeadm.x86_64 0:1.15.0-0 kubectl.x86_64 0:1.15.0-0 kubelet.x86_64 0:1.15.0-0 Dependency Installed: conntrack-tools.x86_64 0:1.4.4-4.el7 cri-tools.x86_64 0:1.12.0-0 kubernetes-cni.x86_64 0:0.7.5-0 libnetfilter_cthelper.x86_64 0:1.0.0-9.el7 libnetfilter_cttimeout.x86_64 0:1.0.0-6.el7 libnetfilter_queue.x86_64 0:1.0.2-2.el7_2 socat.x86_64 0:1.7.3.2-2.el7 Complete! [root@master ~]# # 启动 kubelet [root@master ~]# systemctl enable kubelet \u0026\u0026 systemctl start kubel","date":"2019-06-30","objectID":"/2019/06/k8s-1.15.0-%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95.zh/:2:0","tags":["kubernetes","install","cluster","nginx","service"],"title":"K8s 1.15.0 安装记录","uri":"/2019/06/k8s-1.15.0-%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95.zh/"},{"categories":["Kubernetes"],"content":"主节点操作 [root@master install]# vim installK8sMasterImage.sh [root@master install]# cat installK8sMasterImage.sh #!/bin/bash set -e KUBE_VERSION=v1.15.0 KUBE_PAUSE_VERSION=3.1 ETCD_VERSION=3.3.10 CORE_DNS_VERSION=1.3.1 GCR_URL=k8s.gcr.io ALIYUN_URL=registry.cn-hangzhou.aliyuncs.com/google_containers images=(kube-proxy:${KUBE_VERSION} kube-scheduler:${KUBE_VERSION} kube-controller-manager:${KUBE_VERSION} kube-apiserver:${KUBE_VERSION} pause:${KUBE_PAUSE_VERSION} etcd:${ETCD_VERSION} coredns:${CORE_DNS_VERSION}) for imageName in ${images[@]} ; do docker pull $ALIYUN_URL/$imageName docker tag $ALIYUN_URL/$imageName $GCR_URL/$imageName docker rmi $ALIYUN_URL/$imageName done [root@master install]# chmod +x installK8sMasterImage.sh \u0026\u0026 ./installK8sMasterImage.sh root@master install]# kubeadm init --kubernetes-version=v1.15.0 --apiserver-advertise-address=192.168.33.10 --pod-network-cidr=10.244.0.0/16 [init] Using Kubernetes version: v1.15.0 [preflight] Running pre-flight checks [WARNING Hostname]: hostname \"master\" could not be reached [WARNING Hostname]: hostname \"master\": lookup master on 10.0.2.3:53: no such host [preflight] Pulling images required for setting up a Kubernetes cluster [preflight] This might take a minute or two, depending on the speed of your internet connection [preflight] You can also perform this action in beforehand using 'kubeadm config images pull' [kubelet-start] Writing kubelet environment file with flags to file \"/var/lib/kubelet/kubeadm-flags.env\" [kubelet-start] Writing kubelet configuration to file \"/var/lib/kubelet/config.yaml\" [kubelet-start] Activating the kubelet service [certs] Using certificateDir folder \"/etc/kubernetes/pki\" [certs] Generating \"front-proxy-ca\" certificate and key [certs] Generating \"front-proxy-client\" certificate and key [certs] Generating \"ca\" certificate and key [certs] Generating \"apiserver\" certificate and key [certs] apiserver serving cert is signed for DNS names [master kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local] and IPs [10.96.0.1 192.168.33.10] [certs] Generating \"apiserver-kubelet-client\" certificate and key [certs] Generating \"etcd/ca\" certificate and key [certs] Generating \"etcd/server\" certificate and key [certs] etcd/server serving cert is signed for DNS names [master localhost] and IPs [192.168.33.10 127.0.0.1 ::1] [certs] Generating \"etcd/healthcheck-client\" certificate and key [certs] Generating \"apiserver-etcd-client\" certificate and key [certs] Generating \"etcd/peer\" certificate and key [certs] etcd/peer serving cert is signed for DNS names [master localhost] and IPs [192.168.33.10 127.0.0.1 ::1] [certs] Generating \"sa\" key and public key [kubeconfig] Using kubeconfig folder \"/etc/kubernetes\" [kubeconfig] Writing \"admin.conf\" kubeconfig file [kubeconfig] Writing \"kubelet.conf\" kubeconfig file [kubeconfig] Writing \"controller-manager.conf\" kubeconfig file [kubeconfig] Writing \"scheduler.conf\" kubeconfig file [control-plane] Using manifest folder \"/etc/kubernetes/manifests\" [control-plane] Creating static Pod manifest for \"kube-apiserver\" [control-plane] Creating static Pod manifest for \"kube-controller-manager\" [control-plane] Creating static Pod manifest for \"kube-scheduler\" [etcd] Creating static Pod manifest for local etcd in \"/etc/kubernetes/manifests\" [wait-control-plane] Waiting for the kubelet to boot up the control plane as static Pods from directory \"/etc/kubernetes/manifests\". This can take up to 4m0s [apiclient] All control plane components are healthy after 26.502984 seconds [upload-config] Storing the configuration used in ConfigMap \"kubeadm-config\" in the \"kube-system\" Namespace [kubelet] Creating a ConfigMap \"kubelet-config-1.15\" in namespace kube-system with the configuration for the kubelets in the cluster [upload-certs] Skipping phase. Please see --upload-certs [mark-control-plane] Marking the node master as control-plane by adding the label \"node-role.kubernetes.io/master=''\" [mark-control-plane] Mar","date":"2019-06-30","objectID":"/2019/06/k8s-1.15.0-%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95.zh/:3:0","tags":["kubernetes","install","cluster","nginx","service"],"title":"K8s 1.15.0 安装记录","uri":"/2019/06/k8s-1.15.0-%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95.zh/"},{"categories":["Kubernetes"],"content":"各 Node 节点上处理 [root@node2 install]# vim installK8sNodeImage.sh [root@node5 install]# cat installK8sNodeImage.sh #!/bin/bash set -e KUBE_VERSION=v1.15.0 KUBE_PAUSE_VERSION=3.1 CORE_DNS_VERSION=1.3.1 GCR_URL=k8s.gcr.io ALIYUN_URL=registry.cn-hangzhou.aliyuncs.com/google_containers images=(kube-proxy:${KUBE_VERSION} pause:${KUBE_PAUSE_VERSION} coredns:${CORE_DNS_VERSION}) for imageName in ${images[@]} ; do docker pull $ALIYUN_URL/$imageName docker tag $ALIYUN_URL/$imageName $GCR_URL/$imageName docker rmi $ALIYUN_URL/$imageName done [root@node1 ~]# chmod +x installK8sNodeImage.sh \u0026\u0026 ./installK8sNodeImage.sh v1.15.0: Pulling from google_containers/kube-proxy 39fafc05754f: Pull complete db3f71d0eb90: Pull complete b593bfa65f6f: Pull complete Digest: sha256:7b94921f1c64876d3663698ade724fce79b417b32f0e1053976ca68a18fc0cba Status: Downloaded newer image for registry.cn-hangzhou.aliyuncs.com/google_containers/kube-proxy:v1.15.0 Untagged: registry.cn-hangzhou.aliyuncs.com/google_containers/kube-proxy:v1.15.0 Untagged: registry.cn-hangzhou.aliyuncs.com/google_containers/kube-proxy@sha256:7b94921f1c64876d3663698ade724fce79b417b32f0e1053976ca68a18fc0cba 3.1: Pulling from google_containers/pause cf9202429979: Pull complete Digest: sha256:759c3f0f6493093a9043cc813092290af69029699ade0e3dbe024e968fcb7cca Status: Downloaded newer image for registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.1 Untagged: registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.1 Untagged: registry.cn-hangzhou.aliyuncs.com/google_containers/pause@sha256:759c3f0f6493093a9043cc813092290af69029699ade0e3dbe024e968fcb7cca 1.3.1: Pulling from google_containers/coredns e0daa8927b68: Pull complete 3928e47de029: Pull complete Digest: sha256:638adb0319813f2479ba3642bbe37136db8cf363b48fb3eb7dc8db634d8d5a5b Status: Downloaded newer image for registry.cn-hangzhou.aliyuncs.com/google_containers/coredns:1.3.1 Untagged: registry.cn-hangzhou.aliyuncs.com/google_containers/coredns:1.3.1 Untagged: registry.cn-hangzhou.aliyuncs.com/google_containers/coredns@sha256:638adb0319813f2479ba3642bbe37136db8cf363b48fb3eb7dc8db634d8d5a5b [root@node1 ~]# [root@node5 install]# # Node 加入集群 [root@node1 install]# kubeadm join 192.168.33.10:6443 --token sofcoc.j1it9gvn4uxpduo5 \\ \u003e --discovery-token-ca-cert-hash sha256:3a9b79bd92f66a6284322ade27732932888c0f99884596d5f2c9a03d272e475b [preflight] Running pre-flight checks [preflight] Reading configuration from the cluster... [preflight] FYI: You can look at this config file with 'kubectl -n kube-system get cm kubeadm-config -oyaml' [kubelet-start] Downloading configuration for the kubelet from the \"kubelet-config-1.15\" ConfigMap in the kube-system namespace [kubelet-start] Writing kubelet configuration to file \"/var/lib/kubelet/config.yaml\" [kubelet-start] Writing kubelet environment file with flags to file \"/var/lib/kubelet/kubeadm-flags.env\" [kubelet-start] Activating the kubelet service [kubelet-start] Waiting for the kubelet to perform the TLS Bootstrap... This node has joined the cluster: * Certificate signing request was sent to apiserver and a response was received. * The Kubelet was informed of the new secure connection details. Run 'kubectl get nodes' on the control-plane to see this node join the cluster. [root@node1 install]# ","date":"2019-06-30","objectID":"/2019/06/k8s-1.15.0-%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95.zh/:4:0","tags":["kubernetes","install","cluster","nginx","service"],"title":"K8s 1.15.0 安装记录","uri":"/2019/06/k8s-1.15.0-%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95.zh/"},{"categories":["Kubernetes"],"content":"master 节点操作 [root@master ~]# #将 master 节点也作为工作节点进行 pod 部署 [root@master ~]# kubectl taint nodes master node-role.kubernetes.io/master- node/master untainted ","date":"2019-06-30","objectID":"/2019/06/k8s-1.15.0-%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95.zh/:5:0","tags":["kubernetes","install","cluster","nginx","service"],"title":"K8s 1.15.0 安装记录","uri":"/2019/06/k8s-1.15.0-%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95.zh/"},{"categories":["Kubernetes"],"content":"打 label [root@master temp]# kubectl label node master nodename=master node/master labeled [root@master temp]# kubectl label node node1 nodename=node1 node/node1 labeled [root@master temp]# kubectl label node node2 nodename=node2 node/node2 labeled [root@master temp]# kubectl label node node3 nodename=node3 node/node3 labeled [root@master temp]# kubectl label node node4 nodename=node4 node/node4 labeled [root@master temp]# kubectl label node node5 nodename=node5 node/node5 labeled ","date":"2019-06-30","objectID":"/2019/06/k8s-1.15.0-%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95.zh/:6:0","tags":["kubernetes","install","cluster","nginx","service"],"title":"K8s 1.15.0 安装记录","uri":"/2019/06/k8s-1.15.0-%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95.zh/"},{"categories":["Kubernetes"],"content":"测试 vim nginx-deployment.yaml apiVersion:apps/v1kind:Deploymentmetadata:name:nginx-deploymentlabels:app:nginxspec:replicas:1selector:matchLabels:app:nginxtemplate:metadata:labels:app:nginxspec:containers:- name:nginximage:nginx:1.7.9imagePullPolicy:IfNotPresentports:- containerPort:80name:webprotocol:TCPnodeSelector:nodename:master---apiVersion:v1kind:Servicemetadata:name:nginx-servicelabels:app:nginxspec:ports:- port:80targetPort:8080name:webselector:app-name:nginx---apiVersion:extensions/v1beta1kind:Ingressmetadata:name:nginxnamespace:defaultspec:rules:- host:c4.k8s.comhttp:paths:- path:/nginxbackend:serviceName:nginx-serviceservicePort:8080 [root@master temp]# kubectl apply -f nginx-deployment.yaml deployment.apps/nginx-deployment created service/nginx-service created ingress.extensions/nginx created [root@master temp]# kubectl get service/nginx-service NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE nginx-service ClusterIP 10.100.2.78 \u003cnone\u003e 80/TCP 38s [root@master temp]# kubectl get ing NAME HOSTS ADDRESS PORTS AGE nginx c4.k8s.com 80 4m5s [root@master temp]# wget c4.k8s.com --2019-06-30 07:12:18-- http://c4.k8s.com/ Resolving c4.k8s.com (c4.k8s.com)... 208.73.211.177, 208.73.210.202, 208.73.211.165, ... Connecting to c4.k8s.com (c4.k8s.com)|208.73.211.177|:80... connected. HTTP request sent, awaiting response... 302 Found : Moved Temporarily Location: http://1223.dragonparking.com/?site=c4.k8s.com [following] --2019-06-30 07:12:19-- http://1223.dragonparking.com/?site=c4.k8s.com Resolving 1223.dragonparking.com (1223.dragonparking.com)... 46.51.238.1 Connecting to 1223.dragonparking.com (1223.dragonparking.com)|46.51.238.1|:80... connected. HTTP request sent, awaiting response... 302 Moved Temporarily Location: http://park.zunmi.cn/?acct=1223\u0026site=c4.k8s.com [following] --2019-06-30 07:12:21-- http://park.zunmi.cn/?acct=1223\u0026site=c4.k8s.com Resolving park.zunmi.cn (park.zunmi.cn)... 52.197.205.2 Connecting to park.zunmi.cn (park.zunmi.cn)|52.197.205.2|:80... connected. HTTP request sent, awaiting response... 200 OK Length: 1020 [text/html] Saving to: ‘index.html’ 100%[======================================================================================================================================\u003e] 1,020 --.-K/s in 0s 2019-06-30 07:12:22 (93.5 MB/s) - ‘index.html’ saved [1020/1020] [root@master temp]# ll total 8 -rw-r--r--. 1 root root 1020 May 6 23:28 index.html -rw-r--r--. 1 root root 908 Jun 30 07:07 nginx-deployment.yaml [root@master temp]# kubectl delete -f nginx-deployment.yaml deployment.apps \"nginx-deployment\" deleted service \"nginx-service\" deleted ingress.extensions \"nginx\" deleted ","date":"2019-06-30","objectID":"/2019/06/k8s-1.15.0-%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95.zh/:7:0","tags":["kubernetes","install","cluster","nginx","service"],"title":"K8s 1.15.0 安装记录","uri":"/2019/06/k8s-1.15.0-%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95.zh/"},{"categories":["Kubernetes"],"content":"Refs 1. 博客：https://guzhongren.github.io/ 2. 图床：https://sm.ms/ 3. 原文：https://yq.aliyun.com/articles/706912?spm=a2c4e.11155435.0.0.59853312vRSRSj ","date":"2019-06-30","objectID":"/2019/06/k8s-1.15.0-%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95.zh/:8:0","tags":["kubernetes","install","cluster","nginx","service"],"title":"K8s 1.15.0 安装记录","uri":"/2019/06/k8s-1.15.0-%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95.zh/"},{"categories":["Kubernetes"],"content":"Disclaimer 本文仅代表个人观点，与 Thoughtworks 公司无任何关系。 ","date":"2019-06-30","objectID":"/2019/06/k8s-1.15.0-%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95.zh/:9:0","tags":["kubernetes","install","cluster","nginx","service"],"title":"K8s 1.15.0 安装记录","uri":"/2019/06/k8s-1.15.0-%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95.zh/"},{"categories":["Docker","Golang","shell","Registry","harbor","docker-compose"],"content":"场景 在搭建私有云环境时，我们需要将我们打包的镜像存储在局域网内，而不是把镜像推送到 hub.docker.com；一方面是因为安全问题，另一方面在局域网内存储，网速炒鸡快。当然对于私有云搭建，在本地搭建镜像仓库那是必须的。接下来，对我安装 Harbor 做一个记录。 ","date":"2019-06-09","objectID":"/2019/06/harbor-%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0.zh/:1:0","tags":["Docker"],"title":"Harbor 安装小记","uri":"/2019/06/harbor-%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0.zh/"},{"categories":["Docker","Golang","shell","Registry","harbor","docker-compose"],"content":"分析 因为 Harbor 是用 docker 跑起来的，所以我们的机器上必须有 docker 环境，还有比较中要的一点，Harbor 需要使用 docker-compose, 所以需要 docker-compose。 ","date":"2019-06-09","objectID":"/2019/06/harbor-%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0.zh/:2:0","tags":["Docker"],"title":"Harbor 安装小记","uri":"/2019/06/harbor-%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0.zh/"},{"categories":["Docker","Golang","shell","Registry","harbor","docker-compose"],"content":"安装 ","date":"2019-06-09","objectID":"/2019/06/harbor-%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0.zh/:3:0","tags":["Docker"],"title":"Harbor 安装小记","uri":"/2019/06/harbor-%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0.zh/"},{"categories":["Docker","Golang","shell","Registry","harbor","docker-compose"],"content":"docker 安装 略。..（相信你肯定不会怪我） ","date":"2019-06-09","objectID":"/2019/06/harbor-%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0.zh/:3:1","tags":["Docker"],"title":"Harbor 安装小记","uri":"/2019/06/harbor-%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0.zh/"},{"categories":["Docker","Golang","shell","Registry","harbor","docker-compose"],"content":"docker-compose 安装 $ sudo curl -L \"https://github.com/docker/compose/releases/download/1.24.0/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose $ sudo chmod +x /usr/local/bin/docker-compose $ docker-compose --version docker-compose version 1.24.0, build 1110ad01 ","date":"2019-06-09","objectID":"/2019/06/harbor-%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0.zh/:3:2","tags":["Docker"],"title":"Harbor 安装小记","uri":"/2019/06/harbor-%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0.zh/"},{"categories":["Docker","Golang","shell","Registry","harbor","docker-compose"],"content":"安装 Harbor 离线安装版 获取并解压 $ wget https://storage.googleapis.com/harbor-releases/release-1.8.0/harbor-offline-installer-v1.8.0.tgz $ tar xvf harbor-offline-installer-v1.8.0.tgz 解压会生成 Harbor 文件夹 修改配置文件 $ cd Harbor $ vim /Harbor.yaml 需要配置的地方有几处，但最重要的是 hostname, hostname 必须指定为域名，不能使 localhost,127.0.0.1 这样的地址，别的密码、端口可可定义。如下是我的配置 # Configuration file of Harbor# The IP address or hostname to access admin UI and registry service.# DO NOT use localhost or 127.0.0.1, because Harbor needs to be accessed by external clients.hostname:hub.k8s.com# http related confighttp:# port for http, default is 80. If https enabled, this port will redirect to https portport:80# https related config# https:# # https port for harbor, default is 443# port: 443# # The path of cert and key files for nginx# certificate: /your/certificate/path# private_key: /your/private/key/path# Uncomment external_url if you want to enable external proxy# And when it enabled the hostname will no longer used# external_url: https://reg.mydomain.com:8433# The initial password of Harbor admin# It only works in first time to install harbor# Remember Change the admin password from UI after launching Harbor.harbor_admin_password:Harbor12345# Harbor DB configurationdatabase:# The password for the root user of Harbor DB. Change this before any production use.password:root123# The default data volumedata_volume:/data# Harbor Storage settings by default is using /data dir on local filesystem# Uncomment storage_service setting If you want to using external storage# storage_service:# # ca_bundle is the path to the custom root ca certificate, which will be injected into the truststore# # of registry's and chart repository's containers. This is usually needed when the user hosts a internal storage with self signed certificate.# ca_bundle:# # storage backend, default is filesystem, options include filesystem, azure, gcs, s3, swift and oss# # for more info about this configuration please refer https://docs.docker.com/registry/configuration/# filesystem:# maxthreads: 100# # set disable to true when you want to disable registry redirect# redirect:# disabled: false# Clair configurationclair:# The interval of clair updaters, the unit is hour, set to 0 to disable the updaters.updaters_interval:12# Config http proxy for Clair, e.g. http://my.proxy.com:3128# Clair doesn't need to connect to harbor internal components via http proxy.http_proxy:https_proxy:no_proxy:127.0.0.1,localhost,core,registryjobservice:# Maximum number of job workers in job servicemax_job_workers:10chart:# Change the value of absolute_url to enabled can enable absolute url in chartabsolute_url:disabled# Log configurationslog:# options are debug, info, warning, error, fatallevel:info# Log files are rotated log_rotate_count times before being removed. If count is 0, old versions are removed rather than rotated.rotate_count:50# Log files are rotated only if they grow bigger than log_rotate_size bytes. If size is followed by k, the size is assumed to be in kilobytes.# If the M is used, the size is in megabytes, and if G is used, the size is in gigabytes. So size 100, size 100k, size 100M and size 100G# are all valid.rotate_size:200M# The directory on your host that store loglocation:/var/log/harbor#This attribute is for migrator to detect the version of the .cfg file, DO NOT MODIFY!_version:1.8.0# Uncomment external_database if using external database. Currently only support POSTGRES.# Four databases are needed to be create first by users for Harbor core, Clair, Notary server# and Notary signer. And the tables will be generated automatically when Harbor starting up.# NOTE: external_database is unable to custom attributes individually, you must do them in block.# external_database:# harbor:# host: harbor_db_host# port: harbor_db_port# db_name: harbor_db_name# username: harbor_db_username# password: harbor_db_password# ssl_mode: disable# clair:# host: clair_db_host# port: clair_db_port# db_name: clair_db_name# username: clair_db_username","date":"2019-06-09","objectID":"/2019/06/harbor-%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0.zh/:3:3","tags":["Docker"],"title":"Harbor 安装小记","uri":"/2019/06/harbor-%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0.zh/"},{"categories":["Docker","Golang","shell","Registry","harbor","docker-compose"],"content":"配置/etc/docker/daemon.json 配置此项的目的是让 docker push 可以将镜像推送到私有仓库中 $ vim /etc/docker/daemon.json { \"registry-mirrors\": [\"https://gmjjwogo.mirror.aliyuncs.com\"], \"insecure-registries\": [\"hub.k8s.com\"] # 追加内容，必须符合 json 规范 } 重启 docker $ systemctl restart docker 将本地 golang 镜像推送到私有仓库 $ docker login hub.k8s.com Username: admin Password: WARNING! Your password will be stored unencrypted in /root/.docker/config.json. Configure a credential helper to remove this warning. See https://docs.docker.com/engine/reference/commandline/login/#credentials-store Login Succeeded 为 golang 打标签并推送镜像 $ docker tag golang:alpine hub.k8s.com/cms/golang:alpine $ docker push hub.k8s.com/cms/golang:alpine The push refers to repository [hub.k8s.com/cms/golang] 23419e186866: Pushed 1f6ba46a9c52: Pushed 968d46c1d20e: Pushed b87598efb2f0: Pushed f1b5933fe4b5: Pushed alpine: digest: sha256:5ec3232b32e6876c0941d66d8392f667c77ca1ef14cafb85991deea4339b92da size: 1365 ","date":"2019-06-09","objectID":"/2019/06/harbor-%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0.zh/:3:4","tags":["Docker"],"title":"Harbor 安装小记","uri":"/2019/06/harbor-%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0.zh/"},{"categories":["Docker","Golang","shell","Registry","harbor","docker-compose"],"content":"小结 Harbor 是一个 docker 镜像私有仓库的解决方案，是基于 docker-compose 运行起来的，使用相对简单。 ","date":"2019-06-09","objectID":"/2019/06/harbor-%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0.zh/:4:0","tags":["Docker"],"title":"Harbor 安装小记","uri":"/2019/06/harbor-%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0.zh/"},{"categories":["Docker","Golang","shell","Registry","harbor","docker-compose"],"content":"Refs 1. 博客：https://guzhongren.github.io/* ","date":"2019-06-09","objectID":"/2019/06/harbor-%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0.zh/:5:0","tags":["Docker"],"title":"Harbor 安装小记","uri":"/2019/06/harbor-%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0.zh/"},{"categories":["Docker","Golang","shell","Registry","harbor","docker-compose"],"content":"Disclaimer 本文仅代表个人观点，与 Thoughtworks 公司无任何关系。 ","date":"2019-06-09","objectID":"/2019/06/harbor-%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0.zh/:6:0","tags":["Docker"],"title":"Harbor 安装小记","uri":"/2019/06/harbor-%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0.zh/"},{"categories":["Golang"],"content":" go: golang.org/x/sys@v0.0.0-20180905080454-ebe1bf3edb33: unrecognized import path \"golang.orgnrecognized import path \"golang.org/x/sys\" (https fetch: G1: dial tcp 216.239.37.1:443: conneet https://golang.org/x/sys?go-get=1: dial tcp 216.239.37.rty did not properly respond after1:443: connectex: A connection attempt failed because the connected host has failed to respoconnected party did not properly respond after a period of time, or established connection failed because connected : unrecognized import path \"golang.host has failed to respond.) ... go: golang.org/x/crypto@v0.0.0-20180904163835-0709b304e793nected party did not properly respo: unrecognized import path \"golang.org/x/crypto\" (https fed because connected host has failedtch: Get https://golang.org/x/crypto?go-get=1: dial tcp 216.239.37.1:443: connectex: A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond.) go: error loading module requirements ","date":"2018-11-01","objectID":"/2018/11/go-module-%E5%AE%89%E8%A3%85%E4%B8%8D%E4%BA%86golang.org%E6%97%B6%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E8%AE%B0%E5%BD%95.zh/:0:0","tags":["golang","go","shell","path","github","module"],"title":"Go Module 安装不了 golang.org 时的处理方式记录","uri":"/2018/11/go-module-%E5%AE%89%E8%A3%85%E4%B8%8D%E4%BA%86golang.org%E6%97%B6%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E8%AE%B0%E5%BD%95.zh/"},{"categories":["Golang"],"content":"如上，不能安装 sys 和 crypto 这两个库，用如下方式即可 1 手动加入被墙的包（原始包），一定要记住版本号，实在不知道的话，就试试 v0.0.0； $ go mod edit -require=golang.org/x/net@v0.0.0 2 用 github 上的镜像地址替换 $ go mod edit -replace=golang.org/x/crypto@v0.0.0=github.com/golang/crypto@latest $ go mod edit -replace=golang.org/x/sys@v0.0.0=github.com/golang/sys@latest ","date":"2018-11-01","objectID":"/2018/11/go-module-%E5%AE%89%E8%A3%85%E4%B8%8D%E4%BA%86golang.org%E6%97%B6%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E8%AE%B0%E5%BD%95.zh/:1:0","tags":["golang","go","shell","path","github","module"],"title":"Go Module 安装不了 golang.org 时的处理方式记录","uri":"/2018/11/go-module-%E5%AE%89%E8%A3%85%E4%B8%8D%E4%BA%86golang.org%E6%97%B6%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E8%AE%B0%E5%BD%95.zh/"},{"categories":["Golang"],"content":"Refs 1. 博客：https://guzhongren.github.io/ 2. 图床：https://sm.ms/ 3. 原文：https://yq.aliyun.com/articles/663151?spm=a2c4e.11155435.0.0.3c783312bi9tbU ","date":"2018-11-01","objectID":"/2018/11/go-module-%E5%AE%89%E8%A3%85%E4%B8%8D%E4%BA%86golang.org%E6%97%B6%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E8%AE%B0%E5%BD%95.zh/:2:0","tags":["golang","go","shell","path","github","module"],"title":"Go Module 安装不了 golang.org 时的处理方式记录","uri":"/2018/11/go-module-%E5%AE%89%E8%A3%85%E4%B8%8D%E4%BA%86golang.org%E6%97%B6%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E8%AE%B0%E5%BD%95.zh/"},{"categories":["Golang"],"content":"Disclaimer 本文仅代表个人观点，与 Thoughtworks 公司无任何关系。 ","date":"2018-11-01","objectID":"/2018/11/go-module-%E5%AE%89%E8%A3%85%E4%B8%8D%E4%BA%86golang.org%E6%97%B6%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E8%AE%B0%E5%BD%95.zh/:3:0","tags":["golang","go","shell","path","github","module"],"title":"Go Module 安装不了 golang.org 时的处理方式记录","uri":"/2018/11/go-module-%E5%AE%89%E8%A3%85%E4%B8%8D%E4%BA%86golang.org%E6%97%B6%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E8%AE%B0%E5%BD%95.zh/"},{"categories":["Golang"],"content":" go: golang.org/x/sys@v0.0.0-20180905080454-ebe1bf3edb33: unrecognized import path \"golang.orgnrecognized import path \"golang.org/x/sys\" (https fetch: G1: dial tcp 216.239.37.1:443: conneet https://golang.org/x/sys?go-get=1: dial tcp 216.239.37.rty did not properly respond after1:443: connectex: A connection attempt failed because the connected host has failed to respoconnected party did not properly respond after a period of time, or established connection failed because connected : unrecognized import path \"golang.host has failed to respond.) ... go: golang.org/x/crypto@v0.0.0-20180904163835-0709b304e793nected party did not properly respo: unrecognized import path \"golang.org/x/crypto\" (https fed because connected host has failedtch: Get https://golang.org/x/crypto?go-get=1: dial tcp 216.239.37.1:443: connectex: A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond.) go: error loading module requirements ","date":"2018-11-01","objectID":"/2018/11/go-module-%E5%AE%89%E8%A3%85%E4%B8%8D%E4%BA%86golang.org%E6%97%B6%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E8%AE%B0%E5%BD%95.zh/:0:0","tags":["golang","go","shell","path","github","module"],"title":"Go Module 安装不了 golang.org 时的处理方式记录","uri":"/2018/11/go-module-%E5%AE%89%E8%A3%85%E4%B8%8D%E4%BA%86golang.org%E6%97%B6%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E8%AE%B0%E5%BD%95.zh/"},{"categories":["Golang"],"content":"如上，不能安装 sys 和 crypto 这两个库，用如下方式即可 1 手动加入被墙的包（原始包），一定要记住版本号，实在不知道的话，就试试 v0.0.0； $ go mod edit -require=golang.org/x/net@v0.0.0 2 用 github 上的镜像地址替换 $ go mod edit -replace=golang.org/x/crypto@v0.0.0=github.com/golang/crypto@latest $ go mod edit -replace=golang.org/x/sys@v0.0.0=github.com/golang/sys@latest ","date":"2018-11-01","objectID":"/2018/11/go-module-%E5%AE%89%E8%A3%85%E4%B8%8D%E4%BA%86golang.org%E6%97%B6%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E8%AE%B0%E5%BD%95.zh/:1:0","tags":["golang","go","shell","path","github","module"],"title":"Go Module 安装不了 golang.org 时的处理方式记录","uri":"/2018/11/go-module-%E5%AE%89%E8%A3%85%E4%B8%8D%E4%BA%86golang.org%E6%97%B6%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E8%AE%B0%E5%BD%95.zh/"},{"categories":["Golang"],"content":"Refs 1. 博客：https://guzhongren.github.io/ 2. 图床：https://sm.ms/ 3. 原文：https://yq.aliyun.com/articles/663151?spm=a2c4e.11155435.0.0.3c783312bi9tbU ","date":"2018-11-01","objectID":"/2018/11/go-module-%E5%AE%89%E8%A3%85%E4%B8%8D%E4%BA%86golang.org%E6%97%B6%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E8%AE%B0%E5%BD%95.zh/:2:0","tags":["golang","go","shell","path","github","module"],"title":"Go Module 安装不了 golang.org 时的处理方式记录","uri":"/2018/11/go-module-%E5%AE%89%E8%A3%85%E4%B8%8D%E4%BA%86golang.org%E6%97%B6%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E8%AE%B0%E5%BD%95.zh/"},{"categories":["Golang"],"content":"Disclaimer 本文仅代表个人观点，与 Thoughtworks 公司无任何关系。 ","date":"2018-11-01","objectID":"/2018/11/go-module-%E5%AE%89%E8%A3%85%E4%B8%8D%E4%BA%86golang.org%E6%97%B6%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E8%AE%B0%E5%BD%95.zh/:3:0","tags":["golang","go","shell","path","github","module"],"title":"Go Module 安装不了 golang.org 时的处理方式记录","uri":"/2018/11/go-module-%E5%AE%89%E8%A3%85%E4%B8%8D%E4%BA%86golang.org%E6%97%B6%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E8%AE%B0%E5%BD%95.zh/"},{"categories":["npm"],"content":"引言 我们大多数情况下用到的包都是存放在 npmjs.com 这个网站上的，只要我们安装了 Node，我们就可以使用 Node 自带的 npm 包来下载你需要的包；但有时候我们想让我们自己的包或者库私有，哪怎么办呢？很多人就会想到自己搭一个私服，比如 Nexus Repository Manager 和 sinopia;　虽然搭建起来不是很困难，尤其是 sinopia 就是一个 npm 包，安装灰常简单，但是都需要一台服务器，一台服务。.. 一台服。.. 一台。.. 一。.. 现在大多数公司肯定有自己的 git 仓库了，[没有到 git？说明你们技术太 XXX 落后] 那么我们何不利用 git 仓库来存放我们的各种 lib 呢？ ","date":"2018-10-19","objectID":"/2018/10/npm-%E5%AE%89%E8%A3%85git%E8%B5%84%E6%BA%90.zh/:1:0","tags":["npm","git","registry","私服"],"title":"Npm 安装 git 资源","uri":"/2018/10/npm-%E5%AE%89%E8%A3%85git%E8%B5%84%E6%BA%90.zh/"},{"categories":["npm"],"content":"传统方式 前事不忘，后事之师。先来复习一下怎么从 npmjs.com 获取包。[这句是我说的] $ npm install XXX ... ","date":"2018-10-19","objectID":"/2018/10/npm-%E5%AE%89%E8%A3%85git%E8%B5%84%E6%BA%90.zh/:2:0","tags":["npm","git","registry","私服"],"title":"Npm 安装 git 资源","uri":"/2018/10/npm-%E5%AE%89%E8%A3%85git%E8%B5%84%E6%BA%90.zh/"},{"categories":["npm"],"content":"git 仓库 假如你已经做了一个特别牛逼的库，但是因为只是公司内部使用，比如一些工具库，放出去比如放到 npmjs.com 上没任何意义的，你可以把这个库整理成一个 git 的 repo, 当然打个标签，发个各版本什么的那就更好了。当你把你牛逼的库放在你司的 git 上后，比如地址是 ssh:git.niubi.com/yourName/niubility.git　或者　https://git.niubi.com/yourName/niubility.git, 接下来就是发大招。 ","date":"2018-10-19","objectID":"/2018/10/npm-%E5%AE%89%E8%A3%85git%E8%B5%84%E6%BA%90.zh/:3:0","tags":["npm","git","registry","私服"],"title":"Npm 安装 git 资源","uri":"/2018/10/npm-%E5%AE%89%E8%A3%85git%E8%B5%84%E6%BA%90.zh/"},{"categories":["npm"],"content":"大招 $ npm install git+ssh:git.niubi.com/yourName/niubility.git ... **#或者** $ npm install git+https://git.niubi.com/yourName/niubility.git ... ","date":"2018-10-19","objectID":"/2018/10/npm-%E5%AE%89%E8%A3%85git%E8%B5%84%E6%BA%90.zh/:4:0","tags":["npm","git","registry","私服"],"title":"Npm 安装 git 资源","uri":"/2018/10/npm-%E5%AE%89%E8%A3%85git%E8%B5%84%E6%BA%90.zh/"},{"categories":["npm"],"content":"隐藏技能 [不推荐] ","date":"2018-10-19","objectID":"/2018/10/npm-%E5%AE%89%E8%A3%85git%E8%B5%84%E6%BA%90.zh/:5:0","tags":["npm","git","registry","私服"],"title":"Npm 安装 git 资源","uri":"/2018/10/npm-%E5%AE%89%E8%A3%85git%E8%B5%84%E6%BA%90.zh/"},{"categories":["npm"],"content":"用户名方式 如果你将 npm 注册到自己的 git 仓库，就可以直接省去域名等一切能定位到该 lib 的的通用信息。 注册及登录 $ npm adduser --registry http://you.domain.com ... $ npm login --registry http://you.domain.com ... 安装 $ npm install yourName/niubility ... ","date":"2018-10-19","objectID":"/2018/10/npm-%E5%AE%89%E8%A3%85git%E8%B5%84%E6%BA%90.zh/:5:1","tags":["npm","git","registry","私服"],"title":"Npm 安装 git 资源","uri":"/2018/10/npm-%E5%AE%89%E8%A3%85git%E8%B5%84%E6%BA%90.zh/"},{"categories":["npm"],"content":"恩，没什么可说的了我真是来测试打赏功能的。 ","date":"2018-10-19","objectID":"/2018/10/npm-%E5%AE%89%E8%A3%85git%E8%B5%84%E6%BA%90.zh/:6:0","tags":["npm","git","registry","私服"],"title":"Npm 安装 git 资源","uri":"/2018/10/npm-%E5%AE%89%E8%A3%85git%E8%B5%84%E6%BA%90.zh/"},{"categories":["npm"],"content":"Refs 1. 博客：https://guzhongren.github.io/ 2. 图床：https://sm.ms/ 3. 原文：https://yq.aliyun.com/articles/655108?spm=a2c4e.11155435.0.0.3c783312bi9tbU ","date":"2018-10-19","objectID":"/2018/10/npm-%E5%AE%89%E8%A3%85git%E8%B5%84%E6%BA%90.zh/:7:0","tags":["npm","git","registry","私服"],"title":"Npm 安装 git 资源","uri":"/2018/10/npm-%E5%AE%89%E8%A3%85git%E8%B5%84%E6%BA%90.zh/"},{"categories":["npm"],"content":"Disclaimer 本文仅代表个人观点，与 Thoughtworks 公司无任何关系。 ","date":"2018-10-19","objectID":"/2018/10/npm-%E5%AE%89%E8%A3%85git%E8%B5%84%E6%BA%90.zh/:8:0","tags":["npm","git","registry","私服"],"title":"Npm 安装 git 资源","uri":"/2018/10/npm-%E5%AE%89%E8%A3%85git%E8%B5%84%E6%BA%90.zh/"}]